[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Einführung in die Datenwissenschaft mit Excel",
    "section": "",
    "text": "Vorwort\nWork in Progress\n\n\nCopyright\nDieses Werk ist lizenziert unter einer Creative Commons Namensnennung - Nicht-kommerziell - Weitergabe unter gleichen Bedingungen 4.0 International Lizenz (CC-BY-NC-SA). Details zur Nutzungsbedingungen und dem Copyright finden sich unter createivecommons.org.\n2023, Christian Glahn, Zurich, Switzerland\n\n\n\n\n\nDie PDF-Version liegt hier zum Download"
  },
  {
    "objectID": "kapitel/einleitung/kapitel.html#ziele",
    "href": "kapitel/einleitung/kapitel.html#ziele",
    "title": "1  Einleitung",
    "section": "1.1 Ziele",
    "text": "1.1 Ziele\n\n\n\nAbbildung 1.1: Ziele und Themen"
  },
  {
    "objectID": "kapitel/einleitung/kapitel.html#organisation-dieses-buchs",
    "href": "kapitel/einleitung/kapitel.html#organisation-dieses-buchs",
    "title": "1  Einleitung",
    "section": "1.2 Organisation dieses Buchs",
    "text": "1.2 Organisation dieses Buchs"
  },
  {
    "objectID": "kapitel/einleitung/excel-versionen.html#excel-versionen-und-betriebssysteme",
    "href": "kapitel/einleitung/excel-versionen.html#excel-versionen-und-betriebssysteme",
    "title": "2  Excel Versionen",
    "section": "2.1 Excel-Versionen und Betriebssysteme",
    "text": "2.1 Excel-Versionen und Betriebssysteme\nExcel365 unterscheidet sich leicht für MacOS und Windows. Im Rahmen dieses Buchs stellt das keine Einschränkung dar, denn die Unterschiede sind gering.\nDie auffälligsten Unterschiede betreffen den Importer und die bedingte Formatierung.\n\nDer Importer ist unter Windows etwas flexibeler gestaltet als unter MacOS. Dieser Unterschied betrifft den Inhalt dieses Buchs nicht.\nDie bedingte Formatierung wird unter MacOS traditionell mit einen völlig andereren Dialog konfiguriert wird als unter Windows.\n\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nIn den (wenigen) Fällen, in denen sich die Excel-Versionen auf den beiden Betriebssystemen unterscheiden, wird der Unterschied durch eine MacOS vs. Windows-Box - wie diese hier - gesondert hervorgehoben. Das gleiche gilt für die Eigenheiten, die nur auf einem der beiden Betriebssyeme vorkommen.\n\n\n\n\n\n\n\n\nMacOS\n\n\n\nSoll unter MacOS Excel365 eine alte Version ohne Abonement ersetzen, dann muss die alte Version zuerst deinstalliert werden. Sind zusätzlich andere Office-Programme von Microsoft ohne Abonement installiert, dann müssen diese ebenfalls deinstalliert werden. Beim Deinstallieren werden die Konfigurationsdateien nicht gelöscht. Diese müssen manuell gelöscht werden. Erst jetzt kann die neue Version von Microsoft365 installiert werden."
  },
  {
    "objectID": "kapitel/einleitung/excel-versionen.html#excel-und-sprachen",
    "href": "kapitel/einleitung/excel-versionen.html#excel-und-sprachen",
    "title": "2  Excel Versionen",
    "section": "2.2 Excel und Sprachen",
    "text": "2.2 Excel und Sprachen\nExcel365 ist in vielen Sprachen verfügbar. Die Sprache wird von Excel vom Betriebssystem übernommen. Dieses Buch bezieht sich auf die deutschsprachige Excel Version mit Schweizer Regionseinstellungen. Alle Beispiele lassen sich in allen anderen Sprachen nachvollziehen, wenn die Werte und Funktionsnamen entsprechend angepasst werden.\n\n\n\n\n\n\nWarnung\n\n\n\nDie Funktionsnamen unterscheiden sich stark zwischen den einzelnen Sprachen. Oft ist es unmöglich, die Funktionsnamen durch eine Übersetzung des Funktionsnamen aus einer anderen Sprache abzuleiten.\nBeispielsweise heisst der englische Funktionsname OFFSET() (deutsch: Versatz) auf Deutsch BEREICH.VERSCHIEBEN() (engl. move range).\n\n\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nUnter MacOS kann die Sprache von Excel365 ausschliesslich über die Systemeinstellungen geändert werden. Die Spracheinstellung wird vom Betriebssystem übernommen. Dadurch verändert sich die Sprache aller Programme, die auf dem Computer installiert sind. Wird die Sprache von MacOS geändert, dann muss der Computer neu gestartet werden, damit die Änderung wirksam wird. Dieser Schritt verändert jedoch nicht nur die Sprache von Menus sondern auch die Namen vieler Verzeichnisse. Deshalb wird dieser Schritt nicht empfohlen.\nUnter Windows kann die Sprache nur für Excel365 geändert werden. Dazu muss in Excel unter Datei &gt; Optionen &gt; Sprache geändert werden. Die gewünschte Sprache muss unter Office-Anwendungssprache als bevorzugt markiert werden. Die Änderung wird erst wirksam, nachdem Excel beendet und neu gestartet wurde.\n\n\nDie Spracheinstellung haben keinen Einfluss auf die Funktion von Excel. Die Spracheinstellung bestimmt nur die Sprache der Benutzeroberfläche. Zur Benutzeroberfläche gehören die Menüs, die Dialoge, die Hilfetexte und die Funktionsnamen. Wird eine Arbeitsmappe in einer Excel mit einer anderen Spracheinstellung geöffnet, dann werden die Funktionsnamen automatisch übersetzt. Es ist jedoch unmöglich die Funktionsnamen in der ursprünglichen Sprache der Arbeitsmappe einzugeben."
  },
  {
    "objectID": "kapitel/einleitung/02_oberflaeche.html#arbeitsblätter",
    "href": "kapitel/einleitung/02_oberflaeche.html#arbeitsblätter",
    "title": "3  Bedienoberfläche",
    "section": "3.1 Arbeitsblätter",
    "text": "3.1 Arbeitsblätter\nDer Tabellenbereich ist das zentrale Element von Excels Arbeitsoberfläche. Dabei handelt es sich um den Datenbereich, der sich deutlich durch das beschriftete Gitterraster im Zentrum des Excel-Fensters abhebt und den Grossteil der Arbeitsoberfläche einnimmt. Über dieses Raster wird primär mit Daten und Funktionen interagiert. Der Tabellenbereich zeigt einen Ausschnitt des aktuellen Arbeitsblatts.\n\n\n\nAbbildung 3.1: Das Excel Arbeitsfenster\n\n\n\nDefinition 3.1 Ein Excel Arbeitsblatt ist ein Gitterraster, das aus Zellen besteht. Jede Zelle kann einen Wert enthalten.\n\n\nDefinition 3.2 Eine Zelle ist ein Feld im Raster eines Arbeitsblatt.\n\nExcel zeigt durch eine Hervorhebung an, welche Zelle aktuell markiert ist. Diese Markierung kann mit der Maus oder mit den Pfeiltasten bewegt werden. Wenn nur eine Zelle markiert ist, dann entspricht die Markierung der aktiven Zelle. Eine Markierung kann auch mehrere Zellen umfassen. In diesem Fall wird die aktive Zelle durch eine helle Hervorhebung gekennzeichnet, während der Rest der Markierung ausgegraut ist. Alle Eingaben mit der Tastatur bezeihen sich immer auf die aktive Zelle.\nOben und Links vom Tabellenbereich findet sich die Beschriftung für die Spalten und Zeilen. Spalten werden mit Buchstaben benannt, Zeilen werden mit Zahlen benannt. Daraus ergibt sich ein Koordinatensystem, mit dem jede Zelle eindeutig adressiert wird.\n\nDefinition 3.3 Die Koordinaten einer Zelle sind die Zellenadresse.\n\nIm Abschnitt 6.4 werden die verschiendenen Arten der Adressierung von Zellen und Zellbereichen detailliert beschrieben."
  },
  {
    "objectID": "kapitel/einleitung/02_oberflaeche.html#arbeitsblattreiter",
    "href": "kapitel/einleitung/02_oberflaeche.html#arbeitsblattreiter",
    "title": "3  Bedienoberfläche",
    "section": "3.2 Arbeitsblattreiter",
    "text": "3.2 Arbeitsblattreiter\nDirekt unter dem Tabellenbereich zeigt Excel Register mit den Namen der Arbeitsblätter. Diese Register zeigen alle Arbeitsblätter einer Excel-Arbeitsmappe. Wenn eine neue, leere Arbeitsmappe erstellt wird, dann enthält diese nur ein Arbeitsblatt mit dem Namen Tabelle 1. Mit dem Plus-Symbol neben dem Arbeitsblattregistern können zusätzliche Arbeitsblätter in der Arbeitsmappe erzeugt werden."
  },
  {
    "objectID": "kapitel/einleitung/02_oberflaeche.html#menübalken",
    "href": "kapitel/einleitung/02_oberflaeche.html#menübalken",
    "title": "3  Bedienoberfläche",
    "section": "3.3 Menübalken",
    "text": "3.3 Menübalken\n\n\n\nAbbildung 3.2: Menubalken\n\n\nAm oberen Fensterrand von Excel befindet sich der Menübalken, der im Excel Jargon “Ribbon” heisst. Der Menübalken ist in verschiedene Kategorien unterteilt und sortiert so die verschiedenen interaktiven Kommandos von Excel.\n\nDefinition 3.4 Ein Kommando ist eine interaktive Anweisung an Excel, eine bestimmte Aktion auszuführen.\n\nKommandos werden immer interaktiv ausgelöst und lassen sich meist nicht durch Excel-Funktionen ersetzen.\nFür die tägliche Arbeit sind die folgenden Kategorien des Menübalkens am wichtigsten:\n\nStart\nEinfügen\nFormeln\nDaten\nTabelle"
  },
  {
    "objectID": "kapitel/einleitung/02_oberflaeche.html#funktionsleiste",
    "href": "kapitel/einleitung/02_oberflaeche.html#funktionsleiste",
    "title": "3  Bedienoberfläche",
    "section": "3.4 Funktionsleiste",
    "text": "3.4 Funktionsleiste\nDie Funktionsleiste unterstützt die Arbeit mit der aktiven Zelle. Die Funktionsleiste wird verwendet, wenn mit speziellen Werten oder mit Komplexen Formeln gearbetiet wird.\n\n\n\nAbbildung 3.3: Die Excel Funktionsleiste\n\n\nDie Funktionsleiste hat 6 Bedienfelder.\nGanz links ist das Adressfeld. Das Adressfeld zeigt uns immer die Adresse der aktiven Zelle an. Wenn wir dieses Feld anklicken, dann können wir eine andere Adresse eintragen. In diesem Fall springt die Markierung für die aktive Zelle an die entsprechende Adresse.\nDaneben befinden sich zwei unscheinbare Dreiecke. Dieses Bedienfeld verbirgt eine Liste der benannten Bereiche in der aktuellen Arbeitsmappe. Bei einer leeren Arbeitsmappe ist diese Liste leer.\nDie nächsten vier Bedienfelder gehören zusammen.\nGanz rechts wird der Inhalt der aktuellen Zelle angezeigt. Bei einer leeren Tabelle ist dieser Bereich selbstverständlich leer. Wenn dieser Bereich mit der Maus ausgewählt wird, dann erscheint ein senkrechter, blinkender Strick, der signalisiert, dass Werte oder Formeln eingegeben werden können. Wenn nun etwas eingegeben wird, dann erscheint diese Eingabe auch in der aktiven Zelle.\nIst die Eingabe abgeschlossen, dann kann diese mit dem grünen Haken oder mit der Eingabetaste bestätigt werden.\nIst bei der Eingabe ein Fehler passiert, dann lässt sich die Eingabe mit einem Mausklick auf das rote X oder mit der ESC-Taste abbrechen. Die Eingabe wird dann auf den ursprünglichen Zustand zurückgesetzt.\nWird die aktive Zelle nicht bearbeitet, dann sind der Hacken und das X ausgegraut und können nicht verwendet werden.\nDirekt neben dem Eingabefeld mit dem Inhalt der aktiven Zelle ist das Bedienfeld für den Formelgenerator. Der Formelgenerator ist ein Hilfsdialog, der die Suche nach geeigneten Formeln unterstützt. Der Formelgenerator unterscheidet sich von Menübalken Formeln durch eine kurze Erklärung über die Arbeitsweise einer ausgewählten Funktion."
  },
  {
    "objectID": "kapitel/einleitung/02_oberflaeche.html#statusleiste",
    "href": "kapitel/einleitung/02_oberflaeche.html#statusleiste",
    "title": "3  Bedienoberfläche",
    "section": "3.5 Statusleiste",
    "text": "3.5 Statusleiste\nAm unteren Rand von Excels Anwendungsfenster findet sich die Statusleiste. Die Statusleiste hat drei zentrale Funktionen:\n\nZoom der Tabellenanzeige,\nStatus von Excel und Fehlermeldungen und\nSchnellauswertung eines Zellbereichs.\n\n\n3.5.1 Zoom der Tabellenanzeige\nDer aktuelle Zoom der Arbeitsmappe und die Zoom-Einstellung finden sich ganz rechts in der Statusleiste. Dabei wird der aktuelle Zoom als ein Prozentwert dargestellt. Über den “Schieberegler” links daneben lässt sich der Zoom anpassen.\nWenn der Zoom-Wert angeklickt wird, dann erscheint ein kleiner Dialog, über denden Zoom-Wert als Prozentzahl direkt eingegeben kann. Das ist praktisch, wenn für eine Präsentation oder zum Arbeiten ein bestimmter Zoom-Wert bevorzugt wird.\n\n\n\n\n\n\nAchtung\n\n\n\nDie Zoom-Einstellung muss für jeddes Arbeitsblatt separat eingestellt werden und wird beim nächsten Speichern der Arbeitsmappe mitgesichert.\n\n\n\n\n3.5.2 Status und Fehlermeldungen\nAuf der linken Seite der Statusleiste ist der Status Bereich. Normalerweise wird an dieser Stelle den Wert Bereit angezeigt. Wenn eine Zelle bearbeitet wird, dann erscheint der Status Eingeben oder Zeigen.\nWenn einen Fehler bei der Eingabe einer Formel auftritt, dann wird neben dem Status eine Fehlermeldung eingeblendet. Diese unscheinbare Fehlermeldung wird immer dann wichtig, wenn eine Formel oder ein Algorithmus nicht zu rechnen scheint. In solchen Fällen hilft ein Blick auf den linken Rand der Statusleiste bei der Fehlersuche. Bei Fehlern zeit die Statusleiste einen Hinweis auf den Fehler sowie die Adresse der Zelle, an der Excel den Fehler vermutet.\nTritt ein Fehler auf, dann bricht Excel die Berechnung der gesamten Arbeitsmappe sofort ab und ignoriert alle Formeln, die nach der fehlerhaften Zelle berechnet werden müssten, selbst wenn die Formeln unabhängig voneinander wären. Damit Excel wieder arbeitet, müssen zuerst alle Fehler behoben werden.\n\n\n3.5.3 Schnellauswertung eines Zellenbereichs\nIm mittleren Bereich der Statusleiste ist normalerweise leer. Hier versteckt sich eine sehr nützliche Funktion zur schnellen Zusammenfassung der Werte in einem Bereich: Werden mehrere Zellen markiert, dann zeigt Excel den Mittelwert, die Summe und die Anzahl der ausgewählten Zellen an.\n\n\n3.5.4 Anpassen der Statusleiste\nWenn Sie mit der rechten Maustaste (Win) bzw. mit Control-Klick (Mac) auf die Statusleiste klicken, dann erhalten Sie eine Auswahlliste der Funktionen, die in der Statusleiste angezeigt werden sollen.\nSo lassen sich zusätzliche Funktionen in der Statusleiste aktivieren oder störende Elemente deaktivieren.\n\n\n\n\n\n\nWarnung\n\n\n\nDiese Einstellungen beziehen sich ausschliesslich auf die Excel-Installation und werden nicht zusammen mit der Arbeitsmappe gespeichert!"
  },
  {
    "objectID": "kapitel/einleitung/01_jargon.html",
    "href": "kapitel/einleitung/01_jargon.html",
    "title": "4  Excel Jargon",
    "section": "",
    "text": "Arbeitsmappe: Bezeichnet eine Excel-Datei.\nArbeitsblatt: Als Arbeitsblatt wird in der Regel eine Tabelle in einer Excel-Arbeitsmappe bezeichnet.\nAdresse: Koordinaten einer Zelle oder eines Bereichs auf einem Arbeitsblatt.\nAktive Zelle: Die Zelle, die für das Bearbeiten ausgewählt ist. Ist nur eine Zelle markiert, dann entspricht die aktive Zelle der Markierung. Ist ein Bereich markiert, dann ist die aktive Zelle, die weiss hervorgehobene Zelle.\nBereich: Eine Auswahl von Zellen auf dem gleichen Arbeitsblatt.\ndynamischer Bereich oder dynamisches Feld oder dynamisches Array: Ein Bereich mit Werten, der durch eine Formel erzeugt wird.\nBezug: Adresse eines Bereichs, um den Wert bzw. die Werte an der Adresse zu erhalten.\nExterne Daten: Tabellen, die aus einer anderen Datei oder einer Datenbank eingebunden wurden.\nFormel: Aufruf von Funktionen in einer Zelle.\nFunktion: Bestandteil einer Formel. Funktionen werden über Parameter gesteuert.\nKommando: Ein Kommando ist eine Interaktion, mit der Excel eine Aktion auslöst. Aktionen ähneln Funktionen, können aber nicht als Formel ausgedrückt werden.\nParameter: Wert, der an eine Funktion übergeben wird. Ein Parameter kann direkt als Wert, indirekt als Adresse oder als Ergebnis einer anderen Funktion übergeben werden.\nPivot-Tabelle: Eine Kreuztabelle, mit der Daten aus mehreren Spalten eines Arbeitsblatts zusammengefasst werden können. Eine Pivot-Tabelle kann Daten von mehreren Arbeitsblättern und Tabellen zusammenfassen.\nRibbon: Menüleiste von Excel.\nTabelle: Eine Tabelle ist eine zwei-dimensionale Datenstruktur für strukturierte Daten. Eine Tabelle besteht aus Spalten und Zeilen.\nZelle: Ein Feld in einer Tabelle. Eine Zelle besteht immer aus einem Werteanteil und einem Formelanteil. Normalerweise wird der Werteanteil angezeigt."
  },
  {
    "objectID": "kapitel/daten-sammeln/kapitel.html#sec-datacollection-forms",
    "href": "kapitel/daten-sammeln/kapitel.html#sec-datacollection-forms",
    "title": "5  Daten sammeln",
    "section": "5.1 Daten mit Formularen sammeln",
    "text": "5.1 Daten mit Formularen sammeln\nDie direkte Eingabe von Daten ist nur für kleine Datensätze mit wenigen Merkmalen geeignet. Bei grösseren Datensätzen ist die direkte Eingabe oft zu aufwändig und fehleranfällig. Für die strukturierte Dateneingabe von grösseren Datensätzen werden Formulare verwendet.\nBei der Dateneingabe über Formulare werden die Daten mithilfe von Fragen mit vorgegebenen Antworttypen gesammelt. Der Antworttyp bestimmt, welche Werte für die Frage zulässig sind.\n\n\n\n\n\n\nHinweis\n\n\n\nIn vielen Formularsystemen wird der Antworttyp als Fragetyp bezeichnet, obwohl die Frage immer in Text-Bildform präsentiert wird und der Typ durch die unterschiedlichen Antwortmöglichkeiten bestimmt wird.\n\n\nDurch das Festlegen des Antworttyps wird gleichzeigt der Wertebereich des gemessenen Merkmals definiert. Dadurch ergibt sich beim Erstellen eines Formulars das Datenschema automatisch.\nExcel hat kein eingenes Formularsystem. Stattdessen kann Microsoft Forms verwendet werden. Microsoft Forms ist ein Online-Formulardienst, der in Microsoft365 integriert ist. Forms sammelt die Eingaben mit einem Formular und speichert die Daten in einer Excel Arbeitsmappe. Diese Formulare können über einen Web-Link geteilt werden und im Web-Browser ausgefüllt werden. Dadurch kann das Datensammeln auf verschiedene Personen verteilt werden.\n\n\n\n\n\n\nHinweis\n\n\n\nEin Formular kann in Microsoft Forms ein Quiz oder ein Formular sein. Ein Quiz ist ein Formular, bei dem die Antworten mit einer Punktzahl bewertet werden und ein Feedback erhalten können. Ein Formular fokussiert sich auf die reine Dateneingabe.\n\n\nMicrosoft Forms unterstützt die folgenden Antworttypen:\n\nOffene Antworttypen\n\nOffene Texteingabe\nDatumseingabe\nDatei hochladen\n\nGeschlossene Antworttypen\n\nEinfachauswahl\nMehrfachauswahl\nRangfolge\nLikert-Skala\nBewertung\nNet Promoter Score\n\n\n\n\n\nAbbildung 5.1: MS Forms Fragetypmenu\n\n\nJede dieser Varianten hat die folgenden gemeinsamen Optionen:\n\nEine einleitende Frage oder Anweisung.\nEin optionaler Untertitel oder eine Beschreibung. (Untertitel)\nDie Möglichkeit eine mathematische Formel zur Validierung des Wertebereichs anzugeben (Mathematik).\nDas erzwingen einer Antwort (Erforderlich).\nEine Verzweigung zu einer anderen Frage, wenn eine bestimmte Antwort gegeben wird (Verzweigung).\n\nDie Unterschiede ergeben sich in den Antwortmöglichkeiten.\n\n5.1.1 Offene Texteingabe (Text)\nDie offene Texteingabe erlaubt einzeilige und mehrzeilige (lange) offene Antworten möglich sind. Damit können un- oder semistrukturierte Daten erfasst werden. Diese Antwortmöglichkeit lässt sich auf Zahlenwerte und Zahlenintervalle eingeschränken.\n\n\n5.1.2 Datumseingabe (Datum)\nDiese Eingabe ist eine Variante der offenen Texteingabe zur Eingabe eines Datums. Diese Eingabe wird durch die Option ergänzt, das Datum über eine Kalenderdarstellung auszuwählen.\nDas eingegebene Datum wird als Zahl gespeichert und als Datum dargestellt.\n\n\n5.1.3 Datei hochlanden\nDie zweite Variante für offene Antworten ist das Hochladen von Dateien. Mit diesem Antworttyp lassen sich Bilder, Videos oder Tonaufnahmen leicht erfassen.\n\n\n5.1.4 Einfachauswahl (Auswahl)\nDie Einfachauswahl ist ein Single-Choice-Antworttyp. Es sind nur die vorgegebenen Antwortmöglichkeiten möglich, von denen nur eine ausgewählt werden kann. Die Antwortmöglichkeiten können als Text oder als Bild angegeben werden. Die Antwortmöglichkeiten werden immer in einer Liste angezeigt. Dabei kann zwischen einem Auswahlmenu als Dropdown-Liste und frei anwählbaren Antwortmöglichkeiten (Optionen) gewählt werden.\nDie Reihenfolge der Antwortmöglichkeiten kann durch die Option Optionen in zufälliger Reihenfolge für jedes Formular zufällig angeordnet werden. Diese Option ist sinnvoll, wenn die Reihenfolge der Antwortmöglichkeiten die Antwort beeinflussen könnte. Soll ein Formular mehrfach durch die gleichen Personen ausgefüllt werden, dann sollte diese Option nicht aktiviert werden.\nDas Ergebnis der Einfachauswahl ist eine Zeichenkette der ausgewählten Option.\n\n\n5.1.5 Mehrfachauswahl (Auswahl)\nDie Mehrfachauswahl erlaubt die Auswahl mehrerer Antwortmöglichkeiten, indem die Option Mehrere Antworten aktiviert wird. Dieser Antworttyp ist ansonsten identisch mit der Einfachauswahl.\nDas Ergebnis der Mehrfachauswahl ist eine Zeichenkette mit den ausgewählten Optionen. Wurden mehrere Antworten ausgewählt, dann werden die Optionen durch ein Semikolon getrennt.\n\n\n5.1.6 Rangfolge\nDie Rangfolge erlaubt es, dass die angebotenen Antwortmöglichkeiten in eine Reihenfolge gebracht werden können. Bei diesem Antworttyp müssen die Werte sortiert werden und die Sortierung wird als Antwort gespeichert.\nBei der Darstellung werden die Antwortmöglichkeiten in einer Liste angezeigt und für jedes Formular neu sortiert.\nDas Ergebnis der Rangfolge ist eine Zeichenkette mit der Reihung der Optionen. Die Optionen werden durch ein Semikolon getrennt. Im Ergebnis lässt sich die Rangfolge nicht von einer Mehrfachauswahl unterscheiden.\n\n\n5.1.7 Likert-Skala (Likert)\nDer Antworttyp Likert setzt eine Fragebatterie mit Likert-Skalen um. Darüber lässt sich ein semantisches Differential erheben.\nDie Anworten dieser Fragebatterie werden wie mehrere Einfachauswahlen als Zeichenketten gespeichert. Deshalb muss für diesen Antworttyp immer eine Kodierungstabelle für die richtige Reihenfolge der Werte dokumentiert werden.\n\n\n5.1.8 Bewertung\nDie Bewertung ist eine Variante des Antworttyps Likert-Skala. Mit der Bewertung wird über eine festgelegte Skala der gewünschte Wert abgefragt. Optional können für die beiden Extremwerte Beschriftungen angegeben werden.\nDas Ergebnis wird als Zahl gespeichert. Die Zahl entspricht dem Wert der ausgewählten Option beginnend bei 1.\n\n\n5.1.9 Net Promoter Score\nDer Typ Net Promoter Score ist eine spezielle elfstufige Liker-Skala, die zwischen zwei frei wählbaren Extremwerten festgelegt ist. Die offiziell als Net Promoter Score (Reichheld, 2003) bezeichnete Eingabeform ist eine verzerrte Likert-Skala mit dem Mittelpunkt bei 7.5.\nDer Net Promoter Score wird immer als Ganzzahl im Intervall 0 \\le s \\le 10 zurückgegeben.\n\n\n\n\n\n\nWarnung\n\n\n\nDer Net Promoter Score hat im Management-Umfeld eine grosse Verbreitung gefunden. Die Verwendung dieser Skala ist aber umstritten (Keiningham et al., 2007). Speziell die proklamierte Aussagekraft lässt sich nicht belegen (Fisher & Kordupleski, 2019; Grisaffe, 2007). Von der verbreiteten isolierten Verwendung des Net Promoter Score nach der Methode von Reichheld (2003) wird deshalb abgeraten.\nWird diese Eingabe als Likert-Skala verwendet, dann besteht ausser bei der Darstellung kein Unterschied zur Einfachauswahl oder der Bewertung.\n\n\n\n\n5.1.10 Darstellung der Ergebnisse in Excel\nDie Ergebnisse der Formulare werden in einer Excel-Arbeitsmappe als Tabelle gespeichert. Die Antworten sind in der Spalte ID sequenziell durchnummeriert. Zusätzlich enthält die Tabelle zwei sog. Zeitstempel mit Datum und Uhrzeit des Beginns (Startzeit) und des Endes (Fertigstellungszeit) der Datenerfassung eines Formulars. Optional können die Namen und E-Mail-Adressen der ausfüllenden Person miterfasst werden.\nNach diesen Basisinformationen folgen die einzelnen Antworten für die Formularelemente. Die Werte in der gleichen Zeile entsprechen dabei den Werten aus dem gleichen Formular. Die Spaltenüberschriften sind Standardmässig der Fragetext."
  },
  {
    "objectID": "kapitel/daten-sammeln/kapitel.html#daten-direkt-eingeben",
    "href": "kapitel/daten-sammeln/kapitel.html#daten-direkt-eingeben",
    "title": "5  Daten sammeln",
    "section": "5.2 Daten direkt eingeben",
    "text": "5.2 Daten direkt eingeben\nBei der direkten Eingabe von Daten muss zuerst die Ergebnistabelle manuell erstellt werden, um damit die Daten zu sammeln.\nDamit die Daten einheitlich erfasst werden, benötigt die Tabelle ein Schema. In Excel wird diese Schema über die Tabellenüberschriften definiert und kann bei einer späteren Verarbeitung weiter angepasst werden (s. Kapitel 7).\nEin einfaches Datenschema umfasst nur die Spaltenüberschriften, die erfasst werden sollen. Dazu müssen die Tabellenüberschriften definiert werden. Die Tabellenüberschriften werden in der ersten Zeile der Tabelle eingetragen. Überschriften für weitere Merkmale können zu einem späteren Zeitpunkt noch ergänzt werden. Anschliessend werden die Überschriften markiert und es wird für diesen Bereich eine Tabelle eingefügt. Hierbei muss die Option Tabelle hat Überschriften aktiviert werden (s. Abbildung 5.2).\n\n\n\nAbbildung 5.2: Tabelle erstellen\n\n\nDaten werden der Tabelle hinzugefügt, indem in der Zeile unterhalb der Tabelle neue Werte eingetragen werden. Die Tabellenstruktur mit dem Schema wird automatisch erweitert.\n\n5.2.1 Schemadefinition durch Datenüberprüfung\nDie einfache Schemadefinition stellt nicht sicher, dass die Werte einheitlich abgelegt werden. Das kann später die Datenerfassung und die Datenverarbeitung behindern. Wurde die Datentabelle mit einem Überprüfungsschema erstellt, dann können die Werte in die Tabelle eingetragen und bei der Eingabe validiert werden.\nDie Schemadefinition durch Datenüberprüfung erlaubt die Wertebereiche der gemessenen Merkmale vorab festzulegen. Dadurch lassen sich potentielle Fehler bereits bei der Dateneingabe vermeiden. Hierzu ist es notwendig, die Wertebereiche und die zugehörige Datenklasse einer Spalte zu bestimmen.\n\n\n\n\n\n\nPraxis\n\n\n\nDas Erstellen eines Schemas zur Dateneingabe ist in Excel zwar aufwändig, dennoch sollte dieser Schritt nicht übersprungen werden, weil die Datenüberprüfung die Datenqualität verbessert und die Datenverarbeitung erheblich vereinfacht.\n\n\nIn Excel müssen Vektoren durch die Option Datenüberprüfung definiert werden. Die Option Datenüberprüfung findet sich im Ribbon unter Daten (s. Abbildung 5.3) im Abschnitt Datentools (s. Abbildung 5.4).\n\n\n\nAbbildung 5.3: Ribbon Datenüberprüfung\n\n\n\n\n\nAbbildung 5.4: Datentools Details\n\n\nDie Schemadefinition erfolgt in drei zusätzlichen Schritten:\n\nEs wird eine Platzhalterzeile eingefügt, indem die Zelle unterhalb der ersten Überschrift ausgewählt wird. Die Platzhalterzeile wird benötigt, um die Datenüberprüfung zu definieren.\nFür jeden Vektor wird mit der Option Datenüberprüfung eine Datenüberprüfung für den gewünschten Wertebereich definiert.\nDie Platzhalterzeile wird gelöscht.\n\n\n\n5.2.2 Funktionsweise der Datenüberprüfung\nDie Datenüberprüfung ist eine Funktion, die auf einen Bereich angewendet wird, wobei der Bereich eine einzelne Zelle, einer Zeile oder eine Spalte sein kann. Für das Schema einer Tabelle wird die Datenüberprüfung für eine Spalte eingerichtet.\nDie Datenüberprüfung wird Zellenweise konfiguriert, wobei die erste Zelle eines Bereichs die Referenzzelle ist. Die Datenüberprüfung wird auf die Referenzzelle angewendet und diese Konfiguration wird auf alle Zellen des Bereichs übertragen und automatisch so angepasst, dass die aktuelle Zelle überprüft wird. Dabei sind ein paar Besonderheiten zu beachten.\n\nDie Datenüberprüfung muss mit konstanten Adressen konfiguriert werden. Es muss also die doppelte Dollar-Adressierung (z.B. $A$2) verwendet werden.\nWird nicht die Referenzzelle als Adresse verwendet, dann erfolgt die Datenüberprüfung mithilfe der Werte der angegebenen Adresse. In den folgenden Zellen wird dann der relative Versatz zur Referenzzelle verwendet.\nKonstante Werte müssen in der Datenüberprüfung explizit angegeben und nicht über Bezüge verwiesen werden.\n\nExcel bringt einige vordefinierte Überprüfungen mit, die über die Dropdown-Liste ausgewählt werden können. Die meisten Überprüfungen sind für Zahlenintervalle definiert. Die Standardeinstellung Jeden Wert ist gleichbedeutend mit keiner Überprüfung, weil alle Werte als Eingabe akzeptiert werden. Generelle Überprüfungen von Datentypen sind nicht vorgegeben und müssen über die Option Benutzerdefiniert definiert werden.\n\n\n\nAbbildung 5.5: Dialog Datenüberprüfung mit allen Überprüfungsoptionen\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nWird die Datenüberprüfung auf eine Zelle in einer Tabelle angewendet und in der jeweiligen Spalte existieren noch keine anderen Werte, dann wird die Datenüberprüfung für die gesamte Spalte übernommen. Stehen in der Tabelle bereits Werte, dann müssen zuerst alle Werte in der Spalte ausgewählt werden, bevor die Datenüberprüfung eingerichtet wird. Neue Werte übernehmen die Datenüberprüfung der vorangehenden Zeile.\n\n\n\n\n5.2.3 Datenüberprüfung für Zahlen, Zeichenketten oder Wahrheitswerte\nEine generelle Überprüfung für die fundamentalen Datentypen ist in Excel nicht vorgesehen. Solche Überprüfungen müssen über die Option Benutzerdefiniert festgelegt werden.\nIm Eingabefeld Formel kann eine beliebig komplexe Formel stehen. Die Formel muss einen Wahrheitswert zurückgeben. Wird der Wahrheitswert WAHR zurückgegeben, dann wird der Wert akzeptiert. Wird der Wahrheitswert FALSCH zurückgegeben, dann wird der Wert nicht akzeptiert.\nUm die fundamentalen Datentypen zu überprüfen, können die Informationsfunktionen ISTZAHL(), ISTTEXT() und ISTLOG() verwendet werden (s. Tabelle 5.1). Diese Funktionen geben WAHR zurück, wenn der Wert dem angegebenen Datentyp entspricht. Ansonsten geben sie FALSCH zurück.\n\n\nTabelle 5.1: Überprüfungsausdrücke für die fundamentalen Datentypen\n\n\nDatentyp\nÜberprüfungsausdruck\n\n\n\n\nZahlen\n=ISTZAHL($A$2)\n\n\nZeichenketten\n=ISTTEXT($A$2)\n\n\nWahrheitswerte\n=ISTLOG($A$2)\n\n\n\n\n\n\n5.2.4 Datenüberprüfung für ganze Zahlen\nDie Überprüfung ganzer Zahlen ist in Excel über die Option Ganze Zahl möglich. Diese Option überprüft, ob der Wert eine ganze Zahl ist. Diese Option kann aber nicht direkt für alle ganze Zahlen eingesetzt werden. Um alle zulässigen ganzen Zahlen zu erfassen muss unter der Option Daten der Punkt größer als ausgewählt werden. Anschliessend muss als Minimum der Wert -9.99999999999999E+307 eingetragen werden (s. Abbildung 5.6). Dieser Wert ist der kleinste Wert, der in Excel als (ganze) Zahl erfasst werden kann (Microsoft Support, 2023).\n\n\n\nAbbildung 5.6: Dialog Datenüberprüfung für alle ganzen Zaheln\n\n\n\n\n5.2.5 Datenüberprüfung für ordinalskalierte Wertebereiche\nFür ordinalskalierte Wertebereiche sollten die Werte am Besten als Ganzzahlen erfasst werden. Damit zu einem späteren Zeitpunkt diese Zahlen den eigentlichen Werten zugeordnet werden können, wird eine Zuordnungstabelle benötigt. Diese Zuordnungstabelle wird in einer separaten Tabelle erstellt. Diese Tabelle besteht aus zwei Spalten: Dem Zahlenwert und dem zugeordneten Wert. Die Ordnung der Werte ergibt sich aus der Ordnung der zugeordneten Zahlen.\n\n\n\n\n\n\nWichtig\n\n\n\nHäufig muss bei ordinalskalierten Wertebereichen die Option einer nicht zutreffenden Antwort berücksichtigt werden. In diesem Fall muss eine zusätzlicher Zahlenwert ausserhalb der regulären Ordnung definiert werden. Dieser Wert wird dann der nicht zutreffenden Antwort (z.B. NA oder nicht zutreffend) zugeordnet.\n\n\nDamit der Wertebereich korrekt eingeschränkt wird, muss die Option Liste verwendet werden. Die Quelle entspricht der Spalte mit den zugeordneten Zahlenwerten in der Zuordnungstabelle. Die Option Zellendropdown kann deaktiviert werden.\n\n\n\n\n\n\nAchtung\n\n\n\nDie Datenüberprüfung kann nicht mit Tabellenadressen umgehen. Deshalb müssen die gültigen Werte als absolute Arbeitsblattadressen angegeben werden (s. Abbildung 5.7).\n\n\n\n\n\nAbbildung 5.7: Datenüberprüfung mit Zuordnungstabelle für ordinalskalierte Wertebereiche\n\n\n\n\n5.2.6 Datenüberprüfung für nominalskalierte Wertebereiche\nDie Überprüfung nominalskalierter Wertebereiche wird in Excel durch die Option Liste realisiert. Die Option Liste erlaubt die Auswahl von Werten aus einer Liste in der gleichen Arbeitsmappe. Diese Liste ist einfach ein Bereich mit Werten, eine Spalte in einer anderen Tabelle oder eine benannte Liste (s. Kapitel 8). Die Liste muss in einer Spalte definiert werden, weil die Datenüberprüfung nur auf Spalten angewendet werden kann. Deshalb ist es nicht möglich, eine zeilenorientierte Liste für die Datenüberprüfung anzuwenden.\nFür nominalskalierte Wertebereiche werden alle zulässigen Werte in einer Spalte gestgelegt. Anschliessend wird im Dialog Datenüberprüfung unter Quelle der Bereich mit den zulässigen Werten angegeben.\n\n\n\n\n\n\nTipp\n\n\n\nIm Gegensatz zu ordinalskalierten Wertebereichen, sollten nominalskalierte Wertebereiche nicht als Zahlen kodiert werden, sondern als Zeichenketten erfasst werden.\n\n\nBei der Dateneingabe wird anschliessend ein Auswahlliste mit den zulässigen Werten, so dass die Werte nicht mehr direkt eingetippt werden müssen. Diese Auswahlliste kann unterbunden werden, wenn die Option Zellendropdown deaktiviert wird.\n\n\n\n\nFisher, N. I., & Kordupleski, R. E. (2019). Good and bad market research: A critical review of Net Promoter Score. Applied Stochastic Models in Business and Industry, 35(1), 138–151. https://doi.org/10.1002/asmb.2417\n\n\nGrisaffe, D. B. (2007). Questions about the ultimate question: conceptual considerations in evaluating Reichheld’s Net Promoter Score (NPS). 20.\n\n\nKeiningham, T. L., Cooil, B., Andreassen, T. W., & Aksoy, L. (2007). A Longitudinal Examination of Net Promoter and Firm Revenue Growth. Journal of Marketing, 71(3), 39–51. https://doi.org/10.1509/jmkg.71.3.039\n\n\nMicrosoft Support. (2023). Excel specifications and limits. https://support.microsoft.com/en-gb/office/excel-specifications-and-limits-1672b34d-7043-467e-8e27-269d656771c3\n\n\nReichheld, F. F. (2003). The One Number You Need to Grow. Harvard Business Review."
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html#fundamentale-datentypen",
    "href": "kapitel/datentypen/kapitel.html#fundamentale-datentypen",
    "title": "6  Datentypen",
    "section": "6.1 Fundamentale Datentypen",
    "text": "6.1 Fundamentale Datentypen\nExcel kennt sechs fundamentale Datentypen.\n\nZahlen\nZeichenketten\nWahrheitswerte\nFehlerwerte\nFormeln\nleere Zelle\n\n\n6.1.1 Zahlen\nZahlen werden in Excel immer als Gleitkommazahlen behandelt. Excel kennt von keine ganzen Zahlen. Wenn eine Zahl in eine ganze Zahl umgewandelt wird (z.B. durch die Funktion GANZZAHL), wird lediglich der Nachkommaanteil der Zahl auf 0 gesetzt.\nManche Excel Funktionen arbeiten nur mit ganzen Zahlen. In diesen Fällen wird der Nachkommaanteil der Zahl automatisch abgeschnitten.\nDurch die Verwendung von Gleitkommazahlen können in Excel Zahlen mit einer Genauigkeit von 15 signifikanten Stellen dargestellt werden. Werden zwei Zahlen addiert, und das Ergebnis mehr als 15 signifikante Stellen hätte, werden die alle Stellen ab der 15. signifikanten Stelle abgeschnitten. Excel versucht diese Fehler möglichst zu vermeiden.\nDer Datentyp Zahlen wird in Excel mit der Funktion ISTZAHL() geprüft. Die Funktion ISTZAHL() liefert WAHR, wenn der Wert ein Zahl ist, und sonst FALSCH.\n\n\n6.1.2 Zeichenketten\nZeichenketten heissen in Excel Text. Zeichenketten werden von Excel automatisch gewählt, wenn kein anderer Datentyp für eine Eingabe erkannt wurde. Um die automatische Erkennung zu verhindern, muss der Apostroph-Dekorator (s. Abschnitt 6.2.1) verwendet werden.\nIm Formelmodus müssen Zeichenketten in doppelte Anführungszeichen eingeschlossen werden. Im Wertemodus müssen Zeichenketten meist nicht besonders markiert werden.\nDer Datentyp Zeichenkette wird in Excel mit der Funktion ISTTEXT() geprüft. Die Funktion ISTTEXT() liefert WAHR, wenn der Wert eine Zeichenkette ist, und sonst FALSCH.\nBesondere Zeichenketten sind Adressen bzw. im Excel Jargon Bezüge. Die Funktion ISTBEZUG() prüft, ob eine Zeichenkette eine gültige Excel Adresse ist. Die Funktion ISTBEZUG() liefert WAHR, wenn die Zeichenkette eine Adresse ist, und sonst FALSCH.\n\n\n6.1.3 Wahrheitswerte\nWahrheitswerte heissen in Excel WAHR und FALSCH. Wahrheitswerte heissen im Excel Jargon logische Werte. Während der Werteeingabe werden Wahrheitswerte unabhängig von der Gross- und Kleinschreibung automatisch erkannt.\nIm Formelmodus dürfen Wahrheitswerte nicht in Anführungszeichen eingeschlossen werden, weil sonst die Symbole als Zeichenkette behandelt werden.\nDer Datentyp Wahrheitswerte wird in Excel mit der Funktion ISTLOG() geprüft. Die Funktion ISTZLOG() liefert WAHR, wenn der Wert ein Wahrheitswert ist, und sonst FALSCH.\n\n\n6.1.4 Fehlerwerte\nFehlerwerte ist in Excel ein besonderer Datentyp, um Fehler zu signalisieren. Fehler beginnen immer mit einem Gatter (#), das von einem sog. Fehlerbezeichner gefolgt wird. In der Regel werden Fehlerwerte automatisch erzeugt, es ist aber möglich, Fehlerwerte auch manuell einzugeben. Bei der manuellen Eingabe von Fehlerwerten werden nur die gültigen Fehlerbezeichner akzeptiert. Andere Symbolfolgen werden als Zeichenketten interpretiert.\nExcels gültige Fehlerwerte sind #NV, #NULL!, #WERT!, #BEZUG!, #DIV/0!, #ZAHL!, #NAME?, #KALK!, #ÜBERLAUF!, #DATEN_ABRUFEN! und #ZAHL!.\nDer Wert #NV wird in Excel verwendet, um einen ungültigen Wert zu verweisen. Dieser Wert ist nicht gleichbedeutend mit fehlenden Werten.\nDer Datentyp Fehlerwert wird in Excel mit der Funktion ISTFEHLER() geprüft. Die Funktion ISTFEHLER() liefert WAHR, wenn der Wert ein Fehlerwert ist, und sonst FALSCH. Um einen bestimmten Fehlerwert zu prüfen, kann die Funktion FEHLER.TYP() mit dem entsprechenden Fehlerbezeichner als Argument verwendet werden. Diese Funktion gibt einen eindeutigen Zahlenwert für den Fehler zurück. Ist der Wert kein Fehlerwert, dann wird der Fehler #NV zurückgegeben.\n\n\n6.1.5 Formeln\nFormeln sind ein eigener Datentyp, die mit dem Gleich-Dekorator (=) beginnen. Eine Formel besteht immer aus einem Wert, einem Funktionsaufruf oder einer Kombination von Werten und Funktionsaufrufen, die durch Operatoren verknüpft wurden.\nDer Datentyp Formel wird in Excel mit der Funktion ISTFORMEL() geprüft. Die Funktion ISTFORMEL() liefert WAHR, wenn der Wert eine Formel ist, und sonst FALSCH.\nFormeln sind in Excel ein besonderer Datentyp, denn eine Zelle mit einer Formel hat immer zwei Datentypen. Der erste Datentyp ist der Datentyp Formel, der zweite Datentyp ist der Datentyp des Formelergebnisses.\n\n\n6.1.6 Leere Zellen\nLehre Zellen sind Zellen, die keinen Wert enthalten. Leere Zellen zeigen fehlende Werte in Excel an.\nDie Leere Zelle ist für Excel ein eingener Datentyp und wird mit der Funktion ISTLEER() geprüft. Die Funktion ISTLEER() liefert WAHR, wenn der Wert eine leere Zelle ist, und sonst FALSCH.\n\n\n\n\n\n\nWarnung\n\n\n\nEine leere Zelle und eine leere Zeichenkette lassen sich mit dem Auge nicht unterscheiden. Die Funktion ISTLEER() liefert für eine leere Zeichenkette FALSCH zurück, weil die Zelle einen Wert enthält.\n\n\nLeere Zellen als Ergebnis einer Formel werden von Excel in die Zahl 0 umgewandelt. Im Kapitel Abschnitt 8.2 wird gezeigt, wie sich leere Zellen von Zellen mit dem Wert 0 unterscheiden lassen. Im Abschnitt 8.4.1 wird auf leere Zellen als Funktionsergebnisse ausführlich eingegangen."
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html#dekoratoren",
    "href": "kapitel/datentypen/kapitel.html#dekoratoren",
    "title": "6  Datentypen",
    "section": "6.2 Dekoratoren",
    "text": "6.2 Dekoratoren\n\nDefinition 6.1 Ein Dekorator ist Sprachelement einer Programmiersprache, mit dem die normale Interpretation von Symbolen verändert werden kann.\n\nExcel hat zwei Dekoratoren, als erstes Symbol einer Zelle stehen müssen. D.h. es dürfen auch keine Leerzeichen vor einem Dekorator stehen. Die beiden Dekoratoren sind:\n\nDer Apostroph-Dekorator (')\nDer Gleich-Dekorator (=)\n\n\n6.2.1 Apostroph-Dekoraktor\nDer Apostroph-Dekorator (') erzwingt, dass die nachfolgenden Symbole als Zeichenkette interpretiert werden müssen.\nMithilfe des Apostroph-Dekorators wird die automatische Typerkennung für die laufende Eingabe deaktiviert. Auf diese Weise lassen sich Zeichenketten eingeben, die nur aus Ziffern bestehen oder Zeichenketten, die Datentumswerten ähneln.\nDer Apostroph-Dekorator muss zwingend verwendet werden, wenn auf eine Zeichenkette eine der folgenden Bedingungen zutrifft.\n\nDie Zeichenkette beginnt mit einem Gleichheitszeichen (=), einem Pluszeichen (+), einem Minuszeichen (-) oder einem Prozentzeichen (%).\nDie Zeichenkette besteht nur aus Ziffern, dem Dezimaltrenner (.) oder dem Tausendertrenner (‘) enthält\nDie Zeichenkette ähnelt der wissenschaftliche Notation für Zahlen mit und ohne Vorzeichen für den Exponenten. Z.B. 5.E3.\nDie Zeichenkette ähnelt einm Datum.\nDie Zeichenkette entspricht einen Fehlerwert, unabhängig von der Schreibweise. Z.B. #nv.\nDie Zeichenkette entspricht einem Wahrheitswert (WAHR oder FALSCH) unabhängig von der Schreibweise.\n\nDas Apostroph kann entfallen, wenn die aktive Zelle vorher bereits als Datentyp Text formatiert wurde. In diesem Fall verlieren alle Symbole ihre spezielle Bedeutung. In solche Zellen können keine Formeln eingegeben werden.\n\n\n6.2.2 Gleich-Dekorator\nDer Gleich-Dekorator (=) zeigt an, dass die nachfolgenden Symbole als Formel interpretiert werden müssen.\nBei der Eingabe des Gleich-Dekorators wechselt Excel für die laufende Eingabe in den Formelmodus. Mit beenden der Eingabe mit der Eingabetaste wird der Formelmodus wieder verlassen und das Ergebnis der eingegebenen Formel wird in der Zelle angezeigt."
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html#komplexe-datenstrukturen",
    "href": "kapitel/datentypen/kapitel.html#komplexe-datenstrukturen",
    "title": "6  Datentypen",
    "section": "6.3 Komplexe Datenstrukturen",
    "text": "6.3 Komplexe Datenstrukturen\nExcel kennt zwei komplexe Datenstrukturen:\n\nBereiche\nTabellen\n\nExcels komplexe Datenstrukturen müssen einen fundamentalen Datentyp haben und können keine komplexen Datenstrukturen schachteln.\n\n6.3.1 Bereiche: Vektoren und Matrizen\nExcels Grundstruktur ist das Rechteck, dass durch die markierten Zellen entsteht. Dieses Rechteck heisst im Excel Jargon ein Bereich.\nObwohl Excel vektorähnliche Bereiche kennt, ist es sinnvolle sich Excels Bereiche immer als Matrizen vorzustellen.\n\nEin Bereich mit nur einer Zelle ist eine 1x1- oder 0-dimensionale Matrix.\nEin Bereich mit nur einer Zeile oder einer Spalte ist für Excel eine 1xn- oder 1-dimensionale Matrix. Diese speziellen Matrizen werden in der Regel als Vektoren bezeichnet.\nEin Bereich mit mehreren Zeilen und Spalten ist eine nxm- oder 2-dimensionale Matrix.\n\nFunktionen können Bereiche als Ergebnis haben. In diesem Fall werden die restlichen Werte zeilen und spaltenweise unterhalb bzw. rechts von der entsprechenden Formel ausgegeben.\n\n\n6.3.2 Tabellen\nTabellen sind benannte Bereiche, die Vektoren enthalten. Tabellen bestehen aus Spalten, in denen die Werte als Vektoren stehen. Excel Tabellen haben immer Überschriften.\nExcel kennt zwei Arten von Tabellen:\n\nWertetabellen\nPivot-Tabellen.\n\n\nDefinition 6.2 Wertetabellen sind Listen, die Listen mit gleicher Länge schachteln.\n\nWertetabellen entsprechen ungefähr einem Datenrahmen (engl. data-frame) in anderen Programmiersprachen. Der Unterschied zu einem Datenrahmen ist, dass Excels Wertetabellen keine Vektoren erzwingen. Deshalb können in der gleichen Spalte einer Wertetabelle verschiedene Datentypen gemischt werden.\n\nDefinition 6.3 Pivot-Tabellen sind ein Werkzeug zum interaktiven Zusammenfassen von Daten.\n\nPivot-Tabellen erleichtern einfache Datenanalysen. Pivot-Tabellen entsprechen einer tabellarischen Darstellung der Daten. Ihre Funktion ist auf wenige analytische Funktionen beschränkt und die dargestellten Werte lassen sich nur umständlich weiterverarbeiten.\nPivot-Tabellen sind Arbeitsmappenelemente aber keine Datenstrukturen. Deshalb werden Pivot-Tabellen in diesem Buch ähnlich einer Visualisierung als Darstellungsform behandelt."
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html#sec-adressierung-ds",
    "href": "kapitel/datentypen/kapitel.html#sec-adressierung-ds",
    "title": "6  Datentypen",
    "section": "6.4 Adressierung von Datenstrukturen",
    "text": "6.4 Adressierung von Datenstrukturen\n\nDefinition 6.4 Ein Bezug ist die Adresse eines Bereichs.\n\nIn Excel gibt es zwei Arten von Bezügen:\n\nArbeitsblattadressen\nTabellenadressen\n\n\n6.4.1 Arbeitsblattadressen\n\nDefinition 6.5 Eine Arbeitsblattadresse enthält die Koordinaten eines Bereichs auf einem Arbeitsblatt.\n\nArbeitsblattadressen besteht aus drei Teilen:\n\nArbeitsblattname\nBereichsbeginn\nBereichsende\n\nDer Bereichsbeginn verweist immer auf die linke obere Zelle des Bereichs. Der Bereichsende verweist immer auf die rechte untere Zelle des Bereichs. Eine Zelle wird immer durch den Spaltenindex (Buchstabe) und den Zeilenindex (Zahl) identifiziert. Werden die Koordinaten des Bereichsbeginns und des Bereichsendes bei der Eingabe vertauscht, dann wird der Bereich automatisch korrigiert.\n\nBeispiel 6.1 (Arbeitsblattadresse)  \nTabelle1!A1:C3\n\nBeispiel 6.1 verweist auf den Bereich mit drei Spalten und drei Zeilen auf dem Arbeitsblatt Tabelle1 beginnend mit der Zelle A1 und endend mit der Zelle C3.\nOft werden Arbeitsblattadressen nicht vollständig sondern gekürzt angegeben. Es gibt zwei Möglichkeiten, um Arbeitsblattadressen zu kürzen:\n\nWerden Bereiche auf dem gleichen Arbeitsblatt adressiert, dann kann der Arbeitsblattname weggelassen werden.\nWird ein Bereich mit nur einer Zelle adressiert, dann wird das Bereichsende weggelassen.\n\nWeil Arbeitsblattadressen von vielen interaktiven Excelkommandos verwendet werden, gibt es zwei Arten von Arbeitsblattadressen:\n\nRelative Adressen\nAbsolute Adressen\n\nDie Art der Adresse legt fest, wie ein interaktives Kommando mit einer Adresse umgehen soll. Die populärste interaktive Funktion ist das Autoauffüllen. Dabei wird eine Zelle mit einer Formel interaktiv auf einen Bereich von Zellen übertragen.\n\n\n\n\n\n\nWarnung\n\n\n\nDas Autoauffüllen ist eine einfache und beliebte Methode, um Formeln in Excel auf verschiedene Werte wiederholt anzuwenden. Bis 2019 war das Autoauffüllen die einzige Möglichkeit für die Datentransformation.\nDie relative und absolute Adressierung ist eine wichtige Voraussetzung für das Autoauffüllen. Leider ist das Autoauffüllen auch die Ursache für viele Fehler beim Umgang mit Excel.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nIn Excel365 kann das Autoauffüllen durch vektorisierte Funktionen fast vollständig ersetzt werden. Dadurch lassen sich viele Excel-typische Fehler vermeiden. Dadurch ist die Unterscheidung zwischen der relativen und absoluten Adressierung nicht mehr so wichtig.\n\n\n\n6.4.1.1 Relative Adressen\n\nDefinition 6.6 Eine relative Adresse ist eine Adresse eines Bereichs, die veränderlich ist.\n\nRelative Adressen werden in Excel von interaktiven Funktionen, wie dem Autoauffüllen verwendet, um die Adressen automatisch anzupassen. Eine relative Adresse wird relativ zur aktuellen Zelle angepasst.\nEin Beispiel für eine relative Adresse ist A1. Diese Adresse bezeichnet die Zelle, die sich in der ersten Zeile und der ersten Spalte auf dem aktuellen Arbeitsblatt befindet. Wird die adressierte Zelle interaktiv nach unten aufgefüllt, dann wird die Adresse automatisch zu A2, A3, usw. angepasst. Wird die adressierte Zelle nach rechts aufgefüllt, dann wird die Adresse automatisch zu B1, C1, usw. angepasst.\n\n\n6.4.1.2 Absolute Adressen\n\nDefinition 6.7 Eine absolute Adresse ist eine Adresse eines Bereichs, die ganz oder teilweise unveränderlich ist.\n\nDer unveränderliche Teil einer Arbeitsblattadresse wird mit einem Dollarzeichen ($) markiert. Dieser Teil der Adresse wird bei der Anpassung der Adresse nicht verändert. So lassen sich Adressen angeben, die durch interaktive Kommandos nicht verändert werden.\nEin Beispiel für eine absolute Adresse ist $A$1. Diese Adresse bezeichnet die Zelle, die sich in der ersten Zeile und der ersten Spalte auf dem aktuellen Arbeitsblatt befindet. Wird die adressierte Zelle interaktiv horizontal oder vertikal aufgefüllt, dann wird die Adresse nicht angepasst.\nAuf diese Weise lassen sich konstante Werte in Formeln einbauen.\n\n\n\n6.4.2 Tabellenadressen\nSpalten und einzelne Werte können über die Tabellenadressierung abgefragt werden (Microsoft Support, 2023). Das Ergebnis einer solchen Adressierung ist immer ein dynamisches Feld bzw. ein dynamischer Bereich (s. Abschnitt 8.1.1).\n\n\n\n\n\n\nHinweis\n\n\n\nJede Tabellenadresse kann auch als Arbeitsblattadresse dargestellt werden. Umgekehrt ist dies nicht möglich.\n\n\nEine Tabellenadresse besteht aus zwei Teilen:\n\nDem Tabellennamen\nDem Spaltennamen\n\n\nBeispiel 6.2 (Tabellenadresse)  \nTabelle1[Spalte1]\n\nDas Beispiel 6.2 verweist auf die Spalte Spalte1 der Tabelle Tabelle1.\n\n\n\n\n\n\nWichtig\n\n\n\nDie Namen von Tabellen sind unabhängig den Arbeitsblattnamen. In der gleichen Arbeitsmappe darf jeweils nur eine Tabelle und nur ein Arbeitsblatt mit dem gleichen Namen existieren. Es ist aber möglich, dass eine Tabelle und ein Arbeitsblatt den gleichen Namen haben. Das kann zu Verwirrungen führen, denn die Adresse Tabelle1[Spalte1] und die Adresse Tabelle1!A:A verweisen nicht zwingend auf die gleiche Spalte, denn eine Tabelle muss nicht auf einem Arbeitsblatt mit dem gleichen Namen stehen!\n\n\nTabellenadressen können auch gekürzt werden:\n\nWerden Spalten in der gleichen Tabelle angesprochen, dann kann der Tabellenname weggelassen werden.\nSoll die gesamte Tabelle angesprochen werden, dann kann der Spaltenname weggelassen werden.\n\n\n6.4.2.1 Tabellenbereiche\nUm mehrere Spalten einer Tabelle anzusprechen kann der Bereichsoperator (:) wie bei der Arbeitsblattadressierung verwendet werden. Zusätzlich müssen die Spalten in ein weiteres Paar eckiger Klammern eingeschlossen werden.\n\nBeispiel 6.3 (Tabellenbereich)  \nTabelle1[[Spalte1]:[Spalte3]]\n\nBeispiel 6.3 verweist auf alle Spalten zwischen Spalte1 und Spalte3 der Tabelle Tabelle1.\n\n\n\n\n\n\nWarnung\n\n\n\nWerden zu einem späteren Zeitpunkt neue Spalten zwischen den adressierten Spalten hinzugefügt, dann werden die neuen Spalten automatisch in die Adressierung einbezogen.\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nEs ist nicht möglich mehrere Spalten einer Tabellen gleichzeitig gezielt zu adressieren, wenn diese nicht unmittelbar nebeneinander stehen. Diese Adressierung ist unmöglich, weil Excel nur rechteckige Bereiche adressieren kann und solche Spalten keinen rechteckigen Bereich bilden.\nDie Adressierung aus Beispiel 6.3 kann nicht angepasst werden, so dass nur Spalte1 und Spalte3 adressiert werden, ausser die Spalten Spalte1 und Spalte3 stehen direkt nebeneinander.\n\n\n\n\n6.4.2.2 Diese Zeile-Operator\nEinzelne Zeilen einer Tabelle können mit dem Diese Zeile-Operator adressiert werden. Der Diese Zeile-Operator wird mit dem Wert [#Diese Zeile] oder mit @ angegeben. Dieser Operator reduziert die Tabelle auf eine einzelne Zeile und wählt anschliessend die gewünschte Spalte aus. Diese Zeile bedeutet für Excel die aktuelle Zeile des Arbeitsblatts.\n\n\nBeispiel 6.4 (Diese Zeile-Operator für eine Tabellenzelle)  \n= Tabelle[@Spalte]\noder\n= @Tabelle[Spalte]\n\n\nDer Operator ist speziell für die Verwendung in Formeln in Tabellenzellen gedacht. Obwohl der Operator in allen Formeln eingesetzt werden kann, sollte der Einsatz auf Formeln beschränkt werden, die sich in einer Tabelle befinden.\n\n\n\n\n\n\nWarnung\n\n\n\nDer Diese Zeile-Operator kann nicht auf Tabellen angewendet werden, um eine ganze Zeile zu adressieren. Es darf immer nur eine einzelne Zelle adressiert werden. Die Adressierung @Tabelle ist also ungültig.\n\n\n\n\n\n\n\n\nWarnung\n\n\n\nDer Diese Zeile-Operator ist immer relativ zum Arbeitsblatt und nicht relativ zur aktuellen Tabelle. Es muss nur der Zeilenindex gleich sein, die Zielzelle kann sich auf einem anderen Arbeitsblatt befinden.\n\n\nWird der Diese Zeile-Operator in Tabellen unterschiedlicher Länge verwendet, dann können zwei Fälle eintreten:\n\nIst die adressierte Tabelle kürzer als die adressierende Tablle, dann wird für die Zeilen, die keine Entsprechung in der adressierten Tabelle haben, der Fehler #WERT! zurückgegeben.\nIst die adressierte Tabelle länger als die adressierende Tablle, dann werden alle überzähligen Zeilen ignoriert.\n\n\n\n\n\n\n\nPraxis\n\n\n\nDer Diese Zeile-Operator kann nur auf eine einzelne Zelle in der gleichen Zeile auf einem Arbeitsblatts angewendet werden. Wegen dieser Einschränkung des Diese Zeile-Operators sollten alle Tabellen so gestaltet werden, dass sie in der ersten Zeile des Arbeitsblatts beginnen. Dadurch kann der Diese Zeile-Operator in allen Tabellen verwendet werden.\n\n\n\n\n6.4.2.3 Überschriften adressieren\nEine Excel Tabelle hat immer Spaltenüberschriften. Diese Überschriften können ebenfalls über die Tabellenadressierung adressiert werden. Dazu wird als Spaltenname der Wert #Kopfzeilen verwendet.\n\nBeispiel 6.5 (Kopfzeilen einer Tabelle adressieren)  \nTabelle1[#Kopfzeilen]\n\nUm gezielt Kofzeilen zu adressieren, kann die Adressierung aus Beispiel 6.5 mit der Adressierung aus Beispiel 6.3 kombiniert werden (Beispiel 6.6).\n\nBeispiel 6.6 (Kopfzeilen einer Tabelle adressieren)  \nTabelle1[[#Kopfzeilen];[Spalte1]:[Spalte3]]\n\n\n\n6.4.2.4 Absolute Adressierung in Tabellen\nEin Tabellenbereich ist immer absolut adressiert. Wird aber nur eine einzelne Spalte einer Tabelle adressiert, dann wird die Adresse relativ addressiert. Damit beim Autoauffüllen diese Adresse nicht verändert wird, muss die Adresse als Bereich angegeben werden.\n\nBeispiel 6.7 (Absolute Tabellenadressierung von einer Spalte)  \nTabelle1[[Spalte1]:[Spalte1]]\n\nWird eine Formel mit dieser Adresse interaktiv aufgefüllt, dann wird die Adresse nicht verändert.\n\n\n\n\nMicrosoft Support. (2023). Using structured references with Excel tables. https://support.microsoft.com/en-gb/office/using-structured-references-with-excel-tables-f5ed2452-2337-4f71-bed3-c8ae6d2b276e"
  },
  {
    "objectID": "kapitel/daten-importieren/kapitel.html#datenverbindungen-herstellen",
    "href": "kapitel/daten-importieren/kapitel.html#datenverbindungen-herstellen",
    "title": "7  Daten importieren",
    "section": "7.1 Datenverbindungen herstellen",
    "text": "7.1 Datenverbindungen herstellen\nEine Datenverbindung wird über das Kommando Daten abrufen (Power Query) ausgelöst. Das Kommando ist in der Gruppe Daten im Abschnitt Daten abrufen und transformieren zu finden. Das Kommando bereitet den Import durch Power Query vor, indem zuerst das Dateiformat und anschliessend die zugehörige Datenquellen ausgewählt wird. Nach diesen Schritten kann Excel die Daten Laden oder die Daten transformieren (s. Abbildung 7.3).\n\n\n\n\n\n\nPraxis\n\n\n\nDie Daten sollten nur in Ausnahmefällen unkontrolliert geladen werden. Die Daten sollten vor dem Importieren in Power Query überprüft und transformiert werden. Dadurch wird sichergestellt, dass die Daten korrekt importiert werden.\n\n\n\n\n\nAbbildung 7.3: Laden oder Transformieren-Auswahl beim Import einer Excel Arbeitsmappe\n\n\nWird die Option Daten transformieren ausgewählt, öffnet sich der Power Query Editor. In diesem Editor können die Daten überprüft und transformiert werden. Das Transformieren der Daten umfasst vier Arten der Transformation:\n\nDatentypanpassungen\nSpaltenauswahl\nDatentrennung\nDaten kombinieren\n\nFür jede Transformation wird ein Schritt in Power Query angelegt. Die Schritte werden in der Reihenfolge der Ausführung angezeigt. Die Reihenfolge der Schritte kann verändert werden, indem die Schritte mit der Maus verschoben werden. In der Mitte des Power Query Fensters wird eine Datenvorschau angezeigt, die die Auswirkungen der Transformationen zeigt.\nStandardmässig werden drei bzw. bei Excel Arbeitsmappen vier Schritte in Power Query automatisch konfiguriert:\n\nQuelle\n\nBei Excel Arbeitsmappen folgt dem Schritt Quelle der Schritt Navigation zur Auswahl des Arbeitsblattes.\n\nHöherstufen\nGeänderter Typ (Windows) bzw. geänderter Spaltentyp (MacOS)\n\nDer Schritt Geänderter Typ enthält die Schemadefinition. Power Query versucht das Schema automatisch zu erkennen. Das funktioniert besonders bei Zahlenwerten nicht immer zuverlässig. Deshalb muss das Schema immer kontrolliert und gegebenenfalls angepasst werden.\n\n\n\nAbbildung 7.4: Schemaanpassung mit Power Query\n\n\nNachdem das Schema kontrolliert wurde, können die Daten nach Excel importiert werden. Dazu wird das Kommando Schließen & laden in Power Query Menukategorie Start ausgeführt.\nNach einem Datenimport liegen die Daten in der Arbeitsmappe als Tabelle vor. Diese Daten sind eine Kopie der Daten in der Datenquelle. Dadurch kann die Arbeitsmappe unabhängig von der Datenquelle verwendet und geteilt werden.\n\n\n\n\n\n\nAchtung\n\n\n\nExcel betrachtet jeden Datenimport als Sicherheitsproblem. Daher werden Datenverbindungen beim Öffnen einer Arbeitsmappe standardmässig deaktiviert. Beim Öffnen einer Arbeitsmappe mit einer Datenverbindung wird eine Warnung angezeigt. Um mit den importierten Daten arbeiten zu können, muss die Datenverbindung aktiviert werden.\nWird die Datenverbindung nicht aktiviert, werden Funktionen die auf die Daten zugreifen nicht ausgeführt, sondern nur die Ergebnisse der letzten Ausführung angezeigt."
  },
  {
    "objectID": "kapitel/daten-importieren/kapitel.html#datenschema-anpassen",
    "href": "kapitel/daten-importieren/kapitel.html#datenschema-anpassen",
    "title": "7  Daten importieren",
    "section": "7.2 Datenschema anpassen",
    "text": "7.2 Datenschema anpassen\nDie einfachste Möglichkeit zur Anpassung des Datenschemas ist die Verwendung der Menukategorie Transformation. Dieses Menu zeigt alle verfügbaren Transformationen an. Die Transformationen sind in sechs Kategorien gegliedert:\n\n\n\nAbbildung 7.5: Power Query Menu Transformation\n\n\n\nTabelle\nBeliebige Spalte\nTextspalte\nZahlenspalte\nDatums- & Uhrzeitspalte\nStrukturierte Spalte\n\nFür das Datenschema sind die folgenden Transformationen wichtig:\n\nDatentyp\nUmbenennen\nVerschieben\nSpalte teilen\n\n\n\n\n\n\n\nHinweis\n\n\n\nDie meisten Transformationen gehören konzeptionell zu späteren Kapiteln.\n\nGruppieren nach und Werte ersetzen werden im Kapitel 13 behandelt.\nVertauschen wird im Kapitel 12 behandelt.\nZellen zählen, Ausfüllen und alle Transformationen in den Kategorien Zahlenspalten, Datums- & Uhrzeitspalten und Strukturierte Spalten werden im Kapitel 11 behandelt.\nSpalte pivotisieren und Spalte entpivotisieren werden im Kapitel 14 behandelt.\nFormat, Analysieren und Extrahieren (Kategorie Textspalte) werden im Kapitel 9 behandelt.\n\nIn diesen Kapiteln werden die Transformationen von Power Query separat hervorgehoben.\n\n\n\n7.2.1 Datentyp anpassen\nDie wichtigste Transformation ist die Anpassung des Datentyps. Der Datentyp bestimmt, wie die Daten interpretiert werden. Die Interpretation der Daten bestimmt, welche Operationen auf die Daten angewendet werden können.\n\n\n\n\n\n\nWichtig\n\n\n\nDie Datentypen müssen im Schritt Geänderter Typ (Windows) bzw. geänderter Spaltentyp (MacOS) angepasst werden.\n\n\nPower Query zeigt neben den Spaltenüberschriften mit einem Symbol den Datentyp der Spalte an. Tabelle 7.1 zeigt die Symbole für die verschiedenen Datentypen. Zusätzlich wird der Datentyp im Menubalken neben dem Kommando Datentyp angezeigt. Die Datentypen sind in vier Kategorien unterteilt:\n\nZahlen\nDatum und Uhrzeit\nZeichenketten\nWahrheitswerte\n\nIm Gegensatz zu Excel behandelt Power Query Datum und Uhrzeit als eigenen Datentyp. Power Query muss diese Unterscheidung machen, weil in den Datenquellen diese Werte als Zeichenketten kodiert vorliegen. Dabei handelt es sich um strukturierte Daten. Power Query hat für diese Daten spezielle Parser, die die Zeichenketten aus der Datenquelle in Zahlenwerte für Excel umwandeln.\n\n\nTabelle 7.1: Power Query Datentypen mit Symbolen\n\n\n\n\n\n\n\n\nDatentyp\nSymbol\nKategorie\nBemerkungen\n\n\n\n\nText\n\nZeichenketten\n\n\n\nTRUE/FALSE\n\nWahrheitswerte\n\n\n\nDezimalzahl\n\nZahlen\n\n\n\nGanze Zahl\n\nZahlen\n\n\n\nProzentzahl\n\nZahlen\nDezimalzahl mal 100\n\n\nWährung\n\nZahlen\nDezimalzahl mit Währungsformatierung\n\n\nBinärzahl\n\nZahlen\nGanzzahl\n\n\nZahl mit Gebietsschema\n\nZahlen\nNur MacOS; Das Gebietsschema legt den Tausender- und Dezimaltrenner fest\n\n\nDatum/Uhrzeit\n\nDatum und Uhrzeit\nZeitstempel als formatierte Dezimalzahl\n\n\nDatum\n\nDatum und Uhrzeit\nGanzzahl mit Datumsformatierung\n\n\nUhrzeit\n\nDatum und Uhrzeit\nDezimalzahl zwischen 0 und 1 mit Zeitformatierung\n\n\nDauer\n\nDatum und Uhrzeit\nDezimalzahl als Zeitdauer\n\n\nDatum/Uhrzeit/Zeitzone\n\nDatum und Uhrzeit\nInternationalisierter Zeitstempel als formatierte Dezimalzahl, die Zeitzone muss in den Werten kodiert sein, sonst wird +1 angeommen.\n\n\n\n\nDer Datentyp einer Spalte lässt sich mit dem Kommando Datentyp anpassen. Wird auf das Kommando im Menubalken geklickt, öffnet sich eine Auswahlliste, aus der der richtige Datentyp ausgewählt werden kann (Abbildung 7.6). Wird der Datentyp geändert, dann erfolgt eine Abfrage (s. Abbildung 7.7), ob der Datentyp im aktuellen Arbeitsschritt erstzt werden soll (Aktuelle ersetzen) oder ob ein neuer Arbeitsschritt eingefügt werden soll (Neuen Schritt hinzufügen). Hier kann normalerweise Aktuelle ersetzen ausgewählt werden.\n\n\n\nAbbildung 7.6: Änderung des Datentyps einer Spalte\n\n\n\n\n\nAbbildung 7.7: Abfrage vor dem Ändern eines Datentyps\n\n\n\n\n7.2.2 Spalten umbenennen\nFalls einzelne Spaltenüberschriften einer Datenquelle unhantlich sind, lassen sich diese Spalten umbenennen. Dazu wird das Kommando Umbenennen verwendet. Das Kommando ist im Menuband Transformieren im Abschnitt Beliebige Spalte zu finden. Das Kommando öffnet einen Dialog, in dem der neue Name der Spalte eingegeben werden kann. Die Überschrift wird in einem eigenen Arbeitsschritt geändert.\nSpalten lassen sich auch durch einen Doppelklick auf den Spaltennamen umbenennen.\nDie Spaltenüberschriften müssen für die Datenstruktur eindeutig sein. Wird eine Spaltenüberschrift doppelt verwendet, dann gibt Power Query eine Fehlermeldung aus.\n\n\n\n\n\n\nPraxis\n\n\n\nDas Kommando Umbenennen sollte nur verwendet werden, wenn nur einzelne Spalten umbenannt werden müssen. Falls mehrere Spalten umbenannt werden müssen, sollte dieser Schritt als Transformation in Excel durchgeführt werden.\n\n\n\n\n7.2.3 Spalten verschieben\nIn Excel können nur zusammenhängende Bereiche einer Tabelle mit einer Adressierung gemeinsam angesprochen werden. Diese Reihenfolge ist immer dann hilfreich, wenn Matrix-Operationen mit diesen Daten ausgeführt werden sollen. Falls die Spalten einer Datenquelle in einer ungünstigen Reihenfolge vorliegen, lassen diese sich mit einem Kommando unter Verschieben richtig positionieren.\n\n\n7.2.4 Spalte teilen\nManche Daten fassen mehrere Werte in der einer Spalte zusammen. Falls die Werte als strukturierte Daten vorliegen, kann diese Spalte mit dem Kommando Spalte teilen in mehrere Spalten aufgeteilt werden. Dabei werden drei Varianten unterschieden.\n\nDie Separator-Trennung verwendet Trennzeichen zum Abgrenzen der Werte.\nDie Positions-Trennung trennt Festkodierungen mit festen Positionen in einzelne Spalten.\nDie Längen-Trennung trennt Festkodierungen, deren Werte immer die gleiche Anzahl von Symbolen haben.\n\nDie Separator-Trennung kann ein festes Trennzeichen oder ein Trennungsmuster verwenden. Die möglichen Trennungsmuster sind:\n\nBeim Wechsel zwischen kleinen und grossen Buchstaben.\nBeim Wechsel zwischen grossen und kleinen Buchstaben.\nBeim Wechsel zwischen Ziffern und Nicht-Ziffern.\nBeim Wechsel zwischen Nicht-Ziffern und Ziffern.\n\nBeim trennen von Spalten dürfen nicht semistrukturierte Daten getrennt werden, weil diese nicht für alle Werte die gleiche Struktur haben."
  },
  {
    "objectID": "kapitel/daten-importieren/kapitel.html#spalten-auswählen-oder-entfernen",
    "href": "kapitel/daten-importieren/kapitel.html#spalten-auswählen-oder-entfernen",
    "title": "7  Daten importieren",
    "section": "7.3 Spalten auswählen oder entfernen",
    "text": "7.3 Spalten auswählen oder entfernen\nZwei besondere Transformationen sind Spalten auswählen und Spalten entfernen. Diese Transformationen werden im Menuband Start angeboten. Mit diesen Transformationen lassen sich unbenötigte Spalten aus den Daten entfernen. Dadurch werden die Daten in Excel übersichtlicher.\nDiese Funktion kommt bei Excel-Arbeitsmappen häufig zum Einsatz, wenn nach Ende der Daten zusätzliche leere Spalten folgen. Diese Spalten können mit Spalten entfernen entfernt werden.\n\n\n\nAbbildung 7.8: Power Query Kommandos zum auswählen oder entfernen von Spalten (Menu Start)\n\n\nBeide Kommandos verändern die Datenstruktur, indem Spalten entfernt werden. Das Kommando Spalten auswählen lässt die ausgewählten Spalten in der Datenstruktur und entfernt alle anderen. Das Kommando Spalten entfernen entfernt nur die ausgewählten Spalten.\n\n\n\n\n\n\nAchtung\n\n\n\nEine spezielle Variante von Spalten auswählen ist das Kommando In Liste konvertieren im Menuband Transformieren. Dieses Kommando entfernt alle bis auf die ausgewählte Spalte. Dieses Kommando ändert jedoch die Spaltenüberschrift und sollte deshalb nicht verwendet werden."
  },
  {
    "objectID": "kapitel/daten-importieren/kapitel.html#daten-aktualisieren",
    "href": "kapitel/daten-importieren/kapitel.html#daten-aktualisieren",
    "title": "7  Daten importieren",
    "section": "7.4 Daten aktualisieren",
    "text": "7.4 Daten aktualisieren\nDie Daten können sich aber ändern, z.B. weil ein Formular ausgefüllt wurde oder eine Datenbank aktualisiert wurde. Dadurch ändern sich die Daten in der Datenquelle. In solchen Fällen ist die Kopie in der Arbeitsmappe nicht mehr aktuell. Um die Daten zu aktualisieren, muss die Datenverbindung aktualisiert werden.\nDazu wird das Kommando Alle aktualisieren verwendet. Das Kommando ist im Menu Daten im Abschnitt Verbindungen zu finden. Das Kommando aktualisiert alle Datenverbindungen in der Arbeitsmappe entsprechend der Importspezifikation.\n\n\n\nAbbildung 7.9: Menubalken Daten - Kommando Alle aktualisieren\n\n\nEs werden nur die importierten Daten aktualisiert. Wurde die Tabelle durch Formeln erweitert, werden diese Formeln nicht gelöscht, sondern auf die neuen Daten erweitert.\n\n\n\n\n\n\nWichtig\n\n\n\nDie importierte Struktur darf nicht verändert werden. Das bedeutet, dass innerhalb der Struktur keine Spalten hinzugefügt oder gelöscht werden dürfen. Neue Spalten für Formeln müssen rechts von der importierten Datenstruktur der Tabelle hinzugefügt werden."
  },
  {
    "objectID": "kapitel/daten-importieren/kapitel.html#datenverbindung-anpassen",
    "href": "kapitel/daten-importieren/kapitel.html#datenverbindung-anpassen",
    "title": "7  Daten importieren",
    "section": "7.5 Datenverbindung anpassen",
    "text": "7.5 Datenverbindung anpassen\nGelegentlich ändert sich der Ort einer Datenquelle. Sehr häufig tritt diese Situation ein, wenn eine Datei in einen anderen Ordner verschoben wird. In solchen Fällen muss die Datenverbindung angepasst werden. Dazu muss in Power Query die Datenquelle angepasst werden.\n\nPowerquery öffnen\nEinstellungen im Schritt “Quelle” auswählen (s. Abbildung 7.10)\nPfad zur Datenquelle anpassen\n\nNachdem die richtige Datei ausgewählt wurde, sollte immer das Schema kontrolliert werden, ob die Änderung keine Auswirkungen auf das Schema hat. Wird dieser Schritt übersprungen, kann es zu Fehlern beim Import kommen und im schlimmsten Fall werden die Formeln in der Arbeitsmappe durch eine Fehlerfortpflanzung zerstört.\nAbschliessend kann wieder das Kommando Schliessen & Landen ausgeführt werden.\n\n\n\nAbbildung 7.10: Power Query: Quelle Anpassen (Ausschnitt)\n\n\nAlle Datenverbindungen werden auch im Dialog Abfragen & Verbindungen (s. Abbildung 7.11) angezeigt. Der Dialog ist in der Gruppe Verbindungen im Abschnitt Daten zu finden. Der Dialog zeigt alle Datenverbindungen an, die in der Arbeitsmappe verwendet werden.\n\n\n\nAbbildung 7.11: Menubalken Daten - Abfragen & Verbindungen\n\n\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nUnter Windows lassen sich die Datenquellen im Dialog Abfragen & Verbindungen anpassen. Die Windows Version von Excel von dort immer den Power Query Editor. Die Version für MacOS macht das nicht. Um Änderungen an einer Abfrage vorzunehmen, muss die Abfrage in Power Query über das Kommando Daten abrufen geöffnet werden (s. Abbildung 7.12).\n\n\n\nAbbildung 7.12: Power Query unter MacOS starten"
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#variablen",
    "href": "kapitel/variablen/kapitel.html#variablen",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.1 Variablen",
    "text": "8.1 Variablen\nExcel kennt keine strikte Unterscheidung zwischen Konstanten und Variablen. Grundsätzlich sind alle Werte in Excel Konstanten, weil direkt eingegebene oder durch eine Formel erzeugte Werte nicht durch andere Formel verändert werden können.\n\n\n\n\n\n\nWarnung\n\n\n\nIn Excel lassen sich Zellen und Bereiche sperren. Damit lassen sich die Werte wie Konstanten behandeln. Diese Sperre ist Teil der Formatierung einer Zelle und muss für das gesamte Arbeitsblatt festgelegt werden. Die Sperre kann nicht für einzelne Zellen oder Bereiche festgelegt werden.\nDie Sperre eines Arbeitsblatts wird im Menuband Überprüfen mit dem Kommando Blatt schützen aktiviert. Richten Sie bei diesem Kommando kein Passwort ein.\n\n\nIst ein Arbeitsblatt gesperrt, sind die Werte auf diesem Arbeitsblatt unveränderlich und verhalten sich wie Konstanten. Ist ein Arbeitsblatt nicht gesperrt, dann verhalten sich die Werte wie Variablen.\n\n8.1.1 Dynamische Bereiche\nFormeln können mehr als einen Wert verarbeiten und mehr als einen Ergebnis liefern. Solche Formeln müssen nur in die linke obere Ecke eines Bereichs eingetragen werden. Excel erkennt automatisch, dass die Formel auf einen Bereich angewendet werden soll und erzeugt die entsprechende Formel für alle Zellen des Bereichs. Das Ergebnis einer solchen Formel ist ein dynamischer Bereich.\n\nDefinition 8.1 Vektorisieren heisst das Erzeugen eines dynamischen Bereichs aus einem statischen Bereich.\n\n\nBeispiel 8.1 (Vektorisieren eines statischen Bereichs)  \n=A1:A10\n\nIm Gegensatz zu einem normalen Bereich, ist bei einem dynamischen Bereich nur die linke obere Zelle bekannt. Um trotzdem alle Zellen eines solchen Bereichs zu adressieren, wird die Gatter- (#) Notation verwendet.\nDas Beispiel 8.1 erzeugt einen Bereich mit 10 Zellen. Die Formel wird in die linke obere Zelle des Bereichs eingetragen. Die Formel wird z.B. in die Zelle B1 eingetragen. Anschliessend können die Werte im Bereich B1:B10 über die Gatter-Notation addressiert werden: B1#.\nDer Vorteil des Vektorisierens ist, dass der Bereich durch das Einfügen neuer Zeilen vergrössert werden kann, ohne dass die nachfolgenden vektorisierten Formeln angepasst werden müssen.\n\n\n\n\n\n\nPraxis\n\n\n\nWeil Tabellen automatisch vektorisiert werden, ist es einfacher Werte in einer Tabelle zu erfassen bzw. als Tabelle zu importieren (s. Kapitel 7) und anschliessend über die Tabellenadressierung auf die Werte zu verweisen.\n\n\n\n\n\n\n\n\nMerke\n\n\n\nTabellenadressierungen auf eine Spalte oder einen Spaltenberech sind immer Vektorisiert.\n\n\n\n\nBeispiel 8.2 (Vektorisieren von Tabellenspalten)  \n= Tabelle1[Spalte1]\nDiese Formel vektorisiert die Spalte mit dem Namen Spalte1 aus der Tabelle Tabelle1. Angenommen, dass diese Formel in Zelle A1 des aktuellen Arbeitsblattes steht, dann kann anschliessend auf den Vektor über die Gatter-Notation zugegriffen werden:\n=A1#\n\n\n\n\n8.1.2 Benannte Bereiche\nIm Funktionsbalken wird ganz links die Adresse der aktuellen Zelle angezeigt. Wenn in dieses Feld geklickt wird, dann kann der Adresse ein Name zugewiesen werden. Auf diese Weise kann eine Zelle oder ein Bereich benannt werden. Der Name eines Bereichs darf nur einmal in einer Arbeitsmappe existieren. Dafür kann in jeder Zelle der Arbeitsmappe dieser Namen als Adresse verwendet werden. Dazu ist es nicht notwendig, den die genaue Arbeitsblatt- und Zellenadresse zu kennen.\nVerweist ein benannter Bereich mit einer Zelle auf den Anfang eines dynamischen Bereichs, dann kann der gesamte dynamische Bereich mit der Gatter-Notation referenziert werden.\nAuf diese Weise lassen sich oft adressierte Zelleen oder Bereiche benennen. Dadurch kann die Adresse für Verwendung in Formeln abstrahiert werden.\nDie Verwendung von benannten Bereichen wird weiter vereinfacht, dass bei der Eingabe von Formeln die Namen der benannten Bereiche als Vorschlag angezeigt werden.\n\nBeispiel 8.3 (Adressierung eines dynamischen benannten Bereichs)  \n=umsatz#\n\nBenannte Zellen helfen, auf wichtige Zellen in einer Arbeitsmappe zuzugreifen.\n\n\n\n\n\n\nMerke\n\n\n\nEin benannter Bereich entspricht einer Variablen in anderen Programmiersprachen.\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nEine benannte Zelle oder ein benannter Bereich sind immer absolut referenziert.\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nWenn einem benannten Bereich Zellen hinzugefügt werden, dann wird der benannte Bereich um diese Zellen erweitert.\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nEine Tabelle ist ein spezieller benannter Bereich, der als Ganzes oder in Teilen referenziert werden kann (s. Abschnitt 6.4.2)."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#sec-funktionen",
    "href": "kapitel/variablen/kapitel.html#sec-funktionen",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.2 Funktionen",
    "text": "8.2 Funktionen\nExcel kann nur durch Funktionen und Operatoren programmiert werden.\nExcel hat wenige vordefinierte Operatoren, wobei die Operatoren keine direkte Entsprechung als Funktion haben. Die einzige Ausnahmen sind der Potenzoperator (^) und der Textverkettungsoperator (&). Der Potenzoperator ist funktional gleich mit der POTENZ()-Funktion. Der Textverkettungsoperator entspricht der Funktion TEXTKETTE() mit zwei Argumenten.\n\n\n\n\n\n\nMerke\n\n\n\nDie mit Excel möglichen Programme sind durch die Operatoren und die vordefinierten Funktionen beschränkt.\n\n\nExcel Kommandos können nur durch Interaktion mit den Excel Menus oder Dialogen ausgeführt werden. Diese Funktionalität steht für die Progammierung oft nicht zur Verfügung.\n\n\n\n\n\n\nMakros\n\n\n\nNeben den Funktionen und Kommandos existieren in Excel noch Makros. Mit Makros können neue Kommandos und Funktionen programmiert werden. Makros folgen aber nicht den Regeln von Formeln, weil sie in einer anderen Programmiersprache geschrieben werden.\nMakros unterliegen nicht den Einschränkungen von Excel-Funktionen. Diese Freiheit ist gleichzeitig ein Fluch, denn Makros sind ein Sicherheitsrisiko und Excel präsentiert entsprechende Warnungen, wenn Makros in einer Arbeitsmappe gefunden wurde.\nAktuelle Bestrebungen von Microsoft zielen darauf ab, Makros langfristig durch Funktionen zu ersetzen. Ein Teil dieser Bestrebungen ist die Einführung von LAMBDA()-Funktionen (s. Abschnitt 8.5).\n\n\n\n\n\n\n\n\nMerke\n\n\n\nExcel hat keine Identitätsfunktion. Die Identitätsfunktion wird durch eine Formel simuliert, die nur eine Adresse enthält. Solche Formeln werden für das Vektorisieren (Definition 8.1) von Bereichen eingesetzt.\n\n\n\n8.2.1 Generatoren in Excel\nExcel hat zwei Generatorfunktionen:\n\nDie SEQUENZ()-Funktion\nDie ZUFALLSMATRIX()-Funktion\n\nBeide Generatoren erfordern die Anzahl der Zeilen und Spalten, für die Werte generiert werden sollen. Soll nur ein Spaltenvektor erzeugt werden, muss nur die Anzahl der Zeilen angegeben werden.\nDie SEQUENZ()-Funktion erzeugt eine Sequenz von Werten ausgehend vom ersten Wert (Anfang). Die Schrittweite legt die Abstände zwischen den einzelnen Werten fest. Standardmässig ist die Schrittweite mit 1 festgelegt.\n\n\n\n\n\n\nMerke\n\n\n\nWird die Schrittweite mit 0 festgelegt, dann wird der Anfangswert für die angegebene Anzahl von Spalten und Zeilen wiederholt.\n\n\nDie Funktion ZUFALLSMATRIX() erzeugt Zufallswerte in einem vorgegebenen Intervall. Diese Funktion kann reelle Zahlen oder ganze Zahlen generieren. Der Wertebereich der generierten Zahlen kann durch einen Minimal- und einem Maximalwert eingeschränkt werden. Wird kein Minimal- und Maximalwert angegeben, dann werden Werte im Intervall 0 &lt; z &lt; 1 generiert. Werden Ganzzahlen für dieses Intervall angefordert, dann werden die Werte 0 und 1 erzeugt."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#substitution",
    "href": "kapitel/variablen/kapitel.html#substitution",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.3 Substitution",
    "text": "8.3 Substitution\nExcel kennt zwei Formen der Substitution.\n\nDie Substitution über Funktionspfade\nDie Substitution mit der Funktion LET()\n\nBeide Substitutionsformen sind fast gleichwertig. Funktionspfade eigenen sich besonders gut für die Entwicklung von und zur Fehlersuche in komplexen Formeln. LET() erlaubt es, mehrere Arbeitsschritte effizient in einer Formel zusammenzufassen.\n\n8.3.1 Substitution über Funktionspfade\nEine komplexe Operation lassen sich in Excel durch Substitution über Funktionspfade vereinfachen.\n\nDefinition 8.2 Ein Funktionspfad sind Formeln, die sich über ihre Adressen aufeinander beziehen.\n\nBei einem Funktionspfad werden die substituierten Funktionen als Formeln in separate Zellen geschrieben. Die Adresse der jeweiligen Formel wird als Substitution für die Funktion eingesetzt. Sind die Formeln in einem benannten Bereich, dann kann der Name des Bereichs zur Substitution verwendet werden.\n\n\n\nAbbildung 8.1: Funktionspfad\n\n\nFunktionspfade können mithilfe des Kommandos Spur zum Vorgänger im Menü Formeln sichtbar gemacht werden (Abbildung 8.1).\n\n\n\n\n\n\nPraxis\n\n\n\nUm komplexe Formeln in bestehenden Arbeitsmappen zu verstehen, hilft das Zerlegen dieser Formeln in Funktionspfade. Dabei kann eine tabellarische Organisation helfen, wiederkehrende Operationen leichter zu erkennen.\n\n\n\n\n8.3.2 Substitution mit LET()\nExcels LET()-Funktion erlaubt das Vereinfachen komplizierter Formeln durch Variablen. Diese Variablen existieren nur im Kontext der LET()-Funktion und können nicht ausserhalb dieser Funktion verwendet werden.\nEine Variable in der LET()-Funktion entspricht einer Substitution eines Teilausdrucks einer Formel.\n\nBeispiel 8.4 (LET()-Funktion zur Substitution)  \n=LET(\n    Daten; 'Unbearbeitete Daten'!A:F;\n    DatenFeld; INDEX(\n        Daten;\n        sequenz(ZEILEN(Daten));\n        sequenz(1; SPALTEN(Daten))\n      ); \n    WENN(ISTLEER(DatenFeld);#NV;DatenFeld)\n )\n\nIn Beispiel 8.4 wird der referenzierte Bereich und der Aufruf der INDEX() substituiert. Die Substitution wird durch die Variablen Daten und DatenFeld realisiert.\n\nBeispiel 8.5 (Formel ohne Substitution)  \n=WENN(ISTLEER(INDEX(\n        'Unbearbeitete Daten'!A:F;\n        sequenz(ZEILEN('Unbearbeitete Daten'!A:F));\n        sequenz(1; SPALTEN('Unbearbeitete Daten'!A:F))\n      ));\n      #NV;\n      INDEX(\n        'Unbearbeitete Daten'!A:F;\n        sequenz(ZEILEN('Unbearbeitete Daten'!A:F));\n        sequenz(1; SPALTEN('Unbearbeitete Daten'!A:F))\n      )\n )\n\nDie beiden Beispiele veranschaulichen, wie mit der LET()-Funktion mehr als eine Substitution umgesetzt wird, um eine komplexe Formel in überschaubare Teilschritte zu zerlegen und so stark zu vereinfachen.\n\n\n\n\n\n\nPraxis\n\n\n\nWird eine Funktion in einer Formel mit den gleichen Parametern mehrfach aufgerufen, dann sollte diese Funktion immer mit LET() substituiert werden. Substituierte Berechnungen werden nur einmal für die Substitution durchgeführt und anschliessend wird nur das Ergebnis verwendet. Nicht substituierte Funktionen werden bei jedem Vorkommen neu ausgeführt."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#funktionsketten",
    "href": "kapitel/variablen/kapitel.html#funktionsketten",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.4 Funktionsketten",
    "text": "8.4 Funktionsketten\nFunktionsketten werden in Excel über Substitutionen erzeugt. Gerade bei Matrizen und anderer Transformationen von Datenstrukturen ist die Verwendung von Funktionspfaden aus zwei Gründen unhandlich:\n\nWenn die Ergebnisse mehrerer Arbeistsschritte auf einem Arbeitsblatt dargestellt werden, wird die Übersichtlichkeit behindert.\nWeil Funktionspfade separate Formeln verwenden werden die Ergebnisse für jede Formel serialisiert, was nicht immer zu den erwarteten Ergebnissen führt.\n\nWeil Excel keine Operatoren für die Funktionsverkettung bereitstellt, werden Funktionsketten immer mithilfe der Funktion LET() erzeugt.\n\n8.4.1 LET() und leere Zellen\nNormalerweise werden leere Zellen als Ergebnis einer Funktion durch 0 ersetzt. Dieses Konvertierung findet erst bei der Darstellung des Ergebnisses statt. Innerhalb einer Funktionskette werden leere Zellen als leere Zellen weitergereicht, solange keine Aggregation vorgenommen wird. Es ist deshalb möglich in einer Funktionskette eine Entscheidung mit ISTLEER() für den Fall einer leeren Zelle zu treffen.\nEine Excel-Operation muss einen Wert als Ergebnis einer Formel haben. Wird ein nicht vorhandener Wert (d.h. leere Zelle) in einem Ergebnis einer Formel gefunden, dann wird dieser Wert automatisch in den Wert 0 konvertiert. Diese Umwandlung passiert jedoch erst nachdem die Operation abgeschlossen ist und Excel das Ergebnis auf dem Arbeitsblatt darstellt.\nDieses Verhalten hat zur Folge, dass solange eine Operation nicht abgeschlossen ist, die nicht vorhandenen Werte in ihrer ursprünglichen Form erhalten bleiben. Es ist also möglich undefinierte Werte mit ISTLEER() zu prüfen.\nDie ursprünglichen Daten können unvollständig sein und enthalten dann leere Zellen an den entsprechenden Zellen. Diese fehlenden Werte als 0 darzustellen, kann zu verzerrten Ergebnissen führen. Deshalb sollten solche Werte mit dem Fehler #NV (lies: Nicht Vorhanden) markiert werden. Dieser Fehlerwert wird nicht automatisch in den Wert 0 umgewandelt, so dass die fehlenden Werte korrekt berücksichtigt werden können.\nDiese Umwandlung nutzt aus, dass Excel leere Zellen als Ergebnis von Funktionen zulässt, aber nicht als Ergebnis von Formeln. Entsprechend kann das folgende Funktionsmuster verwendet werden.\nDie beiden Vektoren G1# und H1# sind Hilfsvektoren, die Sequenzen für die Zeilen- und Spaltenindizes der Datenstruktur A:F enthalten.\nDer logische Ausdruck prüft, ob ein Feld mit dem Index G1# und H1# im Stichprobenobjekt leer ist. Falls das Feld in den unbearbeiteten Daten leer ist, dann wird der Wert #NV als Ergebnis zurückgegeben. Sonst soll der Wert im Feld übergeben.\nIn dieser Operation wird die Funktion INDEX() zwei Mal mit den gleichen Parametern aufgerufen. Das ist unpraktisch, weil die Operation an zwei Stellen angepasst müsste, wenn die Daten mehr oder weniger Spalten haben. Besser wäre es, wenn das Zwischenergebnis der INDEX()-Funktion aus der Operation herausgelöst wird und über eine Funktionsverkettung eingebunden wird. Das ist aber nicht möglich, weil Excel bei diesem Zwischenschritt die fehlenden Werte in 0 ändert, sodass anschliessend der logische Ausdruck immer FALSCH liefern würde.\nMittels der LET() Funktion wird das Ergebnis dieses Zwischenschritts in einer temporären Variablen gespeichert. Gegenüber der normalen Funktionsverkettung durch Funktionspfade hat diese Strategie den Vorteil, dass für Excel die Operation nicht abgeschlossen ist und deshalb die fehlenden Werte noch nicht in den Wert 0 umgewandelt werden. Der logische Ausdruck in der WENN()-Funktion kann also WAHR ergeben, wenn in den Daten ein Wert fehlt. Ausserdem muss die Indizierung für eine Position nur einmal durchgeführt werden, was bei komplexen Formeln die Übersichtlichkeit erhöht und die Ausführung beschleunigt.\nDie ursprüngliche Formel lässt sich also dahingehend vereinfachen, dass der Aufruf der INDEX()-Funktion “ausgeklammert” und in der Hilfsvariablen Feld gespeichert wird.\nDaraus ergibt sich die Lösung als Funktionskette.\n=LET(Feld; INDEX('Unbearbeitete Daten'!A:F;A2#;B1#); \n     WENN(\n        ISTLEER(Feld);\n        #NV;\n        Feld\n     )\n )\nDiese Lösung entspricht ungefähr der Funktionskette Formel 8.1.\n\nIndex() \\triangleright Wenn()\n\\tag{8.1}\nDamit wird der Aufruf der WENN()-Funktion vereinfacht, weil nur noch die Hilfsvariable Feld übergeben müssen. Diese Variable enthält die Daten für die Funktionsverkettung, so dass eine zusätzliche Arbeitsblattadresse nicht notwendig ist."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#sec-lambda-funktionen",
    "href": "kapitel/variablen/kapitel.html#sec-lambda-funktionen",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.5 Funktionen selbst definieren",
    "text": "8.5 Funktionen selbst definieren\nIn Excel können eigene Funktionen mit der Funktion LAMBDA() erzeugt werden. Die LAMBDA()-Funktion erzeugt die Funktion aus ihren Parametern. Dabei ist der letzte Parameter immer der Funktionskörper. Die restlichen Parameter sind die Parameter der Funktion. Es können max 253 Parameter angegeben werden, wobei keine optionalen oder vorbelegten Parameter möglich sind. Beispiel 8.6 zeigt eine einfache Funktionsdefinition mit zwei Parametern.\n\nBeispiel 8.6 (Funktionsdefinition mit zwei Parametern ohne Ausführung)  \n= LAMBDA(a; b; a + b)\n\n\n\n\n\n\n\nWarnung\n\n\n\nMit Excels LAMBDA()-Funktion können nur Funktionen durch Verkettung anderer Funktionen erzeugt werden.\n\n\nFür Excel sind Funktionen kein darstellbarer Datentyp. Wird also eine Funktion mit LAMBDA() definiert, ohne dass sie unmittelbar ausgeführt wird, zeigt Excel den Fehler #KALK! an. Dieser Fehler kann dadurch vermieden werden, indem die Funktion unmittelbar ausgeführt wird (s. Beispiel 8.7).\n\nBeispiel 8.7 (Funktionsdefinition mit zwei Parametern mit sofortiger Ausführung)  \n= LAMBDA(a; b; a + b)(1;2)\n\n\n\n\n\n\n\nWarnung\n\n\n\nDer Funktionskörper muss nicht alle Parameter verwenden. Wird eine Funktion aufgerufen, dann müssen alle Parameter angegeben werden, selbst wenn diese im Funktionskörper nicht verwendet werden.\n\n\n\n8.5.1 Map-Reduce und LAMBDA()\nWeil eine mit LAMBDA() erzeugte Funktion als Formel direkt ausgeführt werden muss, ergibt sich kein Vorteil gegenüber normalen Excel-Formeln. Die Funktion wird jedoch zum Erstellen von Callbacks benötigt. Die Hauptanwendung sind Operationen, die mit jedem Wert eines Bereichs durchgeführt werden sollen. Weil Excel normalerweise keine Schleifen zulässt, müssen solche Operationen über die Logikfunktionen MAP(), NACHZEILE(), NACHSPALTE(), REDUCE() und SCAN() erzeugt werden.\nAlle Map-Funktionen erwarten als ersten Parameter einen Bereich mit Werten und als letzten Parameter eine Funktionsdefinition mit LAMBDA().\n\nMAP() erzeugt eine Schleife, welche den Callback für jedes Element genau einmal aufruft. Es ist möglich, mehrere Bereiche anzugeben. Die Parameteranzahl der Callback muss der Anzahl der angegebenen Bereiche entsprechen.\nNACHSPALTE() erzeugt eine Schleife, die eine Funktion für jede Spalte eines Bereichs aufruft. Der Callback darf nur einen Parameter haben. Der Parameter enthält eine Liste mit allen Werten der aktuellen Zeile.\nNACHZEILE() erzeugt eine Schleife, die eine Funktion für jede Zeile eines Bereichs aufruft. Der Callback darf nur einen Parameter haben.\n\nMAP(), NACHSPALTE() und NACHZEILE() behandeln die einzelnen Durchläufe der Schleife als unabhängig. Im Gegensatz dazu sind die Durchläufe einer REDUCE() oder SCAN()-Schleife immer vom voherigen Durchlauf abhängig. REDUCE() und SCAN() erfordern als ersten Parameter einen Initialwert, der als Argument für den ersten Aufruf des Callbacks verwendet wird.\n\nREDUCE() erzeugt eine Schleife, die für jedes Element eines Bereichs den Callback ausführt. Diese Funktion erhält als ersten Parameter, das Callback-Ergebnis des vorherigen Durchlaufs und als zweiten Parameter. Das Ergebnis von REDUCE() ist das Ergebnis des letzten Aufrufs der Schleifenfunktion.\nSCAN() ist eine Variante von REDUCE(). Während REDUCE() nur das letzte Ergebnis der Callbacks ausgibt, erzeugt SCAN() einen Vektor mit allen Ergebnissen der Callback-Aufrufe.\n\n\n\n\n\n\n\nWarnung\n\n\n\nDie Map-Reduce-Funktionen dürfen nur einzelne Werte erzeugen. Datenstrukturen sind auch dann nicht erlaubt, wenn sie alle die gleiche Länge haben und sich in einen rechteckigen Bereich zusammenfügen liessen. Diese Beschränkung gilt auch, wenn die Funktionsergebnisse als Zwischenschritt an eine Kombinationsfunktion für Vektoren (z.B. VSTAPELN()) verknüpft werden. Erzeugt ein Callback eine Datenstruktur, dann erzeugt die jeweilige Funktion den Fehlerwert #KALK!.\nEinzig die Funktion REDUCE() darf Datenstrukturen erzeugen; weil diese Funktion nur ein Ergebnis haben kann.\nDiese Einschränkung bedeutet, dass die Funktionen NACHSPALTE() und NACHZEILE() die Identitätsfunktion nicht als Callback akzeptieren.\n\n\n\n\n8.5.2 Index-Schleifen mit MATRIXERSTELLEN()\nWährend die Funktionen der Map-Reduce-Familie Werte voraussetzen, ist dies nicht immer möglich. Die Funktion MATRIXERSTELLEN() erzeugt eine Schleife über zwei Iteratoren, für die Dimensionen der gewünschten Matrix. Der Callback für die Funktion erfordert deshalb 2 Parameter für die beiden Indizes.\n\n\n\n\n\n\nPraxis\n\n\n\nDie Funktion MATRIXERSTELLEN() kann meistens durch das äussere Produkt (Kapitel 12) ersetzt werden.\n\n\nDer Callback für MATRIXERSTELLEN() darf nur zwei Parameter haben, denen die aktuellen Index-Werte zugewiesen werden. Daraus ergibt sich, dass im Funktionskörper nur diese beiden Parameter bereitgestellt werden. Komplexere Anwendungen lassen sich mit Closures erzeugen. Dazu wird eine Funktion mit LAMBDA() erzeugt, die zusätzliche Werte oder Datenstrukturen als Parameter unterstützt. Diese Funktion erzeugt anschliessend den Callback für MATRIXERZEUGEN(). Der Callback ist also ein Closure der erzeugenden Funktion. Dadurch kann der Callback die Werte und Datenstrukturen der erzeugenden Funktion beim Aufruf durch die Funktion MATRIXERZEUGEN() ebenfalls verwenden (s. Beispiel 8.8).\n\nBeispiel 8.8 (Matrix mit Closure erstellen) Im Bereich A1:A4 stehen beliebige Zeichenketten.\n=MATRIXERSTELLEN(5;3;\n    LAMBDA(namen;\n           LAMBDA(a;b; \n                  ZEILENWAHL(namen; \n                             REST(a+b; \n                                  ZEILEN(namen))+1)\n           )\n    )(A1:A4)\n )\n\n\n\n8.5.3 Neue Funktionen festlegen\nNeben Schleifen können mit LAMBDA() neue Funktionen erzeugt werden. Dazu muss in einem Arbeitsblatt ein Name mit der Funktionsdefinition erzeugt werden. Namen werden über das Menüband Formeln mit dem Kommando Namen definieren erzeugt. Dieses Kommando öffnet einen Dialog, über welchen ein Name definiert werden kann(Abbildung 8.2). In diesem Dialog müssen die beiden Felder Name und Bezieht sich auf ausgefüllt werden.\nDer Name ist der Bezeichner der neuen Funktion. Hier dürfen keine Namen vorhandener Funktionen oder benannter Bereiche verwendet werden. Das Feld Bezieht sich auf muss eine LAMBDA-Formel mit der Funktionsdefinition beinhalten. Als Bereich sollte immer Arbeitsmappe ausgewählt sein, weil sonst die Funktion auf ein einziges Arbeitsblatt beschränkt wäre. Zur Dokumentation sollte im Feld Kommentar zusätzlich eine Kurzbeschreibung der Funktion angegeben werden. Leider zeigt Excel diesen Kommentar nicht als Kurzhilfe für den Funktionsnamen an.\n\n\n\nAbbildung 8.2: Funktionsdefinition mit LAMBDA()\n\n\nNachdem eine Funktion einem Namen zugewiesen wurde, kann dieser Name wie jede andere Funktion in Formeln verwendet werden (Abbildung 8.3).\n\n\n\nAbbildung 8.3: Eigene Funktion anwenden\n\n\nAls Funktionskörper können beliebige Excel Operationen vorkommen. Es bietet sich jedoch an, für komplexere Funktionen den Funktionskörper mit LET() einzuleiten. Dadurch lassen sich einzelne Arbeitsschritte leichter isolieren und verketten."
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#die-leere-zeichenkette",
    "href": "kapitel/zeichenketten/kapitel.html#die-leere-zeichenkette",
    "title": "9  Zeichenketten",
    "section": "9.1 Die leere Zeichenkette",
    "text": "9.1 Die leere Zeichenkette\nEin besonderer Fall ist die leere Zeichenkette. Die leere Zeichenkette wird oft als Platzhalter genutzt. Die leere Zeichenkette ist das neutrale Element für die Verknüpfung von Zeichenketten mit TEXTKETTE() oder TEXTVERKETTEN().\nIn Excel lässt sich die leere Zeichenkette von der leeren Zelle nur unterscheiden, indem die Formel betrachtet wird oder die Zelle mit ISTLEER() (FALSCH) und ISTTEXT() (WAHR) überprüft wird.\nDie leere Zeichenkette wird in Excel nur als Funktionsparameter durch doppelte Anführungszeichen eingerahmt. Soll eine leere Zeichenkette als Wert in eine Zelle eingegeben werden, dann ist ein einfacher Apostroph (’) einzugeben.\n\nBeispiel 9.1 (Leere Zeichenkette in einer Excel-Formel)  \n=WENN(1 = 1; \"\"; \"Fehler\")\n\n\n\n\n\n\n\nMerke\n\n\n\nWenn in Excel eine leere Zeichenkette als Wert in eine Zelle eingetragen werden soll, dann wird ein einfaches Anführungszeichen als Wert eingegeben.\n\n\n\n\n\nAbbildung 9.1: Leere Zeichenkette als Zellenwert in Excel"
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#nicht-druckbare-zeichen",
    "href": "kapitel/zeichenketten/kapitel.html#nicht-druckbare-zeichen",
    "title": "9  Zeichenketten",
    "section": "9.2 Nicht-druckbare Zeichen",
    "text": "9.2 Nicht-druckbare Zeichen\nIn Excel werden die nicht-druckbaren Zeichen für die Darstellung und für Vergleiche entfernt, jedoch werden die nicht-druckbaren Zeichen bei der Länge und beim Extrahieren berücksichtigt. In Excel kann mit der IDENTISCH()-Funktion geprüft werden, ob zwei Zeichenketten die gleiche Symbolfolge beinhalten. .\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nExcel unter Windows stellt nicht-druckbare Zeichen als Kästchen dar, Excel für MacOS zeigt diese Zeichen nicht an.\n\n\nZu den nicht-druckbaren Zeichen gehören auch Leerzeichen, Tabulatoren und Zeilenumbrüche. Diese speziellen nicht-druckbaren Zeichen sind nur erkennbar, wenn sie von druckbaren Zeichen umgeben sind.\nDeutlich wird das an den folgenden Zeichenketten:\n\nHallo\nHal&lt;0x07&gt;lo, wobei das Symbol 0x07 für einen Piepton steht\nHal&lt;0x08&gt;lo, wobei das Symbol 0x08 für einmal Rückwärtslöschen steht.\n\nDiese drei Zeichenketten haben in Excel die Längen 5, 6 und 6. Excel stellt alle drei Zeichenketten als “Hallo” dar. Ausserdem werden die Zeichenketten als gleich ausgewertet.\nExcel entfernt über die Funktion SÄUBERN() alle nicht-druckbare Zeichen aus einer Zeichenkette."
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#zeichenketten-trennen",
    "href": "kapitel/zeichenketten/kapitel.html#zeichenketten-trennen",
    "title": "9  Zeichenketten",
    "section": "9.3 Zeichenketten trennen",
    "text": "9.3 Zeichenketten trennen\n\n9.3.1 Einzelne Symbole extrahieren\nIn Excel lassen sich die einzelnen Symbole einer Zeichenkette mit der folgenden Formel extrahieren:\n=TEIL(\"Daten und Information\"; \n      SEQUENZ(LÄNGE(\"Daten und Information\"));\n      1)\nDiese Formel hat drei Funktionsaufrufe.\n\nDie Funktion LÄNGE() bestimmt die Anzahl der Symbole in der Zeichenkette.\nMit der Funktion SEQUENZ() werdem alle Positionen der Symbole durchnummeriert.\nMit TEIL(Zeichenkette; Sequenz; 1) wird ein Teil der Zeichenkette extrahiert, wobei für jede Position der Sequenz aus Schritt 2 eine Teilzeichenkette mit der Länge 1 erzeugt wird.\n\n\n\n9.3.2 Zeichenketten vor und nach einem Trenner erhalten\nDie Funktion LINKS() und RECHTS() geben eine Teilzeichenkette mit einer festen Anzahl von Zeichen zurück. Die Funktion LINKS() zählt die Anzahl der Zeichen vom Beginn der Zeichenkette und RECHTS() vom Ende her.\n\nBeispiel 9.2 (Zeichen links bis und mit der 5. Position zurückgegeben)  \n= LINKS(\"Daten und Information\"; 5)\n\nWeil RECHTS() vom Ende her zählt, kann nicht die gleiche Position wie bei LINKS() verwendet werden. Dazu muss die Position von der Gesamtlänge der Zeichenkette abgezogen werden (s. Beispiel 9.3).\n\nBeispiel 9.3 (Zeichen rechts von der 10. Position zurückgegeben)  \n= RECHTS(\n    \"Daten und Information\"; \n    LÄNGE(\"Daten und Information\")-10)\n\nEtwas eleganter arbeiten die beiden Funktionen TEXTVOR() und TEXTNACH(). Diese Funktionen suchen nach einer Teilzeichenkette und ergeben die Zeichen vor bzw. nach dieser Zeichenkette. Ein zusätzlicher Parameter ermöglicht die Suche solange zu wiederholen, bis die gesuchte Zeichenkette genau so oft gefunden wurde.\n\nBeispiel 9.4 (TEXTVOR() vor dem ersten Treffer)  \n= TEXTVOR(\"Daten und Information\"; \" \")\n\n\nBeispiel 9.5 (TEXTNACH() ab dem zweiten Treffer)  \n= TEXTNACH(\"Daten und Information\"; \" \"; 2)\n\nUm einen Wert zwischen zwei Treffern zu extrahieren, lassen sich die beiden Funktionen verketten. Diese Technik bietet sich immer dann an, wenn ein Wert zwischen zwei unterschiedlichen Markierungen extrahiert werden soll\n\nBeispiel 9.6 (Text zwischen zwei unterschiedlichen Teilketten extrahieren)  \n= TEXTVOR(TEXTNACH(\"Daten und Information\"; \"ten \"); \" Info\")\n\n\n\n9.3.3 Festkodierte Werte trennen\nEine festkodierte Datenstruktur ist eine Zeichenkette, die Werte an festgelegten Positionen mit konstanten Längen enthält. Diese Daten lassen sich mit der Funktion TEIL() extrahieren.\nDie Funktion hat drei Argumente:\n\nDie Zeichenkette, aus der die Daten extrahiert werden sollen.\nDie Position, an der die Daten beginnen.\nDie Länge der Daten als Anzahl von Symbolen.\n\n\n\nBeispiel 9.7 (IBAN in Land, Prüfziffer, Bankkennung und Kontonummer trennen) Die IBAN ist eine festkodierte Datenstruktur. Die IBAN enthält die Länderkennung, die Prüfziffer, die Bankkennung und die Kontonummer. Die Länge der einzelnen Daten ist konstant und die Position der Felder ist festgelegt.\n\n\n\nFeld\nPosition\nLänge\n\n\n\n\nLand\n1\n2\n\n\nPrüfziffer\n3\n2\n\n\nBankkennung\n5\n5\n\n\nKontonummer\n10\nLänge der IBAN - 10\n\n\n\nDie (ungültige) IBAN CH12BANK1002135135 kann mit der TEIL()-Funktion in die einzelnen Felder zerlegt werden. Dazu müssen zuerst die Positionen und Längen der Felder erstellt werden. Dazu werden die Positionen und Längen der Felder untereinander geschrieben.\n\n\n\nA\nB\nC\nD\n\n\n\n\n1\n3\n5\n10\n\n\n2\n2\n5\n= LÄNGE(IBAN_Nummer) - 10\n\n\n\nDiese Werte werden als Vektoren der Funktion TEIL() übergeben.\n= TEIL(IBAN_Nummer; A1:D1; A2:D2)\nDie Funktion TEIL() gibt die einzelnen Felder als Vektor zurück. Das Ergebnis ist {\"CH\"; \"12\"; \"BANK1\"; \"002135135\"}. Hier muss berücksichtigt werden, dass die einzelnen Felder weiterhin Zeichenketten sind.\n\n\n\n\n9.3.4 Zeichenketten mit einem Separator trennen\nSind Werte in einer Zeichenkette durch einen Separator getrennt, dann lassen sich die Werte mit der Funktion TEXTTEILEN(). Die Funktion kann eine Zeichenkette entlang von zwei Trennzeichen trennen. Dabei erzeugt die Funktion eine Matrix, wobei die Spalten durch den ersten Separator und die Zeilen durch den zweiten Separator bestimmt werden.\n\nBeispiel 9.8 (TEXTTEILEN() mit festem Trennzeichen)  \n= TEXTTEILEN(\"Daten und Information\", \" \")\n\n\n\n\n\n\n\nWichtig\n\n\n\nDie Funktion TEXTTEILEN() kann nur auf einen Wert angewandt werden. Wird ein Zeichenkettenvektor der Funktion übergeben, wird aus jeder Zeichenkette immer nur der erste Wert getrennt und als Ergebnis ausgegeben. Excel verhindert so, dass durch das Teilen mehrerer Zeichenketten die Ergebnisse einen nicht eindeutig grossen rechteckigen Bereich mit Datentyp Zeichenkette erzeugen könnten.\n\n\nDieses Problem wird durch einen Trick umgangen: Dazu wird ein zweiter Separator gewählt, der nicht in den Daten vorkommt und sich vom ursprünglichen Separator unterscheidet. Existiert bereits ein Zeilentrennzeichen in den Daten, wird dieses als zweiter Separator verwendet. Anschliessend werden alle Zeichenketten mit diesem zweiten Separator als Trennzeichen mit TEXTVERKETTEN() verkettet. Abschliessend wird die gesamte Zeichenkette mit dem ursprüngliche Separator als Spalten- und dem zweiten Separator als Zeilentrennzeichen getrennt. Dabei werden alle nicht vorhandenen Werte in einer Zeile durch #NV angezeigt.\nBeispiel 9.9 trennt einen Zeichenkettenvektor mit Werten, die durch ein Leerzeichen getrennt sind. Alle Werte sind Buchstaben oder Ziffern, aber keine Satzzeichen. Deshalb kann das Komma (,) als Zeilentrennzeichen verwendet werden. Damit der Fehlerwert #NV nachfolgende Operationen nicht behindert, wird dieser durch die leere Zeichenkette ersetzt.\n\nBeispiel 9.9 (Einen Zeichenkettenvektor entlang eines Trennzeichens teilen.)  \n=WENNFEHLER(\n    TEXTTEILEN(\n        TEXTVERKETTEN(\",\";; Zeichenketten); \n        \" \"; \n        \",\"); \n    \"\"\n)"
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#suchen-und-ersetzen",
    "href": "kapitel/zeichenketten/kapitel.html#suchen-und-ersetzen",
    "title": "9  Zeichenketten",
    "section": "9.4 Suchen und Ersetzen",
    "text": "9.4 Suchen und Ersetzen\nEine wichtige Operation für Zeichenketten ist das Suchen-und-Ersetzen. Das Suchen-und-Ersetzen lässt sich als eine spezielle Technik zur Mustererkennung vorstellen. Dabei steht eine Anwendung im Vordergrund: Die Korrektur und Vereinheitlichung von Zeichenketten. Anstatt solche Daten umständlich über eine Benutzeroberfläche zu korrigieren, sollte das Bereinigen von Zeichenketten besser automatisch erfolgen. Excel stellt dazu die Funktion WECHSELN() zur Verfügung. Diese Funktion ersetzt entweder alle Vorkommnisse einer Teilzeichenkette oder nur ihr n-tes Auftreten.\n\nBeispiel 9.10 (Alle Vorkommnisse einer Zeichenkette ersetzen)  \n= WECHSELN(\n    \"Daten oder Information oder Wahrscheinlichkeit\"; \n    \"oder\"; \n    \"und\")\n\n\nBeispiel 9.11 (Erstes Auftreten einer Zeichenkette ersetzen)  \n= WECHSELN(\n    \"Daten oder Information oder Statistik\"; \n    \"oder\"; \n    \"und\"; \n    1)\n\n\n9.4.1 Löschen von Teilzeichenketten\nTeilzeichenketten lassen sich löschen, indem die fragliche Zeichenkette durch die leere Zeichenkette ersetzt wird.\n\nBeispiel 9.12 (Teilzeichenkette entfernen)  \n= WECHSELN(\"Daten und Information\"; \"und\"; \"\")\n\n\n\n9.4.2 Zeichenketten durch Ersetzungen vereinheitlichen\nBevor das eigentliche Suchen-und-Ersetzen starten kann, sollten die betreffenden Zeichenketten bereinigt werden. Die einfachste Bereinigung ist das Entfernen von überschüssigen Leerzeichen. Dazu dient die Excel Funktion GLÄTTEN(). GLÄTTEN() entfernt alle Leerzeichen am Anfang und Ende einer Zeichenkette. Alle wiederholten Leerzeichen werden mit GLÄTTEN() zu einem einzelnen Leerzeichen zusammengefasst.\nEine zweite häufig verwendete Bereinigung ist die Transformation auf Kleinbuchstaben oder Grossbuchstaben. Hierzu dienen die drei Funktionen GROSS(), GROSS2() und KLEIN(). Die Vereinheitlichung der Schreibweise ist ein wichtiges Werkzeug um Zeichenketten mit unterschiedlichen Schreibweisen zu vereinheitlichen. Beim Bereinigen sollte eine der verfügbaren Varianten gewählt und konsequent für die Vereinheitlichung verwendet werden. Damit wird sicher gestellt, dass alle Ersetzungen unabhängig von der Schreibweise erfolgen.\nFür das eigentliche Ersetzen wird ein Suchvektor und einen Ersetzenvektor erzeugt. Die beiden Vektoren enthalten Paare aus Suchmuster und Ersetzung. Diese Paare sind geordnet und werden nacheinander ausgeführt.\n\n\n\n\n\n\nPraxis\n\n\n\nSatzzeichen sollte immer durch Leerzeichen und nicht durch eine leere Zeichenkette ersetzt werden. Die überzähligen Leerzeichen können anschliessend mit GLÄTTEN() entfernt werden. Dadurch ist gesichert, dass nicht versehentlich Elemente zusammengefügt werden. Nachdem alle Sonderzeichen entfernt wurden, sollte eine Zeichenkette noch einmal von überschüssigen Leerzeichen bereinigt werden."
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#wahrheitswerte-in-excel",
    "href": "kapitel/boolsche-operationen/kapitel.html#wahrheitswerte-in-excel",
    "title": "10  Aussagenlogik",
    "section": "10.1 Wahrheitswerte in Excel",
    "text": "10.1 Wahrheitswerte in Excel\nWie im Kapitel Datentypen bereits erwähnt, kennt Excel den Datentyp der Wahrheitswerte. Diese Wahrheitswerte können entweder den Wert WAHR oder FALSCH haben. Eine Operation, die Wahrheitswerte ergibt wird als logischer Ausdruck bezeichnet. Weil logische Ausdrücke für viele Funktionen und Operationen notwendig sind, wandelt Excel die Werte anderer Datentypen bei Bedarf um. Dabei gelten die folgenden Regeln:\n\n0 und die leere Zelle entspricht dem Wert FALSCH.\nAlle Zahlen ungleich 0 entstprechen dem Wert WAHR.\nAlle Zeichenketten inklusive der leeren Zeichenkette entsprechen dem Wert WAHR.\nFehlerwerte bleiben unverändert.\n\nWerden Wahrheitswerte in mathematischen Operationen und Funktionen verwendet, dann konvertiert Excel den Wert FALSCH in 0 und den Wert WAHR in 1 um.\nWerden Wahrheitswerte als Parameter an Zeichenkettenfunktionen übergeben, dann werden die Wahrheitswerte in die entsprechende Zeichenkette umgewandelt. Aus dem Wert WAHR wird also die Zeichenkette \"WAHR\" und aus dem Wert FALSCH wird die Zeichenkette \"FALSCH\".\n\n\n\n\n\n\nWarnung\n\n\n\nWahrheitswerte werden in den verschiedenen Sprachversionen von Excel in der eingestellten Sprache angegeben. Beim Wechsel zwischen verschiedenen Excel-Sprachversionen werden die Wahrheitswerte automatisch korrekt angezeigt. Die Umwandlung in Zeichenketten erfolgt dann in der jeweiligen Sprache. Deshalb sollte die Verwendung von in Zeichenketten konvertierten Wahrheitswerten in nachgelagerten Funktionen vermieden werden."
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#aussagenlogische-operationen",
    "href": "kapitel/boolsche-operationen/kapitel.html#aussagenlogische-operationen",
    "title": "10  Aussagenlogik",
    "section": "10.2 Aussagenlogische Operationen",
    "text": "10.2 Aussagenlogische Operationen\nFür Wahrheitswerte existieren spezielle Operationen, um die Regeln der Aussagenlogik bzw. der Boole’schen Algebra abzubilden. Diese Operationen verknüpfen Wahrheitswerte und haben Wahrheitswerte als Ergebnis. Die vier Grundoperationen NICHT (\\lnot), UND (\\land), ODER (\\lor, “inklusives Oder”) und XODER (\\oplus, “entweder-oder”) sind in Excel als Funktionen verfügbar.\nDie Funktion NICHT() wandelt einen Wert in den jeweils den anderen Wahrheitswert um. Falls anstelle eines Wahrheitswerts ein anderer Datentyp übergeben wurde, gelten die oben angegebenen Regeln für die Umwandlung.\nDie Funktionen UND(), ODER() und XODER() sind Aggregatoren. Das bedeutet, dass Sie alle Werte in dem angegebenen Bereichen zusammenfassen. Das ist oft nicht das gewünschte Verhalten. Deshalb muss bei der Arbeit mit Vektoren auf die Bool’sche Arithmetik zurückgegriffen werden, um logische Ausdrücke richtig auszuwerten.\nZum Beispiel sollen für die folgenden Werte paarweise der logische Ausdruck a \\land b ausgewertet werden, so dass für alle Wertepaare der richtige Wahrheitswert ermittelt wird.\n\n\n\nA\nB\n\n\n\n\nWAHR\nFALSCH\n\n\nFALSCH\nWAHR\n\n\nWAHR\nWAHR\n\n\nFALSCH\nWAHR\n\n\nWAHR\nWAHR\n\n\nFALSCH\nFALSCH\n\n\n\nDie Formel = UND(A1:A6; B1:B6) liefert den Wert FALSCH zurück, weil nicht alle Werte im gesamten Bereich von A1:A6 und B1:B6 gleich WAHR sind. Es gibt keine Funktion und keinen eigenen logischen Operator zur paarweisen logischen Verknüpfung dieser beiden Bereiche. Deshalb werden in Excel oft logische Ausdrücke in der Boole’schen Arithmethik eingesetzt, um nur die Werte aus den gleichen Datensätzen miteinander zu vergleichen. Diese Schreibweise ist immer dann notwendig, wenn logische Ausdrücke sich auf die einzelnen Datensätze beziehen.\nDie Formel = A1:A6 * B1:B6 hat die Werte {0;0;1;0;1;0} zum Ergebnis. Um Wahrheitswerte zuerhalten kann noch auf die Ungleichheit mit 0 geprüft werden. Dazu wird die Formel wie folgt ergänzt: = (A1:A6 * B1:B6) &lt;&gt; 0. Das Ergebnis ist nun {FALSCH; FALSCH; WAHR; FALSCH; WAHR; FALSCH}. Dieser Schritt ist in der Praxis selten notwendig, weil für die meisten Operationen Zahlenwerte implizit als Wahrheitswerte behandelt werden.\nWeil Excel alle Werte ungleich 0 als WAHR interpretiert, können die Operationen UND() mit * und die Operation ODER() mit + direkt ersetzt werden. Hierbei ist darauf zu achten, dass das nummerische Ergebnis dieser Addition oder Multiplikation ausschliesslich als Wahrheitswert von Bedeutung ist.\nDie Operation XODER() entspricht der Ungleichheit &lt;&gt;. Dabei muss allerdings darauf geachtet werden, das dieser Vergleich als Ersatz für XODER() ausschliesslich für Wahrheitswerte bzw. 0 und 1 erlaubt ist. Für die oben gezeigten Werte ergibt die Formel = (A1:A5 &lt;&gt; B1:B5) die Werte {WAHR; WAHR; FALSCH; WAHR; FALSCH; FALSCH}. Das Ergebnis ist deshalb sichergestellt, weil alle Vergleichswerte 0 oder 1 sind. Werden jedoch auch andere Vergleichswerte zugelassen, dann liefert die Formel = (A1:A6 &lt;&gt; B1:B6) die Werte {WAHR; WAHR; WAHR; WAHR; WAHR; WAHR}. Dieses Verhalten zeigt das folgende Beispiel.\n\n\n\nA\nB\n\n\n\n\n1\n0\n\n\n0\n2\n\n\n1\n2\n\n\n0\n1\n\n\n3\n2\n\n\n0\n0\n\n\n\nDamit das Richtige Ergebnis erzeugt wird, müssen die Werte in Wahrheitswerte konvertiert werden. Dazu muss die Formel durch Vergleiche ungleich 0 erweitert werden:\n= (A1:A6 &lt;&gt; 0) &lt;&gt; (B1:B6 &lt;&gt; 0)\nDiese Formel liefert die gewünschten Werte {WAHR; WAHR; FALSCH; WAHR; FALSCH; FALSCH}.\nDie folgende Tabelle zeigt logischen Operatoren und die zugehörigen Terme für die Boole’sche Arithmetik.\n\n\n\nOperator\n Boole’sche Operation\nVereinfachter Operator\n\n\n\n\n\\lnot\n1 - a\nNICHT(a)\n\n\n\\land\na * b\na * b\n\n\n\\lor\na + b - a * b\na + b\n\n\n\\oplus\na + b - 2 * a * b oder ( a - b ) ^ 2\n(a &lt;&gt; b)"
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#vergleiche",
    "href": "kapitel/boolsche-operationen/kapitel.html#vergleiche",
    "title": "10  Aussagenlogik",
    "section": "10.3 Vergleiche",
    "text": "10.3 Vergleiche\nEine besondere Art von logischen Ausdrücken sind Vergleiche. Ein Vergleich prüft das Verhältnis zweier Werte zueinander. Excel kennt die üblichen Vergleichsoperatoren, die jeweils einen Wahrheitswert zurückliefern.\nIn Excel werden die Vergleichsoperatoren wie folgt geschrieben:\n\n&gt; (grösser als)\n&lt; (kleiner als)\n&gt;= (grösser oder gleich)\n&lt;= (kleiner oder gleich)\n= (gleich)\n&lt;&gt; (ungleich)\n\nExcel’s Vergleichsoperatoren sind Datentypen sensitiv. Das bedeutet, dass die Operatoren Datentypen vor dem Vergleich nicht angleichen. Der folgende Vergleich ergibt also FALSCH.\n= 3 = \"3\"\n\n\n\n\n\n\nMerke\n\n\n\nZiffern sind keine Zahlen!\n\n\nWeil die Operationen *, + und - normalerweise vor den Vergleichsoperatoren ausgeführt werden, müssen alle Vergleiche eines logischen Ausdrucks für die Boole’sche Arithmetik in Klammern gesetzt werden.\n\n10.3.1 Der \\in-Operator mit XVERWEIS\nMithilfe der Funktion XVERGLEICH() kann der \\in-Operator aus der Mengenlehre in Excel für logische Ausdrücke bereitgestellt werden. Mit dieser Funktion XVERWEIS() können sowohl der \\in als auch der \\notin-Operator mit XVERWEIS() abgebildet werden.\nFür die folgenden Beispiele verwenden wir die Werte:\n\n\n\nA\nB\n\n\n\n\nSuchkriterium\nSuchbereich\n\n\n4\n1\n\n\n7\n3\n\n\n\n4\n\n\n\n8\n\n\n\n\n\\in-Operator: XVERWEIS(A2:A3; B2:B5; B2:B5 = B2:B5; FALSCH)\n\\notin-Operator: XVERWEIS(A2:A3; B2:B5; B2:B5 &lt;&gt; B2:B5; WAHR)\n\nDer Trick besteht darin, dass die Rückgabematrix durch einen Vergleich aus dem Suchbereich erzeugt wird. Dadurch wird die Rückgabematrix mit den gleichen Wahrheitswerten für alle Werte im Suchbereich gefüllt. Die erste Formel ergibt deshalb {WAHR; FALSCH} und die zweite Formel {FALSCH; WAHR}, weil der Wert 4 im Suchbereich vorkommt und der Wert 7 nicht. Diese Werte können direkt in logischen Ausdrücken verwendet werden.\n\n\n10.3.2 Zeichenketten vergleichen\nDie Vergleichsoperatoren zeigen die Unterschiede zweier Zeichenketten bezüglich der alphabetischen Sortierung an. Die “kleinste” Zeichenkette ist die leere Zeichenkette. Gross- und Kleinschreibung wird bei Zeichenkettenvergleichen nicht unterschieden.\nWeil Excel für Vergleiche die nicht-druckbaren Zeichen mit Ausnahme des Leerzeichens und des Tabulators ignoriert, gibt der Vergleichsoperator = WAHR auch für Zeichenketten zurück, die unterschiedliche nicht-druckbare Zeichen enthalten. Das gleiche Problem entsteht beim Vergleich von unterschiedlicher Gross- und Kleinschreibung. Um auch diese Unterschiede zu erkennen, müssen wir die Funktion IDENTISCH() verwenden. Diese Funktion vergleicht die Zeichenketten Zeichen für Zeichen und liefert nur dann WAHR zurück, wenn die Zeichenketten exakt gleich sind.\n\nBeispiel 10.1 ## Anwendung der IDENTISCH() Funktion als Vergleichsoperator.\n= WENN(IDENTISCH(\"A\"; \"a\"); \"Gleich\"; \"Ungleich\")"
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#sec-vector-logic",
    "href": "kapitel/boolsche-operationen/kapitel.html#sec-vector-logic",
    "title": "10  Aussagenlogik",
    "section": "10.4 Komplexe logische Ausdrücke und Datenstrukturen",
    "text": "10.4 Komplexe logische Ausdrücke und Datenstrukturen\nExcel hat zwar Funktionen für die logischen Operatoren Und (UND()), Oder (ODER()) und Exklusives Oder (XODER()), diese Funktionen haben aber den Nachteil, dass sie nur Werte zusammenfassen können. In der Praxis werden jedoch oft Datenstrukturen als Variablen für logische Ausdrücke verwendet. Diese sollen durch die logischen Operatoren verknüpft und nicht zusammengefasst werden.\nUm logische Verknüfungen für Datenstrukturen zu realisieren, müssen die logischen Operatoren mit der Boole’schen Arithmetik umgesetzt werden. Dazu werden die logischen Operatoren durch die entsprechenden arithmetischen Operatoren ersetzt.\n\n\nBeispiel 10.2 Für die folgenden Werte soll der folgende logische Ausdruck geprüft werden.\n\na \\land b \\lor (c &lt; 10) \\land d\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nWAHR\n5\n21\n17\n\n\nFALSCH\n3\n5\n1\n\n\nWAHR\n0\n10\n2\n\n\nFALSCH\n1\n11\n3\n\n\n\nFür diesen Ausdruck werden die Werte {WAHR; WAHR; FALSCH; FALSCH} erwartet.\nDie naive Umsetzung =ODER(UND(A1:A4;B1:B4);UND(C1:C4;D1:D4)) hat als Ergebnis den Wert WAHR.\nDie Formel = A1:A4 * B1:B4 + (C1:C4 &lt; 10) * D1:D4 liefert die Werte {5; 1; 0; 0} diese lassen sich durch einen Vergleich in die entsprechenden Wahrheitswerte konvertieren. Diese Konversion ist nur notwendig, wenn der Ausdruck nicht als logischer Ausdruck an eine Funktion übergeben wird.\n= (A1:A4 * B1:B4 + (C1:C4 &lt; 10) * D1:D4) &lt;&gt; 0\nDiese Formel ergibt die erwarteten Werte {WAHR; WAHR; FALSCH; FALSCH}.\n\n\nDie Ausnahme von dieser Regel ist Verwendung der logischen Funktionen als Tabellenfunktion. In diesem Fall können die Werte zeilenweise auch von den logischen Funktionen verarbeitet werden.\n\n\nBeispiel 10.3 Werden die Werte aus Beispiel 10.2 als Tabelle konvertiert und mit BeispielTabelle benannt, dann können die logischen Funktionen in einer gleich langen Tabelle mit der gleichen Startzeile auch als Tabellenfunktionen verwendet werden. In diesem Fall werden die Werte zeilenweise verarbeitet.\n=ODER(\n      UND(BeispielTabelle[@a];BeispielTabelle[@b]);\n      UND(BeispielTabelle[@c] &lt; 10; BeispielTabelle[@d])\n )\nDiese Formel ergibt die erwarteten Werte {WAHR; WAHR; FALSCH; FALSCH}."
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#fälle-unterscheiden",
    "href": "kapitel/boolsche-operationen/kapitel.html#fälle-unterscheiden",
    "title": "10  Aussagenlogik",
    "section": "10.5 Fälle unterscheiden",
    "text": "10.5 Fälle unterscheiden\nLogische Ausdrücke eigenen sich besonders gut, um Fallunterscheidungen zu formulieren, weil ein logischer Ausdruck immer nur zwei Werte als Ergebnis haben kann. Es gibt also für jeden logischen Ausdruck immer nur zwei unterscheidbare Fälle.\nExcel hat zwei zentrale Funktionen für Fallunterscheidungen: WENN() und WENNS(). Die Funktion WENN() ist eine einfache Unterscheidung, die Funktion WENNS() unterstützt mehrfache Unterscheidungen. In anderen Programmiersprachen wird in diesem Zusammenhang auch von Verzweigungen gesprochen.\n\n10.5.1 WENN\nDie Funktion WENN() ist eine einfache Fallunterscheidung. Einfach bedeutet hier, dass die beiden Fälles eines logischen Ausdrucks unterschieden werden. Entsprechend hat die Funktion WENN() drei Parameter:\n\nDer auszuwertende logische Ausdruck.\nDas Ergebnis falls der logische Ausdruck WAHR ergibt.\nDas Ergebnis falls der logische Ausdruck FALSCH ergibt.\n\nDas Ergebnis für den Fall, dass der logische Ausdruck FALSCH ergibt, ist optional. Fehlt dieser Parameter, dann wird der Wert FALSCH zurückgegeben.\nDas Verhalten dieser Funktion lässt sich mit den Wahrheitswerten als logischer Ausdruck direkt überprüfen:\n= WENN(WAHR; \"Guten Tag\"; \"Auf Wiedersehen\")\nWeil der logische Ausdruck in diesem Fall WAHR ist, wird der zweite Parameter als Ergebnis zurückgegeben. Die Formel gibt also den Wert \"Guten Tag\" zurück.\nWird der logische Ausdruck auf FALSCH geändert, dann liefert die Formel den Wert \"Auf Wiedersehen\".\n= WENN(FALSCH; \"Guten Tag\"; \"Auf Wiedersehen\")\nLassen wir den dritten Parameter weg, dann wird der Wert FALSCH zurückgegeben.\n= WENN(FALSCH; \"Guten Tag\")\nAusser der Fallunterscheidung hat WENN() keine weiteren Eigenschaften. Deshalb wird diese Funktion in der Praxis oft mit anderen Funktionen kombiniert. Das kann mit der Funktion WENN() selbst geschehen. In diesem Fall wird von geschachtelten Fallunterscheidungen gesprochen.\nZur Veranschaulichung dient das folgende Beispiel:\n\n\n\n\nA\n\n\n\n\n1\n4\n\n\n2\n7\n\n\n\nEine Fallunterscheidung soll prüfen, ob die Werte in A1:A2 Werte gleich 1, 3, 4 oder 8 sind. Falls das der Fall ist, soll der zugehörige Zahlwert als Zeichenkette ausgegeben werden. Falls das nicht der Fall ist, soll der Wert Ungültig zurückgegeben werden. Als geschachtelte WENN()-Funktion lässt sich diese Fallunterscheidung wie folgt formulieren:\n= WENN(A1 = 1; \"Eins\"; \n       WENN(A1 = 3; \"Drei\"; \n            WENN(A1 = 4; \"Vier\"; \n                 WENN(A1 = 8; \"Acht\"; \n                      \"Ungültig\"))))\nEine solche geschachtelte Fallunterscheidung wird als Entscheidungsbaum bezeichnet.\n\n\n10.5.2 WENNS\nDie Funktion WENN() ist eine einfache Fallunterscheidung. In vielen Excel-Arbeitsmappen existieren geschachtelte Aufrufe von WENN()-Funktionen. Diese Aufrufe machen die Formeln nicht nur schwer lesbar, sondern auch fehleranfällig und ineffizient. Deshalb sollten geschachtelte Fallunterscheidungen unbedingt vermieden werden. Mit der Funktion WENNS() lassen sich geschachtelte Fallunterscheidungen vermeiden, indem alle Fallunterscheidungen in einem einzigen Funktionsaufruf zusammengefasst werden.\n\n\n\n\n\n\nMerke\n\n\n\nGeschachtelte Fallunterscheidungen mit WENN() unbedingt vermeiden!\n\n\nDie Funktion WENNS() erwartet Parameterpaare, bestehend aus einem logischen Ausdruck und dem Ergebnis, falls dieser logische Ausdruck WAHR ergibt. Die Funktion kann bis zu 127 Parameterpaare verarbeiten, so dass sich auch sehr komplexe Fallunterscheidungen mit dieser Funktion abbilden lassen.\n\nBeispiel 10.4 Das folgende Beispiel zeigt die Verwendung der Funktion WENNS() für die geschachtelte Fallunterscheidung aus dem Abschnitt WENN.\n= WENNS(A2:A3 = 1; \"Eins\"; \n        A2:A3 = 3; \"Drei\"; \n        A2:A3 = 4; \"Vier\"; \n        A2:A3 = 8; \"Acht\")\nDas Beispiel bildet aber noch nicht die vollständige Fallunterscheidung ab. Es fehlt noch der Fall, dass keiner der logischen Ausdrücke WAHR ergibt. Leider kann WENNS() ausschliesslich logische Ausdrücke mit ihren Ergebnissen verbinden.\n\n\n\n\n\n\nMerke\n\n\n\nWENNS() kann nur logische Ausdrücke mit ihren WAHR-Ergebnissen verbinden.\n\n\nAnders als bei WENN() gibt es keine direkte Möglichkeit, ein Ergebnis festzulegen, falls alle logische Ausdrücke FALSCH ergeben. Um ein solches Verhalten zu erzeugen, wird ausgenutzt, dass die Funktion WENNS() immer einen wahren logischen Ausdruck mit einem Ergebnis verknüpft. Weil die logischen Ausdrücke in der Reihenfolge ausgewertet werden, wie sie in der Funktion angegeben sind, muss der letzte logische Ausdruck alle Fälle abdecken, die von keinem anderen der vorangegangen logischen Ausdrücke akzeptiert wurden. Der einfachste logische Ausdruck, der immer wahr ist, ist der Wahrheitswert WAHR. Deshalb wird dieser Wert als letzter logischer Ausdruck für WENNS() verwendet.\nMit diesem Wissen lässt sich das Beispiel mit WENNS() vervollständigen:\n= WENNS(A2:A3 = 1; \"Eins\"; \n        A2:A3 = 3; \"Drei\"; \n        A2:A3 = 4; \"Vier\"; \n        A2:A3 = 8; \"Acht\"; \n        WAHR; \"Ungültig\")\nDiese Formel prüft die Werte in A2:A3 auf Gleichheit mit den Werten 1, 3, 4 und 8. Für diese Zahlen wird die zugehörige Zahlwert als Zeichenkette ausgegeben. Falls keiner dieser Werte gefunden wird, wird der Wert Ungültig zurückgegeben.\n\nDie Fallunterscheidung mit WENNS() endet beim ersten logischen Ausdruck, der WAHR ergibt. Die Funktion prüft der Reihe nach alle angegebenen logischen Ausdrücke. Sobald einer dieser Ausdrücke WAHR ist, wird der zugehörige Ergebniswert ausgegeben und die Funktion wird beendet. Diese Eigenschaft begründet, dass die logischen Ausdrück nur die Fälle prüfen müssen, die von den vorangegangenen logischen Ausdrücken nicht abgedeckt wurden.\n\nBeispiel 10.5 (Fallunterscheidung mit WENNS() vereinfachen) Gegeben ist die Formel mit geschachtelten Entscheidungen.\n= WENN(J2&gt;=O2;\n    (WENN(J2&gt;L2;\n          0;\n          WENN(J2&lt;=L2;\n               WENN((J2&gt;N2)*(J2&gt;=O2);\n                    (K2+((M2-K2)/(N2-L2))*(J2-L2));\n                    WENN((J2&lt;=N2)*(J2&lt;O2);\n                         (M2+((O2-M2)/(O2-N2))*(J2-N2))\n                ))\n          )\n    ));\n    100)\nDiese Formel ist aus zwei Gründen übermässig komplex.\n\nDie Fallunterscheidung mit WENN() ist geschachtelt.\nEs existieren redundante Fallunterscheidungen.\n\nBevor die Fallunterscheidung mit WENNS() vereinfacht wird, werden die redundanten Fallunterscheidungen entfernt. Das betrifft die zweite (J2 &gt; L2) und die vierte Fallunterscheidung (J2 &gt; N2). Im jeweiligen FALSCH-Fall wird der gegenteilige logische Ausdruck geprüft. Das ist in diesem Fall unnötig, weil die äussere Fallunterscheidung diesen Fall bereits abdeckt. Werden die redundanten logischen Ausdrücke und unnötige Klammern entfernt, dann ergibt sich die folgende wesentlich einfachere Formel.\n= WENN(J2&gt;=O2;\n    WENN(J2&gt;L2;\n          0;\n          WENN((J2&gt;N2)*(J2&gt;=O2);\n              K2+(M2-K2)/(N2-L2)*(J2-L2);\n              M2+(O2-M2)/(O2-N2)*(J2-N2)\n          )\n    );\n    100)\nDie äusserste Fallunterscheidung hat für den Fall WAHR eine geschachtelte WENN()-Funktion und im Fall FALSCH ein einfaches Ergebnis. Das ist für WENNS() unhandlich, so dass die äusserste Fallunterscheidung durch Umkehrung des logischen Ausdrucks umgestellt wird.\n= WENN(J2&lt;O2;\n       100; \n       WENN(J2&gt;L2;\n            0;\n            WENN((J2&gt;N2)*(J2&gt;=O2);\n                 K2+(M2-K2)/(N2-L2)*(J2-L2);\n                 M2+(O2-M2)/(O2-N2)*(J2-N2)\n            )\n       )\n  )\nNun lassen sich die vier unterschiedlichen Fälle gut erkennen und mit WENNS() abbilden. Daraus ergibt sich die folgende Formel.\n= WENNS(J2&lt;O2; 100; \n        J2&gt;L2; 0; \n        (J2&gt;N2)*(J2&gt;=O2); K2+(M2-K2)/(N2-L2)*(J2-L2); \n        WAHR; M2+(O2-M2)/(O2-N2)*(J2-N2)\n  )\nDiese Formel ist wesentlich einfacher zu lesen und zu verstehen. Beim Durchgehen der Fälle fällt auf, dass ein Teilausdruck des dritten Falls das Gegenteil des ersten Falls ist. Diese Bedingung wurde bereits im ersten Fall geprüft und würde sie nicht gelten, dann wäre die Formel bereits beendet worden. Deshalb können bereits geprüfte Teilausdrücke in den nachfolgenden Ausdrücken weggefallen. Dadurch wird nicht nur die Verschachtelung, sondern auch die Komplexität der logischen Ausdrücke vereinfacht.\n= WENNS(J2&lt;O2; 100; \n        J2&gt;L2; 0; \n        J2&gt;N2; K2+(M2-K2)/(N2-L2)*(J2-L2); \n        WAHR;  M2+(O2-M2)/(O2-N2)*(J2-N2)\n  )\nDiese Formel hat noch den Makel, dass der letzte Fall WAHR keine Konstante abbildet. Besser wäre es, wenn der zweite und der letzte Fall vertauscht wären, so dass der Wert 0 der letzte Wert ist. Dazu müssen die logischen Ausdrücke umorganisiert werden. Bei der Umorganisation ist die Reihenfolge der logischen Ausdrücke zu beachten: Die letzten beiden Fälle sind nicht umabhängig vom logischen Ausdruck J2&gt;L2. Beim Umorganisieren darf diese Abhängigkeit nicht verloren gehen.\n= WENNS(J2&lt;O2; 100; \n        (J2&lt;=L2)*(J2&gt;N2); K2+(M2-K2)/(N2-L2)*(J2-L2); \n        J2&lt;=L2; M2+(O2-M2)/(O2-N2)*(J2-N2)\n        WAHR; 0\n  )\nDiese Formel ist deutlich einfacher und weniger Fehleranfällig als die ursprüngliche Formel mit geschachtelten WENN()-Funktionen. Es lassen sich auch weitere Fälle hinzufügen, ohne dass die Formel komplexer wird. Dabei ist zu beachten, dass diese Fälle vor dem Fall WAHR angegeben werden müssen.\n\n\n\n10.5.3 Nicht erreichbare Entscheidungen\nEin besonderes Problem sind Entscheidungen, die zwar definiert aber nie erreicht werden können. Solche Entscheidungen sind immer redundant. Eine nicht erreichbare Entscheidung kann nur dann auftreten, wenn eine vorangegangene Entscheidung bereits den geprüften Fall abdeckt. Ergibt ein solcher logischer Ausdruck Falsch, dann wird eine spätere Entscheidung für den gleichen Fall im Falsch-Zweig des Entscheidungsbaums ebenfalls Falsch ergeben. Der Wahr-Zweig dieser Entscheidung kann damit nie erreicht werden.\n\nBeispiel 10.6 (Nicht erreichbare Entscheidung)  \n=WENNS( A1 &gt; 5; \"Sehr gut\"; \n        A1 &gt; 3; \"Genügend\"; \n        A1 &gt; 4; \"Gut\"; \n        A1 &lt;= 3; \"Ungenügend\")\n\nIn Beispiel 10.6 kann nie das Ergebnis “Gut” erzeugt werden, weil der zweite logische Ausdruck (A1 &gt; 3) alle Werte “maskiert”, die durch den dritten logischen Ausdruck (A1 &gt; 4) als “Gut” markiert werden müssten. “Ungenügend” würde trotzdem angezeigt werden, wenn der Wert in A1 entweder 1, 2 oder 3 ist.\n\n\n\n\n\n\nWichtig\n\n\n\nEine nicht erreichbare Entscheidung ist kein technischer Fehler, sondern ein logischer Fehler.\n\n\nIm Beispiel 10.6 kann die Entscheidung A1 &gt; 4 nicht erreicht werden, weil das vorherige und allgemeinere Kriterium A1 &gt; 3 für die gleichen Werte zutrifft.\n\n\n\n\n\n\nMerke\n\n\n\nEs müssen immer die spezielleren Kriterien vor den allgemeineren Kriterien geprüft werden.\n\n\nNicht erreichbare Entscheidungen lassen sich durch das Formale prüfen der logischen Ausdrücke leicht erkennen. Dazu werden logischen Ausdrücke und die zugehörigen Wertebereiche für den Wahr- und Falsch-Fall untereinander aufgeschrieben. Ein logischer Ausdruck kann einen Wertebereich nur dann abdecken, wenn dieser eine Teilmenge des Wertebereichs der aktuellen logischen Verzweigung ist.\n\n\nTabelle 10.1: Formale Prüfung der logischen Ausdrücke aus Beispiel 10.6\n\n\nRang\nlogischer Ausdruck\nWahr-Fall\nFalsch-Fall\n\n\n\n\n1\nA1 &gt; 5\nA1 &gt; 5\nA1 &lt;= 5\n\n\n2\nA1 &gt; 3\nA1 &gt; 3\nA1 &lt;= 3\n\n\n3\nA1 &gt; 4\nA1 &gt; 4\nA1 &lt;= 4\n\n\n4\nA1 &lt;= 3\nA1 &lt;= 3\nA1 &gt; 3\n\n\n\n\nWeil die Funktion WENNS() verwendet wird, ist der Wertebereich für einen logischen Ausdruck durch die Falsch-Fälle der logischen Ausdrücke mit niedrigerem Rang abgedeckt.\nFür Rang 3 muss wegen dieser Tabelle der logischen Ausdruck in Formel 10.1 gelten. Dieser Ausdruck kann jedoch nie Wahr ergeben, weil der geiche Wert in Variable A1 nicht kleiner oder gleich 3 und gleichzeitig grösser als 4 sein kann.\n\n\\begin{aligned}\n& (A1 &lt;= 5) \\land & (A1 &lt;= 3) \\land & (A1 &gt; 4) \\\\\n\\Leftrightarrow & & (A1 &lt;= 3) \\land & (A1 &gt; 4) \\\\\n\\Leftrightarrow &  & \\text{Falsch}\n\\end{aligned}\n\\tag{10.1}\n\n\n10.5.4 ERSTERWERT\nDie Funktion ERSTERWERT() bildet einen Spezialfall von WENNS() ab: Es wird bei allen logischen Ausdrücken ein Vergleich auf Gleichheit des Suchkriteriums mit verschiedenen Referenzwerten durchgeführt. In diesem Fall können die logischen Ausdrücke mit ERSTERWERT() stark vereinfacht werden. Das lässt sich am ersten Beispiel im Abschnitt WENNS veranschaulichen.\nWeil alle logischen Ausdrücke die Gleichheit über den gleichen Adressbereich prüfen, kann die Operation mit der Funktion ERSTERWERT() vereinfacht wie folgt werden.\n= ERSTERWERT(A2:A3; \n             1; \"Eins\"; \n             3; \"Drei\"; \n             4; \"Vier\"; \n             8; \"Acht\"; \n             \"Ungültig\")\n\n\n10.5.5 XVERWEIS zur Fallunterscheidung\nDie Funktion XVERWEIS() ist als Excels Version des \\in-Operators bereits bekannt. Die Funktion kann auch als Alternative zur Funktion ERSTERWERT() verwendet werden. In diesem Fall werden als Rückgabematrix keine Wahrheitswerte, sondern die Ergebnisse der Fallunterscheidung angegeben.\nDer Vorteil dieser Anwendung ist, dass die Fallunterscheidung nicht mehr auf die Anzahl der Parameterpaare beschränkt ist und die Parameterpaare zum Zeitpunkt der Formelerstellung auch nicht bekannt sein müssen.\nDas folgende Beispiel zeigt die Umsetzung des Beispiels aus dem Abschnitt ERSTERWERT mit XVERWEIS(). Dazu wird zuerst eine Tabelle mit den Vergleichswerten und den zugehörigen Ergebnissen erstellt.\n\n\n\nC\nD\n\n\n\n\n1\nEins\n\n\n3\nDrei\n\n\n4\nVier\n\n\n8\nAcht\n\n\n\nDiese Referenztabelle stell in Spalte C die sog. Suchmatrix und in Spalte D die sog. Rückgabematrix bereit. Mit diesen Werten lässt sich die Fallunterscheidung wie folgt abbilden.\n= XVERWEIS(A2:A3; C2:D5; D2:D5; \"Ungültig\")\nEin weiterer Vorteil von XVERGLEICH() gegenüber ERSTERWERT() sind Vergleiche mit den Operatoren =, &lt;= oder &gt;=. Diese Vergleiche lassen sich über den fünften Parameter von XVERWEIS() konfigurieren. Dabei steht der Wert 0 für die Gleichheit, der Wert -1 für kleiner oder gleich und der Wert 1 für grösser oder gleich. Die Vergleiche sind immer so organisiert, dass der linke Operand dem Suchkriterium entspricht und der rechte Operand dem Wert in der Suchmatrix. Bei einem Treffer wird der Wert aus der Rückgabematrix zurückgegeben. Gibt es keinen Treffer für den Vergleich wird der Wert aus dem vierten Parameter wenn_nicht_gefunden geliefert.\n\n\n10.5.6 Anwendungshilfe für Fallunterscheidungen\nDie Anwendung der verschiedenen Fallunterscheidungsfunktionen hängt von verschiedenen Kriterien ab. Diese sind hier zusammengefasst:\nDie Funktion WENN() wird immer dann eingesetzt, wenn ein logischer Ausdruck geprüft werden muss und nur die beiden Fälle dieses Ausdrucks unterschieden werden müssen.\nDie Funktion WENNS() wird immer dann eingesetzt werden, wenn mehrere logische Ausdrücke geprüft werden müssen. Die logischen Ausdrücke können dabei beliebig komplex sein und sich auf verschiedene Daten und Bereiche beziehen.\nDie Funktion ERSTERWERT() wird immer dann eingesetzt, wenn die Gleichheit des Suchkriteriums mit wenigen Referenzwerten überprüft werden soll. Die Suchkriterien sind für alle Vergleiche identisch.\nDie Funktion XVERWEIS() wird immer dann eingesetzt, wenn ein Vergleich auf Gleichheit, Kleiner-oder-Gleich oder Grösser-oder-Gleich durchgeführt werden muss. Die Suchkriterien und die Vergleichsoperatoren sind für alle Vergleiche identisch.\nDie Funktion XVERWEIS() muss anstatt von ERSTERWERT() verwendet werden, wenn die Referenzwerte des Vergleichs zum Zeitpunkt der Formelerstellung noch nicht bekannt sind oder leicht änderbar bleiben sollen."
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#filtern",
    "href": "kapitel/boolsche-operationen/kapitel.html#filtern",
    "title": "10  Aussagenlogik",
    "section": "10.6 Filtern",
    "text": "10.6 Filtern\nExcel bietet die Funktion FILTER() zum Filtern von Daten. Diese Funktion erzeugt einen Ergebnisbereich mit den Werten, die durch den angegebenen logischen Ausdruck ausgewählt wurden.\n\n\n\n\n\n\nWarnung\n\n\n\nIn Excel können in Tabellen und Pivot-Tabellen für einzelne Vektoren Werte für die Darstellung “gefiltert” werden. Dabei verwendet Excel nicht die Filter Funktion, sondern blendet einzelne Datensätze aus. Dadurch können die Ergebnisse nachgereihter Operationen nicht mit den dargestellten Werten zusammenpassen, weil nicht-dargestellte Werte weiterhin Teil der Daten sind und bei Berechnungen weiterhin mitberücksichtigt werden.\n\n\nDas Ergebnis der Funktion FILTER() ist ein dynamischer Bereich mit den ausgewählten Werten. Im Gegensatz zu Tabellen-Filter sind die nicht dargestellten Werte nicht mehr Teil der Daten. Deshalb sind die Ergebnisse der FILTER()-Funktion konsistent mit den Ergebnissen der nachgereihten Operationen.\n\nDefinition 10.1 Excels FILTER()-Funktion wählt aus einem Vektor die Werte aus, für die ein Auswahlvektor den Wert WAHR oder einen Wert, der dem logischen WAHR entspricht.\n\n\n\nBeispiel 10.7 (Filtern mit Excel) Gegeben sind die folgende Werte in den Spalten A und B. Die Filter()-Funktion steht an Adresse D2.\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n1\nBasel\n WAHR\n\n=FILTER(A1:A5; B1:B5)\n\n\n2\nGenf\n FALSCH\n\n Basel\n\n\n3\nLugano\n FALSCH\n\n Zug\n\n\n4\nZug\nWAHR \n\n Zürich\n\n\n5\nZürich\nWAHR \n\n \n\n\n\nWeil die Werte in Spalte B vom Datentyp Wahrheitswert sind, kann &gt; dieser Vektor zur Auswahl der Städtenamen in Spalte A verwendet werden.\nAnstelle eines Vektors mit Wahrheitswerten wird meistens ein Vergleich als zweiter Parameter übergeben. Dieser Vergleich muss einen Vektor erzeugen, der genauso lang ist, wie der Vektor im ersten Parameter. Solche Vektoren werden dynamisch erzeugt, indem ein Vergleich entweder den Vektor selbst oder einen benachbarten Vektor verwendet.\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n1\nBasel\ndeutsch\n\n=FILTER(A1:A5; B1:B5 = \"deutsch\")\n\n\n2\nGenf\n französisch\n\n Basel\n\n\n3\nLugano\nitalienisch\n\n Zug\n\n\n4\nZug\ndeutsch \n\n Zürich\n\n\n5\nZürich\ndeutsch \n\n \n\n\n\n\n\n\n10.6.1 Excel Filter und logische Operationen\nWeil die FILTER()-Funktion immer über Vektoren arbeitet, können die logischen Funktionen nicht verwendet werden, weil sie keine Vektoren erzeugen. Deshalb muss der logische Ausdruck des Filters als Boole’sche Arithmetik formuliert werden (Kapitel 10.4).\n\n\n\n\n\n\nHinweis\n\n\n\nDie Funktion NICHT() ist kein Aggregator und kann mit der FILTER()-Funktion kombiniert werden.\n\n\nUm mit komplexen logischen Ausdrücken in Filtern zu verwenden, müssen wir die logischen Operatoren durch ihre arithmetische Schreibweise ersetzen.\n\n\nTabelle 10.2: Beispiel eines komplexen logischen Ausdrucks mit FILTER()\n\n\n\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\n\n\n\n\n1\nName\nSprache\nEinwohner:innen\n\nFormel\n\n\n2\nBasel\ndeutsch\n173863\n\n=FILTER(A2:A6;(B2:B6=\"deutsch\")*(C2:C6 &gt; 100000))\n\n\n3\nGenf\n französisch\n203856\n\n Basel\n\n\n4\nLugano\nitalienisch\n62315\n\n Zürich\n\n\n5\nZug\ndeutsch \n30934\n\n\n\n\n6\nZürich\ndeutsch \n421878"
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#selektieren",
    "href": "kapitel/boolsche-operationen/kapitel.html#selektieren",
    "title": "10  Aussagenlogik",
    "section": "10.7 Selektieren",
    "text": "10.7 Selektieren\nSehr häufig liegen umfangreiche Daten mit vielen Vektoren vor. Soll sich eine Analyse auf einzelne Vektoren beschränken, dann sollen, analog zum Filtern von Datensätzen, nur diese Vektoren ausgewählt werden.\n\nDefinition 10.2 Das Filtern von Vektoren wird als selektieren bezeichnet.\n\nWeil die Vektoren einer Stichprobe in der Regel benannt sind, werden Vektoren über ihre Namen selektiert.\n\n\n\n\n\n\nMerke\n\n\n\nDie Vektorennamen einer Stichprobe haben besondere Eigenschaften:\n\nVektorennamen sind immer von Datentyp Zeichenkette.\nVektorennamen einer Stichprobe bilden einen Vektor.\nDie Vektorennamen einer Stichprobe sind eindeutig.\n\n\n\nDie dritte Eigenschaft ist nicht ganz offensichtlich, denn in einer manuell eingegebenen zwei-dimensionalen Struktur kann eine Überschrift mehrfach verwendet werden. Sobald eine solche Struktur in eine Excel-Tabelle umgewandelt wird, erzwingt Excel eindeutige Vektorennamen.\nAus diesen Eigenschaften folgt, dass die Auswahl von Vektoren durch die Eigenschaften von Zeichenketten unterstützt wird. Wir können zur Auswahl die folgenden Operationen verwenden:\n\nIdentischer Vektorname\nVektorname beginnt mit einer bestimmten Zeichenkette\nVektorname endet mit einer bestimmten Zeichenkette\nVektorname enthält an einer beliebigen Position eine bestimme Zeichenkette\n\nDiese Operationen lassen sich als logische Ausdrücke formulieren, wodurch sich komplexere Selektoren umsetzen lassen.\nDer einfachste Weg zum Vektoren adressieren ist die Verwendung des Vektornamens über die Tabellenadressierung. Dabei wird der Vektorname in eckige Klammern gesetzt (s. Abschnitt 6.4.2). Die Tabellenadressierung ist jedoch auf vollständige Namen und auf zusammenhängende Bereiche beschränkt.\nDie Verwendung einer Selektor-Funktion zur Auswahl von Vektoren ist nicht auf Tabellen beschränkt, sondern kann mit beliebigen tabellarischen Strukturen angewendet werden. In Excel wird eine Selektor Funktion durch die Funktionskette eines Filters mit der Funktion SPALTENWAHL() erreicht.\nNeben der Tabellenadressierung bietet Excel die Funktion SPALTENWAHL(), um Vektoren aus einem Bereich auszulesen. Diese Funktion benötigt aber die Position der gewünschten Spalte, denn oft sollen aber Vektoren über Namen oder Namensteile ausgewählt werden. Dafür kommt die Funktion XVERGLEICH() zur Anwendung. Mit XVERGLEICH() erhalten wir die Position eines gesuchten Werts in einem angegebenen Bereich.\nDie Idee hinter dem hier beschriebenen Ansatz ist, dass wir herausfinden, wo unser gewünschter Vektor in der Stichprobe steht. Anschliessend wählen wir alle Werte an dieser Position mit der Funktion Spaltenwahl() aus.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Funktion XVERGLEICH() ähnelt der Funktion XVERWEIS() indem wir einen Wert in einem Vektor suchen können. Anstelle eines Referenzwerts aus einem anderen Vektor liefert XVERGLEICH() nur die Position des gesuchten Werts zurück. Falls ein Wert mehrfach vorkommt, dann gibt die Funktion nur die erste Position zurück.\n\n\nDer Funktion XVERGLEICH() können mehrere Suchwerte übergeben werden, für welche die Positionen bestimmt werden.\n\n\n\nBeispiel für Vektorenselektion\n\n\nDer Algorithmus zum Selektieren von Vektoren ist durch die folgenden Schritte definiert:\n\nWir vektorisieren nur die Vektornamen auf einem neuen Arbeitsblatt mit der Identitätsfunktion ab Adresse B1. Zur Veranschaulichung nenne ich dieses Arbeitsblatt Stichprobendaten.\nWir vektorisieren alle Stichprobendaten mittels der Identitätsfunktion auf dem gleichen Arbeitsblatt ab Adresse B2.\nAuf einem neuen Arbeitsblatt geben wir in der ersten Zeile die Vektorennamen ab Adresse A1 ein, die wir auswählen möchten. In diesem Beispiel wird angenommen, dass 3 Vektoren ausgewählt werden sollen.\nWir wählen die einzelnen Vektoren mit der folgenden Formel an der Adresse A2 aus.\n\n\nBeispiel 10.8 (Selektion von Vektoren in Excel)  \n=SPALTENWAHL(Stichprobendaten!$B$2#; \n             XVERGLEICH(A1:C1; Stichprobendaten!$B$1#))\n\nDer Vorteil dieser Strategie ist, dass die Selektion individuelle, nicht-zusammenhängende Vektoren selektieren kann und nicht auf Tabellen beschränkt ist."
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#sortieren",
    "href": "kapitel/boolsche-operationen/kapitel.html#sortieren",
    "title": "10  Aussagenlogik",
    "section": "10.8 Sortieren",
    "text": "10.8 Sortieren\nExcel kennt zwei Funktionen zum Sortieren:\n\nSORTIEREN()\nSORTIERENNACH()\n\nDie Funktion SORTIEREN() sortiert einen Bereich zeilen- oder spaltenweise. Für allgemeine Sortierungen nach mehreren Vektoren stellt Excel die Funktion SORTIEREN() zur Verfügung.\n\n\n\n\n\n\nHinweis\n\n\n\nExcels SORTIERENNACH()-Funktion kann einen Bereich zeilen- oder spaltenweise sortieren. Diese Funktion hat vier Parameter:\n\nMatrix - der zu sortierende Bereich, der keine Matrix sein muss.\nSortierindex - die Spalten- oder Zeilennummer, nach der sortiert werden soll. Standardmässig wird die erste Spalte bzw. die erste Zeile angenommen.\nSortierreihenfolge - legt die Sortierreihenfolge fest. 1, um aufsteigend und -1, um absteigend zu sortieren.\nnach_Spalte - Ein Wahrheitswert, ob die Spalten oder die Zeilen sortiert werden sollen. WAHR bedeutet, dass die Spalten (horizontal) sortiert werden sollen. FALSCH bedeutet, dass die Zeilen (vertikal) sortiert werden sollen. Standardmässig wird zeilenweise sortiert.\n\n\n\nDie Funktion ermöglicht es, mehrere Vektoren auf einmal nach mehreren gemeinsamen Kriterien zu sortieren. Dazu müssen zuerst die Sortierkriterien identifiziert werden.\nDie Funktion SORTIERENNACH() deckt den Spezialfall ab, wenn die Sortierung nach einem externen Kriterium erfolgen soll. Während SORTIEREN() erfordert, dass die Sortierindizes im zu sortierenden Bereich enthalten sind, können die Sortierindizes bei SORTIERENNACH() an einer beliebigen Stelle in der Arbeitsmappe liegen.\n\n10.8.0.1 Schritt 1: Sortierkriterien festlegen.\nDie Sortierkriterien sind durch die Werte im Sortierindex festgelegt, nach denen sortiert werden soll. Der Sortierindex ist ein Vektor mit einem Wert für eine Zeile bzw. Spalte der Sortiermatrix. Entlang der Werte im Sortierindex wird die Sortiermatrix sortiert.\nIn Excel können die Vektoren mit den Sortierkriterien an einer beliebigen Position in einer Arbeitsmappe liegen. Dabei müssen zwei Bedingungen erfüllt sein:\n\nDer Sortierindex und die Sortiermatrix müssen die gleiche Länge haben.\nDie Sortierindex und die Sortiermatrix müssen die gleiche Orientierung haben.\n\n\n\n10.8.0.2 Schritt 2:\nIm zweiten Schritt werden die zu sortierenden Vektoren ausgewählt.\nIn R wird dieser zweite Schritt automatisch auf die vorgegebene Stichprobe angewandt. In Excel können wir zusammenhängende Vektoren als “Matrix” an die SORTIERENNACH()-Funktion übergeben. Hängen die Vektoren nicht direkt zusammen, dann müssen mehrere Sortieroperationen mit den gleichen Referenzen auf die Sortierreferenzen durchgeführt werden.\nIn Excel wird die Sortierrichtung als Sortierreihenfolge bezeichnet und als separater Parameter für das jeweilige Sortierkriterium angegeben. Dabei steht 1 für die aufsteigende Sortierung und -1 für die absteigende Sortierung."
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#rezepte",
    "href": "kapitel/boolsche-operationen/kapitel.html#rezepte",
    "title": "10  Aussagenlogik",
    "section": "10.9 Rezepte",
    "text": "10.9 Rezepte\n\n10.9.1 Fehlerwerte abfangen\nViele Excel-Funktionen geben einen Fehlerwert zurück, falls die Funktion kein gültiges Ergebnis ermitteln kann. Weil sich diese Fehlerwerte in Operationen fortpflanzen, müssen diese Werte durch einen geeigneten regulären Wert ersetzt werden. Das kann mit der folgenden Entscheidung erreicht werden.\n= WENN(ISTFEHLER(A1); 0; A1)\nDiese Operation ersetzt alle Fehlerwerte durch den Wert 0 und lässt alle anderen Werte unverändert.\nWeil diese Entscheidung sehr oft vorkommt, gibt es die Funktion WENNFEHLER(), mit der die gleiche Operation einfacher ausgedrückt werden kann.\n= WENNFEHLER(A1; 0)\n\n\n10.9.2 Eine Zahl für genau eine Bedingung zurückgeben\nEin häufiger Spezialfall für Unterscheidungen ist die Auswahl von Zahlen, die genau einen logischen Ausdrück erfüllen. Solche Unterscheidungen geben im FALSCH-Fall 0 und im anderen Fall die gesuchte Zahl zurück. In diesem Spezialfall kann der Zielwert ohne Umweg über die WENN()-Funktion mit dem logischen Ausdruck multipliziert werden. Der logische Ausdruck liefert 1 für WAHR und 0 für FALSCH. Die Multiplikation mit 0 liefert immer 0. Die Multiplikation mit 1 liefert den Zielwert.\nDas Beispiel gibt für die folgenden Werte alle Zahlen zurück, die grösser als 10 und kleiner als 20 sind.\n\n\n\nA\n\n\n\n\n13\n\n\n5\n\n\n17\n\n\n20\n\n\n12\n\n\n2\n\n\n29\n\n\n11\n\n\n7\n\n\n32\n\n\n\nNormalerweise würde diese Entscheidung durch die folgende Operation abgebildet:\n= WENN((A1:A10 &gt; 10) * (A1:A10 &lt; 20); A1:A10; 0)\n\n\n\n\n\n\nWarnung\n\n\n\nDiese spezielle Fallunterscheidung sollte auf Korrektheit überprüft werden, wenn im WAHR-Fall der Wert 0 erlaubt ist. In diesem Fall wird der Wert 0 nicht vom logischen Ausdruck unterschieden.\n\n\nWeil alle Werte Zahlen sind, handelt es sich um den Spezialfall, dass der WAHR-Wert eine Zahl und der FALSCH-Fall eine 0 ist. Für diesen Fall lässt sich die Formel vereinfachen, indem die gesuchten Werte mit dem logischen Ausdruck multipliziert werden:\n= A1:A10 * (A1:A10 &gt; 10) * (A1:A10 &lt; 20)\nDas Ergebnis beider Formeln sind die Werte {13;0;17;0;12;0;0;11;0;0}.\nDamit dieses Rezept funktioniert, müssen alle Teile des logischen Ausdrucks genau die Werte FALSCH oder WAHR bzw. 0 oder 1 zurückgeben. Das ist notwendig, weil nur das neutrale Element die Zielwerte unverändert lässt. Eine direkte Übergabe von Zahlen im logischen Ausdruck verfälscht das Ergebnis, weil nicht mit dem neutralen Element gerechnet wird.\nSoll für einen logischen Ausdruck nur der Wert 1 oder 0 zurückgegeben werden, dann kann der Rückgabebereich am Anfang der Formel weggelassen werden. Es wird dann nur der logische Ausdruck angegeben. Die Formel = (A1:A10 &gt; 10) * (A1:A10 &lt; 20) hat die Werte {1;0;1;0;1;0;0;1;0;0} als Ergebnis.\n\n\n10.9.3 Fehlerwerte vergleichen\nFehlerwerte können nicht direkt mit den Vergleichsoperatoren verglichen werden, weil Excel immer den ersten gefundenen Fehlerwert als Ergebnis einer Operation zurückgibt. Deshalb müssen Fehlerwerte zuerst in normale Werte konvertiert werden. Damit verschiedene Fehlerwerte miteinander verglichen werden können, müssen die verschiedenen Fehlerwerte zuerst in eindeutige Zahlen umgewandelt werden. Das übernimmt die Funktion FEHLER.TYP(). Diese Zahlen können anschliessend wie gewohnt weiter verarbeitet werden.\nDas folgende Beispiel weist den gegebenen Fehlerwerten eine Fehlermeldung zu:\n\n\n\nA\n\n\n\n\n#NV\n\n\n#WERT!\n\n\n3\n\n\n\nDie folgende Formel liefert die Werte {\"Fehler: #NV\"; \"Fehlerhafter Wert\", \"Kein Fehler\"}.\n= WENNS(FEHLER.TYP(A1:A2) = 7; \"Fehler: #NV\"; \n        FEHLER.TYP(A1:A2) = 3; \"Fehlerhafter Wert\"; \n        WAHR; \"Kein Fehler\")\nWeil alle Vergleiche die Gleichheit überprüfen, kann die Formel mit der Funktion ERSTERWERT() vereinfacht werden. Die Formel lautet dann:\n= ERSTERWERT( WENNFEHLER(FEHLER.TYP(A1:A3); 0);\n              3; \"Fehlerhafter Wert\";\n              7; \"Fehler: #NV\";\n              \"Kein Fehler\")\nFür diesen Schritt muss die Operation mit der Funktion WENNFEHLER() erweitert werden, weil die Funktion FEHLER.TYP() einen Fehler ausgibt, wenn der übergebene Wert kein Fehlerwert ist. Weil die Fehlertypen mit Werten grösser 0 durchnummeriert sind, bietet sich für reguläre Werte der Wert 0 an.\n\n\n10.9.4 Filtern und Summen\nBis Juli 2020 mussten die Funktionen SUMMEWENN() oder SUMMEWENNS() verwendet werden, um Daten nach Kriterien zu summieren. Diese Funktionen haben allerdings den Nachteil, dass keine echten logischen Ausdrücke verwendet werden können. Seit Juli 2020 steht die FILTER()-Funktion zur Verfügung. Dadurch können echte logische Ausdrücke als Filterkriterien eingesetzt werden. Gleichzeitig hat sich die Bedeutung der Funktionen SUMMEWENN() und SUMMEWENNS()geändert (s. Kapitel 13).\nDie folgende Formel sollten wir jetzt mit der Filter-Technik umschreiben.\n\nBeispiel 10.9 (Summenwenn durch Filter-Summe ersetzen) Alt wurde geschrieben:\n= SUMMEWENN(B2#; \"&lt; 0\")\nNeu ist die gleiche Funktion etwas ausführlicher:\n= SUMME( FILTER(B2#; B2# &lt; 0) )\nDiese Schreibweise hat den Vorteil, dass die einzelnen Schritte nach dem Prinzip der Problemzerlegung getrennt werden und separat untersucht werden können. Das war in der alten Schreibweise nur indirekt möglich.\n\nDas gleiche Prinzip gilt auch für ZÄHLENWENN() und ZÄHLENWENNS() anwenden. In diesem Fall wird entweder die Funktion ANZAHL() oder die Funktion ANZAHL2() als Aggregator eingesetzt.\nDer grösste Vorteil ist aber, dass mit dieser Technik beliebige EXCEL-Aggregatoren mit gefilterten Daten eingesetzbar sind und nicht mehr auf die vordefinierten Aggregatoren eingeschränkt sind. Mit dem Filtern wird es ausserdem möglich, andere logische Ausdrücke als nur einen direkte Vergleich oder, im Fall von SUMMEWENNS() oder ZÄHLENWENNS(), mit Und verknüpfte Vergleiche durchzuführen.\n\n\n\n\n\n\nWarnung\n\n\n\nWenn wir komplexe logische Ausdrücke mit Excels FILTER()-Funktion verwenden wollen, dann müssen wir für die logischen Operatoren die arithmetische Schreibweise für die logischen Ausdrücke verwenden!"
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#sequenzen",
    "href": "kapitel/vektor-operationen/kapitel.html#sequenzen",
    "title": "11  Vektoroperationen",
    "section": "11.1 Sequenzen",
    "text": "11.1 Sequenzen\n\n11.1.1 Nullvektor\n\n\n11.1.2 Einsvektor"
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#konkatenation",
    "href": "kapitel/vektor-operationen/kapitel.html#konkatenation",
    "title": "11  Vektoroperationen",
    "section": "11.2 Konkatenation",
    "text": "11.2 Konkatenation\nHSTAPELN\nVSTAPELN"
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#transformationen",
    "href": "kapitel/vektor-operationen/kapitel.html#transformationen",
    "title": "11  Vektoroperationen",
    "section": "11.3 Transformationen",
    "text": "11.3 Transformationen\n\n\n\n\n\n\nMerke\n\n\n\nBeliebige Transformationen lassen sich mit MAP() umsetzen.\n\n\n\n11.3.1 Transformationen mit einem Skalar\n\n\n11.3.2 Transformationen mit einem Vektor"
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#aggregationen",
    "href": "kapitel/vektor-operationen/kapitel.html#aggregationen",
    "title": "11  Vektoroperationen",
    "section": "11.4 Aggregationen",
    "text": "11.4 Aggregationen\n\n\n\n\n\n\nMerke\n\n\n\nBeliebige Aggregationen lassen sich mit REDUCE() umsetzen."
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#zählen",
    "href": "kapitel/vektor-operationen/kapitel.html#zählen",
    "title": "11  Vektoroperationen",
    "section": "11.5 Zählen",
    "text": "11.5 Zählen\n### Zählen durch Summieren\n### Zählen durch Filtern\n\n11.5.1 Zählen durch Nummerieren"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#vektorform-einer-matrix",
    "href": "kapitel/matrix-operationen/kapitel.html#vektorform-einer-matrix",
    "title": "12  Matrix-Operationen",
    "section": "12.1 Vektorform einer Matrix",
    "text": "12.1 Vektorform einer Matrix\nZUSPALTE()\nZUZEILE()"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrizen-vergleichen",
    "href": "kapitel/matrix-operationen/kapitel.html#matrizen-vergleichen",
    "title": "12  Matrix-Operationen",
    "section": "12.2 Matrizen vergleichen",
    "text": "12.2 Matrizen vergleichen\n= UND(Matrix1!A1# = Matrix2!A1#)"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#einheitsmatrix-erzeugen",
    "href": "kapitel/matrix-operationen/kapitel.html#einheitsmatrix-erzeugen",
    "title": "12  Matrix-Operationen",
    "section": "12.3 Einheitsmatrix erzeugen",
    "text": "12.3 Einheitsmatrix erzeugen\nExcel erlaubt nur das Erzeugen der Identitätsmatrix. Die Funktion MEINHEIT() erzeugt also immer eine quadratische Einheitsmatrix."
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrizen-transponieren",
    "href": "kapitel/matrix-operationen/kapitel.html#matrizen-transponieren",
    "title": "12  Matrix-Operationen",
    "section": "12.4 Matrizen Transponieren",
    "text": "12.4 Matrizen Transponieren\nMTRANS()"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrixaddition",
    "href": "kapitel/matrix-operationen/kapitel.html#matrixaddition",
    "title": "12  Matrix-Operationen",
    "section": "12.5 Matrixaddition",
    "text": "12.5 Matrixaddition"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#vektoraddition",
    "href": "kapitel/matrix-operationen/kapitel.html#vektoraddition",
    "title": "12  Matrix-Operationen",
    "section": "12.6 Vektoraddition",
    "text": "12.6 Vektoraddition"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#skalarmultiplikation",
    "href": "kapitel/matrix-operationen/kapitel.html#skalarmultiplikation",
    "title": "12  Matrix-Operationen",
    "section": "12.7 Skalarmultiplikation",
    "text": "12.7 Skalarmultiplikation"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrixmultiplikationkreuzprodukt",
    "href": "kapitel/matrix-operationen/kapitel.html#matrixmultiplikationkreuzprodukt",
    "title": "12  Matrix-Operationen",
    "section": "12.8 Matrixmultiplikation/Kreuzprodukt",
    "text": "12.8 Matrixmultiplikation/Kreuzprodukt\nMMULT()\n\n12.8.1 Inverse Matrix\nMINV()\n\n\n12.8.2 Zeilen- und Spaltensummen"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#äusseres-vektorprodukt",
    "href": "kapitel/matrix-operationen/kapitel.html#äusseres-vektorprodukt",
    "title": "12  Matrix-Operationen",
    "section": "12.9 Äusseres Vektorprodukt",
    "text": "12.9 Äusseres Vektorprodukt\n\n12.9.1 Dreieckmatrizen erzeugen\n\n\n12.9.2 Vorgänger- und Nachfolgersummen"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#co-occurence-matrizen",
    "href": "kapitel/matrix-operationen/kapitel.html#co-occurence-matrizen",
    "title": "12  Matrix-Operationen",
    "section": "12.10 Co-Occurence Matrizen",
    "text": "12.10 Co-Occurence Matrizen"
  },
  {
    "objectID": "kapitel/kodieren-gruppieren/kapitel.html#indizieren",
    "href": "kapitel/kodieren-gruppieren/kapitel.html#indizieren",
    "title": "13  Indizieren und Gruppieren",
    "section": "13.1 Indizieren",
    "text": "13.1 Indizieren\nEs werden drei Arten von Indizes unterschieden:\n\nDer Primärindex, mit dem ein einzelner Datensatz eindeutig identifiziert werden kann.\nFremdschlüssel sind Sekundärindizes für Querverweise auf eine zweite Datenstruktur (eine sog. Indextabelle oder engl. Lookup-Table).\nGruppenindizes sind Sekundärindizes zur Identifikation von Datensätzen mit gemeinsamen Eigenschaften.\n\nWeil ein Index Werte über einen Datensatz enthält, gehört ein Index zum jeweiligen Datensatz und wird über einen Indexvektor in einer Stichprobe abgebildet.\n\n13.1.1 Hashing eines Primärindex\nIn Excel muss zum Durchnummerieren die SEQUENZ()-Funktion verwendet werden. Das erreichen wir mit der folgenden Operation: =SEQUENZ(ZEILEN(DatenBereich)), wobei DatenBereich eine Excel-Adresse sein muss. Weil mit Excel keine leeren Tabellen existieren, führt diese Sequenz in Excel zu keinen Fehlern. Wegen dieser Eigenschaft muss ein entsprechender Bereich mindestens einen Umfang von einem Datensatz haben.\n\n\n\n\n\n\nHinweis\n\n\n\nDiese Eigenschaft gilt auch für Tabellen, die nur aus Überschriften bestehen. Damit die Formel zum Nummerieren eingegeben werden kann, muss mindestens ein Datensatz existeren, weil sonst keine Zelle für die Formel in der Tabelle existiert.\n\n\n\n\n13.1.2 Hashing eines Sekundärindex\nEin Sekundärindex kennzeichnet mehrere Datensätze mit gleichen Eigenschaften. Die einfachste Hashing-Funktion für Sekundärindizes ist WENNS(). Diese Funktion stellt über die Bedingungen sicher, dass alle Hashes einen Datensatz die Merkmale eindeutig auswerten.\nSoll ein Sekundärindex über Zahlen gebildet werden, werden die Ganzzahldivision und der Modulo-Operator häufig als Hashing-Funktion eingesetzt. Die Ganzzahldivision fasst aufeinanderfolgende Werte zu einem Wert zusammen. Der Modulo-Operator weist aufeinanderfolgenden Werte unterschiedlichen Werten zu.\n\n\n\n\n\n\nPraxis\n\n\n\nExcels Funktion für die Ganzzahldivision ist eigentlich die Funktion QUOTIENT(). Diese Funktion kann leider nur mit einzelnen Werten und nicht mit Vektoren oder Matrizen verwendet werden. Deshalb ist die Funktion QUOTIENT() für die Praxis nur bedingt tauglich. Stattdessen muss die Ganzzahldivision in Excel wie folgt simuliert werden.\n= GANZZAHL( A1:A9 / 3 )\n\n\n\n\nBeispiel 13.1 (Tage und Wochen bestimmen) Gegegeben ist eine Sequenz in A1 Startend bei 1. Diese Sequenz bildet die Werktage eines Projekts ab. Der erste Tag ist ein Montag. Feiertage werden nicht berücksichtigt. Aus dieser Sequenz sollen Wochentage und Wochen ermittelt werden.\nDie Wochennummern im Projekt wird mithilfe der Ganzzahldivision ermittelt.\n= GANZZAHL(A1# / 5)\nDie Wochentage werden mit dem Modulo-Operator bestimmt.\n=  REST(A1#; 5)\n\n\n\n\n13.1.3 Indizieren mit einer Referenztabelle\nOft müssen Werte in andere Werte übersetzt werden, wobei die Kodierung keiner mathematischen Logik folgt. In diesem Fall werden sog. Referenz- oder Kodierungstabellen für das Indizieren verwendet. Sehr oft werden diese Tabellen unabhängig von der Datenerhebung erstellt.\nEine Referenztabelle hat mindestens zwei Spalten, wobei per Konvention die erste Spalte die möglichen Werte vor dem Indizieren. Diese Werte können in den Daten auftreten. Alle folgenden Spalten enthalten Kodierungen des ursprünglichen Werts.\n\n\n\n\n\n\nWarnung\n\n\n\nEnthält eine Referenztabelle mehr als eine Kodierung, dann müssen die Werte spaltenweise kodiert werden.\n\n\n\n\nBeispiel 13.2 (Likert-Skala kodieren) Eine Liker-Skala ist ein Messinstrument zur Meinungs- oder Empfindungserhebung. Eine Likert Skala wird in der Regel zwischen zwei Extremfeststellungen erfasst, die später als Zahlen kodiert ausgewertet werden.\nSolche Skalen erfordern eine Referenztabelle, weil die Ordnung der Werte sich nicht aus der alphabetischen Reihenfolge der Zeichenketten ergibt. Für die Auswertung müssen die Zeichenketten in Zahlen kodiert werden. Es ist üblich die Kodierung von Likert-Skalen in Referenztabellen zu dokumentieren. Die folgende Tabelle zeigt eine eine fünfstufige Liker-Skala mit den entsprechenden Zahlenwerten für die Auswertung.\n\n\n\nWert\nZahl\n\n\n\n\nTrifft gar nicht zu\n-2\n\n\nTrifft eher nicht zu\n1\n\n\nUnentschieden\n0\n\n\n Trifft eher zu\n1\n\n\n Trifft voll und ganz zu\n2\n\n\n\nDie Kodierung erfolgt mit der Funktion XVERWEIS().\n= XVERWEIS(Tabelle1[Aussage_Likert]; \n           KodierungLikert[Wert]; \n           KodierungLikert[Zahl])"
  },
  {
    "objectID": "kapitel/kodieren-gruppieren/kapitel.html#gruppieren",
    "href": "kapitel/kodieren-gruppieren/kapitel.html#gruppieren",
    "title": "13  Indizieren und Gruppieren",
    "section": "13.2 Gruppieren",
    "text": "13.2 Gruppieren\nDas Gruppieren ist in Excel auf die folgenden Funktionen beschränkt:\n\nZÄHLENWENN()\nZÄHLENWENNS()\nSUMMEWENN()\nSUMMEWENNS()\nMINWENNS()\nMAXWENNS()\nMITTELWERTWENN()\nMITTELWERTWENNS()\n\n\n\n\n\n\n\nWichtig\n\n\n\nDie Funktionen ZÄHLENWENN(), ZÄHLENWENNS(), SUMMEWENN() und SUMMEWENNS() wurden bis 2019 zum Erzeugen von bedingten Aggregationen verwendet. Mit der Einführung dynamischer Felder und der FILTER()-Funktion lassen sich bedingte Aggregationen einfacher und flexibler durch Funktionsverkettungen von FILTER() mit einer beliebigen Aggregationsfunktion erreichen.\nSeit dieser Version hat sich die Bedeutung der Funktionen geändert. Die Funktionen werden neu als Gruppierungsfunktionen verwendet.\n\n\n\n\n\n\n\n\nMerke\n\n\n\nWenn für eine Funktion eine WENN und eine WENNS-Variante existieren, dann sollte für gruppierte Aggregationen immer die WENNS-Variante verwendet werden.\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nDie beiden Funktionen WENN() und WENNS() sind keine Gruppierungsfunktionen, sondern Unterscheidungen. Trotz ähnlicher Namen, dürfen sie nicht mit den Gruppierungsfunktionen verwechselt werden.\n\n\nDie WENNS-Varianten sind für alle Aggregationen bezüglich ihrer Parameter konsistent, so dass die Syntax leichter zu merken ist. Die beiden (neuen) Funktionen MINWENNS() und MAXWENNS() veranschaulichen diese Empfehlung, weil für diese Funktionen keine WENN-Variante existiert.\nEine Gruppierungsoperation erfolgt in drei Schritten:\n\nErzeugen der Gruppierungsindizes.\nErmitteln der Gruppierungen\nAusführen der Gruppierungsfunktion für alle Gruppierungen\n\nBeispiel 13.3 zeigt diese drei Schritte. Gegeben sind Werte zwischen 1 und 25, die in drei Bereiche organisiert werden sollen. Es soll die Anzahl der Werte in den einzelnen Bereichen ermittelt werden. Die Werte liegen in einer Tabellenstruktur vor.\nDer Gruppierungsindex ist ein Merkmal und sollte gemeinsam mit den Daten gespeichert und versioniert werden. Dieser Sekundärindex strukturiert die Daten in einer Tabelle oder einem Bereich.\n\n\nBeispiel 13.3 (Gruppiertes Zählen) Die Reihenfolge der Schritte muss eingehalten werden!\nSchritt 1: Sekundärindex erstellen (in A1)\n= WENNS( Tabelle1[Werte] &gt; 18; \"gross\";\n         Tabelle1[Werte] &gt; 10; \"mittel\"; \n         WAHR; \"klein\" )\nDieser Schritt kann entfallen, wenn ein Sekundärindex bereits vorhanden ist.\nSchritt 2: Gruppierungen ermitteln (in C1)\n= EINDEUTIG(A1#)\nSchritt 3: Zählen (in D1)\n= ZÄHLENWENNS( A1#; C1# )\n\n\nBeim Zählen wird der Gruppierungsindex direkt verwendet. Die anderen Gruppierungsfunktionen haben einen zusätzlichen Parameter für den Vektor über den die Operation ausgeführt werden soll.\n\n13.2.1 Mehrere Sekundärindizes\n\n\n\n\n\n\nWichtig\n\n\n\nDie WENNS-Varianten können mehrere Sekundärindizes verknüpfen. Dabei werden die vorkommenden Permutationen der Hash-Werte als Index verwendet. Alle Kriterienvektoren müssen dafür gleich lang sein und die Permutationen abbilden.\n\n\nUm alle vorkommenden Permutationen mehrerer Sekundärindizes zu ermitteln, müssen die Vektoren einen Bereich bilden. Für diese Bereich ermittelt die Funktion EINDEUTIG() dann jede vorkommende Zeile. Dieser Trick funktioniert jedoch nur wenn alle Sekundärindizes nebeneinander stehen, was oft nicht der Fall ist. Die Funktion HSTAPELN() löst dieses Problem, weil sie mehrere Vektoren zu einem Bereich zusammenfügen kann. Beispiel 13.4 zeigt die Vorgehensweise für drei Vektoren.\n\nBeispiel 13.4 (Vorkommende Permutationen mehrerer Sekundärindizes ermitteln in A1)  \n= LET(bereich; HSTAPELN(\n                Tabelle1[Name]; \n                Tabelle1[Durchlauf]; \n                Tabelle1[Gruppe] );\n      EINDEUTIG(bereich)\n)\n\nDiese Permutationstabelle kann nun mit den Gruppierungsfunktionen verwendet werden. Beispiel 13.5 zeigt die Verwendeung der Gruppierungen aus Beispiel 13.4.\n\nBeispiel 13.5 (Gruppieren mit mehreren Indizes)  \n= MITTELWERTWENNS(\n    Tabelle1[Zeit]; \n    Tabelle1[Name];      SPALTENWAHL(A1#; 1);\n    Tabelle1[Durchlauf]; SPALTENWAHL(A1#; 2); \n    Tabelle1[Gruppe];    SPALTENWAHL(A1#; 3)\n)"
  },
  {
    "objectID": "kapitel/daten-formen/kapitel.html",
    "href": "kapitel/daten-formen/kapitel.html",
    "title": "14  Daten formen",
    "section": "",
    "text": "Work in Progress"
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html#universelle-kennwerte",
    "href": "kapitel/daten-beschreiben/kapitel.html#universelle-kennwerte",
    "title": "15  Daten beschreiben",
    "section": "15.1 Universelle Kennwerte",
    "text": "15.1 Universelle Kennwerte"
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html#lagemasse",
    "href": "kapitel/daten-beschreiben/kapitel.html#lagemasse",
    "title": "15  Daten beschreiben",
    "section": "15.2 Lagemasse",
    "text": "15.2 Lagemasse\n\n15.2.1 Modus\n\n\n15.2.2 Median\n### Mittelwert"
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html#streumasse",
    "href": "kapitel/daten-beschreiben/kapitel.html#streumasse",
    "title": "15  Daten beschreiben",
    "section": "15.3 Streumasse",
    "text": "15.3 Streumasse\n\n15.3.1 Interquatilsabstand\n\n\n15.3.2 Varianz und Standardabweichung"
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html#diagramme-erstellen",
    "href": "kapitel/daten-visualisieren/kapitel.html#diagramme-erstellen",
    "title": "16  Daten visualisieren",
    "section": "16.1 Diagramme erstellen",
    "text": "16.1 Diagramme erstellen\n\n\n\n\n\n\nWarnung\n\n\n\nExcels Diagrammtypen erfordern, dass die Daten in einem bestimmten Format vorliegen. Das notwendige Format hängt vom Diagrammtyp ab. Es lassen sich deshalb nicht alle Visualisuerungen aus den gleichen Datenstrukturen erzeugen.\n\n\n\n16.1.1 Datenvorbereitung\nDie verschiedenen Diagrammtypen erfordern unterschiedliche Datenformate. Deshalb müssen die Daten für die Visualisierung vorbereitet und in eine geeignete Form gebarcht werden.\nAlle Werte, die visualisiert werden sollen, müssen einen Bereich bilden. Dieser Bereich kann innerhalb einer Tabelle liegen oder dynamische Felder umfassen.\nExcel organisiert die Werte für die Darstellung in Datenreihen. Je nach Visualisierung besteht eine Datenreihe aus einer Überschrift und einer, zwei oder drei Spalten mit Werten.\n\n\n\n\n\n\nPraxis\n\n\n\nEs vereinfacht die Arbeit, wenn die Spalten einer Datenreihe möglichst nebeneinander geschrieben werden. Alternativ können die gleichen Teilspalten organisiert werden. Letzteres bietet sich immer dann an, wenn die Werte in die Breitform transponiert werden müssen.\n\n\nErlaubt ein Diagramm horizontale oder vertikale Achsbeschriftungen, dann werden diese normalerweise in den Spalten vor den eigentlichen Werte für den Darstellungsbereicht positioniert.\n\n\n16.1.2 Diagrammerstellung\nUm ein Diagramm zu erstellen müssen die vorbereiteten Daten markiert werden. Excel Diagramme können nicht mit dynamischen Feldern umgehen, so dass alle darzustellenden Werte markiert werden müssen.\nAusser den Spaltenüberschriften sollten keine weiteren Daten markiert werden. Dazu gehören auch die Werte, die für die Beschriftung der X-Achse benötigt werden. Abbildung 16.1 zeigt eine solche Markierung.\n\n\n\nAbbildung 16.1: Markierung der zu visualisierenden Werte\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nOft liegen Daten als Tabellen oder Dynamische Felder vor. Verändert sich die Anzahl der Werte einer solchen Datenstruktur, betrifft diese Änderung nicht den markierten Wertebereich. Liegen neue Werte ausserhalb des markierten Bereichs für ein Diagramm, dann werden diese Werte nicht dargestellt. In solchen Fällen muss der Bereich für die Darstellung nachträglich erweitert werden.\n\n\nNachdem wie zu visualisierenden Werte markiert wurden, kann das eigentliche Diagramm eingefügt werden. Dazu muss aus dem Menübalken Einfügen im Abschnitt Diagramme (Abbildung 16.2) die gewünschte Darstellung ausgewählt werden.\n\n\n\nAbbildung 16.2: Menübalken Einfügen/Diagramme\n\n\nDie Auswahl erzeugt das gewünschte Diagramm für die markierten Daten auf dem aktuellen Arbeitsblatt.\n\n\n16.1.3 Diagrammbearbeitung\nSobald ein Diagramm erstellt wurde, kann es über das Menüband Diagrammentwurf angepasst werden. Dieses Menüband wird nur angezeigt, wenn ein Diagramm ausgewählt wurde.\n\n\n\nAbbildung 16.3: Menüband Diagrammentwurf\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nFür die Datenvisualisierung sind das Untermenü Diagrammelement hinzufügen und das Kommando Daten markieren zentral, weil über sie die Darstellung gesteuert wird.\nDaneben wird das Farbschema über das Menü Farben ändern gesteuert.\n\n\nDas Untermenu Diagrammelement hinzufügen erlaubt es, einzelne Diagrammelement zur Visualisierung hinzuzufügen oder zu entfernen. Die möglichen Diagrammelemente hängen vom jeweiligen Diagrammtyp ab.\nDas Untermenu Schnelllayout bietet Vorlagen für die einzelnen Diagrammelemente. Diese Vorlagen dienen oft als Basis für die weitere Verfeinerung mit dem Untermenü Diagrammelement hinzufügen.\nMit dem Untermenü Farbenändern können die im Diagramm verwendeten Farben angepasst werden. In diesem Menü finden sich verschiedene Farbpaletten. Diese Farbpaletten werden durch das aktuelle Farbschema der Arbeitsmappe bestimmt.\nIm Bereich Diagrammformatvorlagen kann die allgemeine Darstellung angepasst werden. Diese Einstellungen sollten nur angepasst werden, um ein Diagramm für eine besondere Präsentation vorzubereiten. Normalerweise werden über diesen Bereich keine Änderungen vorgenommen.\nDas Kommando Zeile/Spalte tauschen ist bei guter Vorbereitung der Daten nicht notwendig. Dieses Kommando ändert für eine Visualisierung die Verwendung von Spalten in die Verwendung von Zeilen. Dieses Kommando ist entsprechend nur Notwendig, wenn die Daten zeilenweise anstatt spaltenweise vorbereitet wurden.\n\n\n\n\n\n\nWarnung\n\n\n\nManche Visualisierungen verwenden ein komplexes internes Datenmodell, so dass die mehrfache Anwendung des Kommandos Zeile/Spalte tauschen nicht zwingend zur urspünglichen Darstellung führt.\n\n\nMit Daten markieren werden die Datenreihen und Quellen für Achsbeschriftungen in der Arbeitsmappe festgelegt. Dieses Kommando öffnet den Dialog Datenquelle auswählen, mit dem die Daten den einzelnen Darstellungselementen zugewiesen werden. Mit diesem Kommando können die Datenreihen korrigiert werden, wenn die automatische Erkennung von Excel nicht das gewünschte Ergebnis erzielt hat.\nDas Untermenü Diagrammtyp ändern erlaubt es, den Typ eines Diagramms zu verändern, ohne den Diagrammbereich zu verändern. Weil die verschiedenen Diagrammtyp recht unterschiedliche Anforderungen an die Datenorganisation haben, sollte hier nur Diagrammtypen innerhalb der gleichen Gruppe ausgewählt werden. Beispielsweise könnte so ein Balkendiagramm in ein Säulendiagramm geändert werden.\nDas Kommand Diagramm verschieben erlaubt es, ein Diagramm auf einem eigenen Arbeitsblatt zu platzieren. Dieses Kommando ist nur dann sinnvoll, wenn eine Arbeitsmappe zur Präsentation der Daten verwendet wird.\n\n\n16.1.4 Dialog Datenquelle auswählen\nÜber das Kommando Daten markieren wird der Dialog Datenquelle auswählen (Abbildung 16.4) geöffnet, über den die Daten den Darstellungselementen zugewiesen werden.\n\n\n\nAbbildung 16.4: Dialog Datenquelle auswählen\n\n\nDer Dialog besteht aus drei Teilen:\n\nDer Teil Bereichdetails zeigt den Datenbereich des Diagramms an. Der angezeigte Bereich sollte nicht in diesem Teil verändert werden.\nDer Teil Legendeneinträge (Reihen) weist Spalten mit Werten den Datenreihen des Diagramms zu. In diesem Teil werden die verwendeten Datenbereiche angepasst, die im Teil Bereichdetails zusammengefasst angezeigt werden.\nIm Teil Ausgeblendete und leere Zellen wird die Behandlung von leeren Zellen und #NA-Werten festgelegt. In diesem Teil sind nur selten Anpassungen notwendig.\n\n\n\n16.1.5 Diagramme exportieren\nUm ein Diagramm zum Einbetten in andere Programme bereitzustellen, muss das Diagramm aus Excel exportiert werden. Dazu ein Rechtsklick auf das Diagramm öffnet ein Kontextmenü, in welchem sich der Punkt Als Grafik speichern ... findet (Abbildung 16.5).\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nDas Kommando zum Speichern von Diagrammen heisst unter MacOS Als Bild speichern ... und unter Windows Als Grafik speichern ....\n\n\n\n\n\nAbbildung 16.5: Kontextmenu zum Exportieren eines Diagramms\n\n\nAnschliessend erscheint ein Dialog zum Speichern der Diagrammdatei (Abbildung 16.6). Standardmässig bietet dieser Dialog als Dateityp das Grafikformat PNG an, was in den meisten Fällen gewählt werden sollte. Alternativ können Diagramme in den Formaten JPEG, GIF, PDF, BMP und SVG exportiert werden. Hier sind für die Praxis nur die beiden Formate PDF und SVG von Bedeutung.\n\n\n\n\n\n\nPraxis\n\n\n\nDas PDF-Format sollte gewählt werden, wenn eine Grafik einzeln ausgedruckt werden soll.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nDas SVG-Format sollte gewählt werden, wenn das Diagramme grossformtig oder in hoher Qualität auf Web-Seiten veröffentlicht werden soll.\n\n\n\n\n\nAbbildung 16.6: Auswahl zum Speichern eines Diagramms"
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html#diagrammtypen",
    "href": "kapitel/daten-visualisieren/kapitel.html#diagrammtypen",
    "title": "16  Daten visualisieren",
    "section": "16.2 Diagrammtypen",
    "text": "16.2 Diagrammtypen\nAlle Excel Diagramme visualisieren Werte vom Datentyp Zahl. Um andere Datentypen zu visualisieren, müssen diese zuerst in Zahlen kodiert werden.\n\n16.2.1 Balkendiagramme\nExcel unterscheidet zwischen Balken- oder Säulendiagrammen. Technisch unterscheiden sich die beiden Diagrammtype nur durch die Orientierung der Balken. Im Folgenden werden beide Diagrammtypen als Balkendiagramme bezeichnet.\n\n\n\n\n\n\nMerke\n\n\n\nFür ein Balkendiagramm entspricht ein Wert einem Balken und der Wert bestimmt dessen Grösse.\n\n\n\n\n\n\n\n\nMerke\n\n\n\nFür Balkendiagramme mit zwei oder mehr Gruppen, müssen die Daten in der Breitform vorliegen.\n\n\nExcel bietet zwei spezielle Formen von Balkendiagrammen: Trichterdiagramme und Wasserfall-Diagramme. Beide Diagramme sind eindimensional.\nTrichterdiagramme stellen die Balken horizontal zentriert dar, wobei nur positive Werte zulässig sind. Deshalb haben Excels Trichterdiagramme keine Beschriftung der X-Achse (Abbildung 16.7).\n\n\n\n\n\n\nMerke\n\n\n\nTrichterdiagramme unterscheiden sich von anderen Balkendiagrammen nur in der Anordnung der Balken.\n\n\n\n\n\nAbbildung 16.7: Trichterdiagramm mit fünf Werten\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nWeil Trichterdiagrammen keine beschriftete X-Achse haben und die Anordnung der Balken schwerer zu dekodieren ist, sollten diese Diagramme nicht verwendet werden.\n\n\nWasserfalldiagramme stellen die Balken so dar als Folge dar. Diese Diagramme stellen positive und negative Werte gerichtet nebeneinander. Der Start des von links nach rechts gelesenene nächste Balken beginnt bei dem Wert, an dem der vorherige Balken endete. Bei positiven Werten befindet sich der Endpunkt über dem Startpunkt, bei negativen Werten darunter (Abbildung 16.8).\n\n\n\nAbbildung 16.8: Wasserfalldiagramm mit Leserichtungen\n\n\n\n\n\n\n\n\nMerke\n\n\n\nWasserfalldiagramme werden zur Visualisierung von Veränderungen über die Zeit verwendet.\n\n\nBei Wasserfalldiagrammen kann die Beschriftung der X-Achse über ein zweite Datenspalte mitgegeben werden. Bei Trichterdiagrammen können auf die gleiche Weise die Beschriftungen der Y-Achse angepasst werden. In beiden Fällen müssen die Beschriftungen in der Spalte vor den Werten gespeichert sein.\n\n\n16.2.2 Histogramm\nEin Histogramm ist in Excel immer ein eindimensionales Balkendiagramm. Werden Werte aus mehreren Spalten übergeben, dann werden alle Werte im Histogramm abgebildet.\n\n\n\n\n\n\nPraxis\n\n\n\nFür Daten mit diskreten Wertebereichen, sind Balkendiagramme immer einem Histogramm vorzuziehen.\n\n\n\n\n16.2.3 Boxplot\n\n\n16.2.4 Punktdiagramm\n\n\n16.2.5 Blasendiagramm\nBlasendiagramme ähneln Punktdiagrammen. Weil drei Merkmale kodiert werden, müssen die Daten in drei Spalten vorliegen. Dabei wird die linke Spalte für die X-Achse verwendet. Die mittlere Spalte wird für die Y-Achse verwendet. Die rechte Spalte enthält die Werte für die Grösse der Punkte. Prinzipiell lassen sich die Werte nachträglich noch umorganisieren, oft ist es aber einfacher, die Spalten vorher anzuordnen.\n\n\n\nAbbildung 16.9: Beispiel eines Blasendiagramms\n\n\nEine Datenreihe eines Blasendiagramms besteht aus drei Merkmalen.\n\n\n\nAbbildung 16.10: Konfiguration der Datenreihen eines Blasendiagramms\n\n\n\n\n16.2.6 Linien-, Kreis- und Donutdiagramme\nLinien-, Kreis- und Donutdiagramme sind in Excel Varianten von Balkendiagrammen: Sie verwenden das gleiche Format für die Datenreihen und werden ansonsten gleich konfiguriert. Wie bei Balkendiagrammen, wird die X-Achse als eine diskrete Datenskalierung behandelt. Die Daten können also nominal- oder ordinalskaliert sein.\n\n\n\n\n\n\nPraxis\n\n\n\nKreis- und Donutdiagramme sind identisch mit Balkendiagrammen, wenn alle Werte positiv sind. Für mehr als drei Werte können die meisten Menschen sich diese Diagramme oft nicht richtig interpretieren. Deshalb sollten Kreis- und Donutdiagramme möglichst nur zur Darstellung (extremer) Mengenverhältinisse verwendet werden. Grundsätzlich ist ein Balkendiagramm einem Kreis- oder Donutdiagramm vorzuziehen. (s. Abbildung 16.11 und Abbildung 16.12)\n\n\n\n\n\nAbbildung 16.11: Kreisdiagramm mit ähnlich grossen Werten\n\n\n\n\n\nAbbildung 16.12: Balkendiagramm für die gleichen Werte aus Abbildung 16.11\n\n\nExcels Liniendiagramme zeichnen für jeden Wert auf der Y-Achse einen Punkt und verbinden die Punkte mit geraden Linien.\n\n\n\n\n\n\nAchtung\n\n\n\nWeil die X-Achse immer diskrete Daten abbildet, dürfen Liniendiagramme nicht mit Punktdiagrammen mit interpolierten Linien verwechselt werden.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nExcels Liniendiagramme sollten nur für sog. Paralleldiagramme verwendet werden, in denen mehrere diskrete Merkmale mit dem gleichen Wertebereich gegenübergestellt werden. Durch die Linien werden Unterschiede in den Ausprägungsprofilen sichtbar.\nAbbildung 16.13 zeigt ein solches Paralleldiagramm. Dieses Beispiel macht die Grenzen dieses Diagrammtyps sichbar, weil Excel sich überlagernde Linien nicht nebeneinander darstellen kann.\n\n\n\n\n\nAbbildung 16.13: Anwendung eines Liniendiagramms als Paralleldiagramm"
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html#mathematische-funktionen-visualisieren",
    "href": "kapitel/daten-visualisieren/kapitel.html#mathematische-funktionen-visualisieren",
    "title": "16  Daten visualisieren",
    "section": "16.3 Mathematische Funktionen visualisieren",
    "text": "16.3 Mathematische Funktionen visualisieren"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referenzen",
    "section": "",
    "text": "Fisher, N. I., & Kordupleski, R. E. (2019). Good and bad market\nresearch: A critical review of net promoter score. Applied\nStochastic Models in Business and Industry, 35(1),\n138–151. https://doi.org/10.1002/asmb.2417\n\n\nGrisaffe, D. B. (2007). Questions about the ultimate question:\nConceptual considerations in evaluating reichheld’s net promoter score\n(NPS). 20.\n\n\nKeiningham, T. L., Cooil, B., Andreassen, T. W., & Aksoy, L. (2007).\nA longitudinal examination of net promoter and firm revenue growth.\nJournal of Marketing, 71(3), 39–51. https://doi.org/10.1509/jmkg.71.3.039\n\n\nMicrosoft Support. (2023a). Excel specifications and limits. https://support.microsoft.com/en-gb/office/excel-specifications-and-limits-1672b34d-7043-467e-8e27-269d656771c3\n\n\nMicrosoft Support. (2023b). Using structured references with excel\ntables. https://support.microsoft.com/en-gb/office/using-structured-references-with-excel-tables-f5ed2452-2337-4f71-bed3-c8ae6d2b276e\n\n\nReichheld, F. F. (2003). The one number you need to grow. Harvard\nBusiness Review."
  }
]