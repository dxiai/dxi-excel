[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Einführung in die Datenwissenschaft mit Excel",
    "section": "",
    "text": "Vorwort\nWork in Progress\n\n\nCopyright\nDieses Werk ist lizenziert unter einer Creative Commons Namensnennung - Nicht-kommerziell - Weitergabe unter gleichen Bedingungen 4.0 International Lizenz (CC-BY-NC-SA). Details zur Nutzungsbedingungen und dem Copyright finden sich unter createivecommons.org.\n2023-2024, Christian Glahn, Zurich, Switzerland",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "kapitel/einleitung/kapitel.html",
    "href": "kapitel/einleitung/kapitel.html",
    "title": "1  Einleitung",
    "section": "",
    "text": "1.1 Ziele",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "kapitel/einleitung/kapitel.html#ziele",
    "href": "kapitel/einleitung/kapitel.html#ziele",
    "title": "1  Einleitung",
    "section": "",
    "text": "Abbildung 1.1: Ziele und Themen",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "kapitel/einleitung/kapitel.html#organisation-dieses-buchs",
    "href": "kapitel/einleitung/kapitel.html#organisation-dieses-buchs",
    "title": "1  Einleitung",
    "section": "1.2 Organisation dieses Buchs",
    "text": "1.2 Organisation dieses Buchs",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "kapitel/einleitung/excel-versionen.html",
    "href": "kapitel/einleitung/excel-versionen.html",
    "title": "2  Excel Versionen",
    "section": "",
    "text": "2.1 Excel-Versionen und Betriebssysteme\nExcel ist die Tabellenkalkulation der Microsoft Office Umgebung. Die erste Version wurde 1985 veröffentlicht und wird seitdem ständig weiterentwickelt. Aktuell existieren mehrere Versionen von Excel nebeneinander.\nDie verschiedenen Versionen unterscheiden sich in der Funktionalität.\nDie aktuelle Version ist Excel365 und muss auf einem Desktop-Computer oder Laptop installiert werden. Diese Version ist Teil des Microsoft365 Abonnements. Diese Version wird kontinuierlich weiterentwickelt und erhält regelmässig neue Funktionen, welche die Arbeit erleichtern.\nTeil des Microsoft365 Abonnements sind die Web- und die Mobilversionen von Excel. Beide Versionen sind in der Funktion leicht eingeschränkte Versionen von Excel365. Die Mobilversion ist für die Arbeit auf einem Smartphone oder Tablet optimiert. Die Web-Version benötigt einen Web-Browser und kann auf jedem Gerät mit Internetzugang verwendet werden. Der Unterschied zwischen Excel365 und den wird immer kleiner und die meisten Konzepte in diese Buch lassen sich auch in Excel im Web umsetzen.\nExcel’s Desktop Version ohne Abonnement wurde auf dem Stand von Juni 2019 eingefroren. Diese Version wird nur noch mit Sicherheitsupdates versorgt. Neue Funktionen sind in dieser Version nicht verfügbar. Diese Version ist noch recht weit verbreitet und lässt sich nur schwer von der aktuellen Version unterscheiden, denn tatsächlich handelt es sich bei Excel365 und der Desktop-Version ohne Abonnement um die selbe Anwendung. Fehlt das Abonnement, dann sind die neuen Funktionen nicht verfügbar und werden nicht angezeigt oder ausgeführt. Falls diese Version aktiv ist und eine Arbeitsmappe, die mit einer Version mit Abonnement erstellt wurde, öffnet, dann erfolgt eine Fehlermeldung und die entsprechenden Funktionen werden blockiert.\nDieses Buch setzt die aktuelle Version von Excel365 voraus. In den folgenden Kapiteln ist also immer Excel365 gemeint, wenn schlicht von Excel geschrieben wird. Die meisten Beispiele und Konzepte lassen sich in der Desktop-Version ohne Abonnement nicht umsetzen. Viele Beispiele lassen sich mit der Web- oder Mobilversion nachvollziehen, diesen Versionen fehlt allerdings der Importer für Daten aus anderen Dateien, der in Kapitel 7 behandelt wird und für viele Beispiele Voraussetzung ist.\nExcel365 unterscheidet sich leicht für MacOS und Windows. Im Rahmen dieses Buchs stellt das keine Einschränkung dar, denn die Unterschiede sind gering.\nDie auffälligsten Unterschiede betreffen den Importer und die bedingte Formatierung.",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Excel Versionen</span>"
    ]
  },
  {
    "objectID": "kapitel/einleitung/excel-versionen.html#excel-versionen-und-betriebssysteme",
    "href": "kapitel/einleitung/excel-versionen.html#excel-versionen-und-betriebssysteme",
    "title": "2  Excel Versionen",
    "section": "",
    "text": "Der Importer ist unter Windows etwas flexibler gestaltet als unter MacOS. Dieser Unterschied betrifft den Inhalt dieses Buchs nicht.\nDie bedingte Formatierung wird unter MacOS traditionell mit einen völlig anderen Dialog konfiguriert wird als unter Windows.\n\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nIn den (wenigen) Fällen, in denen sich die Excel-Versionen auf den beiden Betriebssystemen unterscheiden, wird der Unterschied durch eine MacOS vs. Windows-Box - wie diese hier - gesondert hervorgehoben. Das gleiche gilt für die Eigenheiten, die nur auf einem der beiden Betriebssyeme vorkommen.\n\n\n\n\n\n\n\n\nMacOS\n\n\n\nSoll unter MacOS Excel365 eine alte Version ohne Abonnement ersetzen, dann muss die alte Version zuerst deinstalliert werden. Sind zusätzlich andere Office-Programme von Microsoft ohne Abonnement installiert, dann müssen diese ebenfalls deinstalliert werden. Beim Deinstallieren werden die Konfigurationsdateien nicht gelöscht. Diese müssen manuell gelöscht werden. Erst jetzt kann die neue Version von Microsoft365 installiert werden.",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Excel Versionen</span>"
    ]
  },
  {
    "objectID": "kapitel/einleitung/excel-versionen.html#excel-und-sprachen",
    "href": "kapitel/einleitung/excel-versionen.html#excel-und-sprachen",
    "title": "2  Excel Versionen",
    "section": "2.2 Excel und Sprachen",
    "text": "2.2 Excel und Sprachen\nExcel365 ist in vielen Sprachen verfügbar. Die Sprache wird von Excel vom Betriebssystem übernommen. Dieses Buch bezieht sich auf die deutschsprachige Excel Version mit Schweizer Regionseinstellungen. Alle Beispiele lassen sich in allen anderen Sprachen nachvollziehen, wenn die Werte und Funktionsnamen entsprechend angepasst werden.\n\n\n\n\n\n\nWarnung\n\n\n\nDie Funktionsnamen unterscheiden sich stark zwischen den einzelnen Sprachen. Oft ist es unmöglich, die Funktionsnamen durch eine Übersetzung des Funktionsnamen aus einer anderen Sprache abzuleiten.\nBeispielsweise heisst der englische Funktionsname OFFSET() (deutsch: Versatz) auf Deutsch BEREICH.VERSCHIEBEN() (engl. move range).\n\n\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nUnter MacOS kann die Sprache von Excel365 ausschliesslich über die Systemeinstellungen geändert werden. Die Spracheinstellung wird vom Betriebssystem übernommen. Dadurch verändert sich die Sprache aller Programme, die auf dem Computer installiert sind. Wird die Sprache von MacOS geändert, dann muss der Computer neu gestartet werden, damit die Änderung wirksam wird. Dieser Schritt verändert jedoch nicht nur die Sprache von Menus sondern auch die Namen vieler Verzeichnisse. Deshalb wird dieser Schritt nicht empfohlen.\nUnter Windows kann die Sprache nur für Excel365 geändert werden. Dazu muss in Excel unter Datei &gt; Optionen &gt; Sprache geändert werden. Die gewünschte Sprache muss unter Office-Anwendungssprache als bevorzugt markiert werden. Die Änderung wird erst wirksam, nachdem Excel beendet und neu gestartet wurde.\n\n\nDie Spracheinstellung haben keinen Einfluss auf die Funktion von Excel. Die Spracheinstellung bestimmt nur die Sprache der Benutzeroberfläche. Zur Benutzeroberfläche gehören die Menüs, die Dialoge, die Hilfetexte und die Funktionsnamen. Wird eine Arbeitsmappe in einer Excel mit einer anderen Spracheinstellung geöffnet, dann werden die Funktionsnamen automatisch übersetzt. Es ist jedoch unmöglich die Funktionsnamen in der ursprünglichen Sprache der Arbeitsmappe einzugeben.",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Excel Versionen</span>"
    ]
  },
  {
    "objectID": "kapitel/einleitung/02_oberflaeche.html",
    "href": "kapitel/einleitung/02_oberflaeche.html",
    "title": "3  Bedienoberfläche",
    "section": "",
    "text": "3.1 Arbeitsblätter\nDer Tabellenbereich ist das zentrale Element von Excels Arbeitsoberfläche. Dabei handelt es sich um den Datenbereich, der sich deutlich durch das beschriftete Gitterraster im Zentrum des Excel-Fensters abhebt und den Grossteil der Arbeitsoberfläche einnimmt. Über dieses Raster wird primär mit Daten und Funktionen interagiert. Der Tabellenbereich zeigt einen Ausschnitt des aktuellen Arbeitsblatts.\nExcel zeigt durch eine Hervorhebung an, welche Zelle aktuell markiert ist. Diese Markierung kann mit der Maus oder mit den Pfeiltasten bewegt werden. Wenn nur eine Zelle markiert ist, dann entspricht die Markierung der aktiven Zelle. Eine Markierung kann auch mehrere Zellen umfassen. In diesem Fall wird die aktive Zelle durch eine helle Hervorhebung gekennzeichnet, während der Rest der Markierung ausgegraut ist. Alle Eingaben mit der Tastatur beziehen sich immer auf die aktive Zelle.\nOben und Links vom Tabellenbereich findet sich die Beschriftung für die Spalten und Zeilen. Spalten werden mit Buchstaben benannt, Zeilen werden mit Zahlen benannt. Daraus ergibt sich ein Koordinatensystem, mit dem jede Zelle eindeutig adressiert wird.\nIm Abschnitt 6.4 werden die verschiedenen Arten der Adressierung von Zellen und Zellbereichen detailliert beschrieben.",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bedienoberfläche</span>"
    ]
  },
  {
    "objectID": "kapitel/einleitung/02_oberflaeche.html#arbeitsblätter",
    "href": "kapitel/einleitung/02_oberflaeche.html#arbeitsblätter",
    "title": "3  Bedienoberfläche",
    "section": "",
    "text": "Abbildung 3.1: Das Excel Arbeitsfenster\n\n\n\n\nDefinition 3.1 Ein Excel Arbeitsblatt ist ein Gitterraster, das aus Zellen besteht. Jede Zelle kann einen Wert enthalten.\n\n\nDefinition 3.2 Eine Zelle ist ein Feld im Raster eines Arbeitsblatt.\n\n\n\n\nDefinition 3.3 Die Koordinaten einer Zelle sind in der Zelladresse kodiert.",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bedienoberfläche</span>"
    ]
  },
  {
    "objectID": "kapitel/einleitung/02_oberflaeche.html#arbeitsblattreiter",
    "href": "kapitel/einleitung/02_oberflaeche.html#arbeitsblattreiter",
    "title": "3  Bedienoberfläche",
    "section": "3.2 Arbeitsblattreiter",
    "text": "3.2 Arbeitsblattreiter\nDirekt unter dem Tabellenbereich zeigt Excel Register mit den Namen der Arbeitsblätter. Diese Register zeigen alle Arbeitsblätter einer Excel-Arbeitsmappe. Wenn eine neue, leere Arbeitsmappe erstellt wird, dann enthält diese nur ein Arbeitsblatt mit dem Namen Tabelle 1. Mit dem Plus-Symbol neben dem Arbeitsblattregistern können zusätzliche Arbeitsblätter in der Arbeitsmappe erzeugt werden.",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bedienoberfläche</span>"
    ]
  },
  {
    "objectID": "kapitel/einleitung/02_oberflaeche.html#menübalken",
    "href": "kapitel/einleitung/02_oberflaeche.html#menübalken",
    "title": "3  Bedienoberfläche",
    "section": "3.3 Menübalken",
    "text": "3.3 Menübalken\n\n\n\n\n\n\nAbbildung 3.2: Menubalken\n\n\n\nAm oberen Fensterrand von Excel befindet sich der Menübalken, der im Excel Jargon “Ribbon” heisst. Der Menübalken ist in verschiedene Kategorien unterteilt und sortiert so die verschiedenen interaktiven Kommandos von Excel.\n\nDefinition 3.4 Ein Kommando ist eine interaktive Anweisung an Excel, eine bestimmte Aktion auszuführen.\n\nKommandos werden immer interaktiv ausgelöst und lassen sich meist nicht durch Excel-Funktionen ersetzen.\nFür die tägliche Arbeit sind die folgenden Kategorien des Menübalkens am wichtigsten:\n\nStart\nEinfügen\nFormeln\nDaten\nTabelle",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bedienoberfläche</span>"
    ]
  },
  {
    "objectID": "kapitel/einleitung/02_oberflaeche.html#funktionsleiste",
    "href": "kapitel/einleitung/02_oberflaeche.html#funktionsleiste",
    "title": "3  Bedienoberfläche",
    "section": "3.4 Funktionsleiste",
    "text": "3.4 Funktionsleiste\nDie Funktionsleiste unterstützt die Arbeit mit der aktiven Zelle. Die Funktionsleiste wird verwendet, wenn mit speziellen Werten oder mit Komplexen Formeln gearbetiet wird.\n\n\n\n\n\n\nAbbildung 3.3: Die Excel Funktionsleiste\n\n\n\nDie Funktionsleiste hat 6 Bedienfelder.\nGanz links ist das Adressfeld. Das Adressfeld zeigt uns immer die Adresse der aktiven Zelle an. Wenn wir dieses Feld anklicken, dann können wir eine andere Adresse eintragen. In diesem Fall springt die Markierung für die aktive Zelle an die entsprechende Adresse.\nDaneben befinden sich zwei unscheinbare Dreiecke. Dieses Bedienfeld verbirgt eine Liste der benannten Bereiche in der aktuellen Arbeitsmappe. Bei einer leeren Arbeitsmappe ist diese Liste leer.\nDie nächsten vier Bedienfelder gehören zusammen.\nGanz rechts wird der Inhalt der aktuellen Zelle angezeigt. Bei einer leeren Tabelle ist dieser Bereich selbstverständlich leer. Wenn dieser Bereich mit der Maus ausgewählt wird, dann erscheint ein senkrechter, blinkender Strick, der signalisiert, dass Werte oder Formeln eingegeben werden können. Wenn nun etwas eingegeben wird, dann erscheint diese Eingabe auch in der aktiven Zelle.\nIst die Eingabe abgeschlossen, dann kann diese mit dem grünen Haken oder mit der Eingabetaste bestätigt werden.\nIst bei der Eingabe ein Fehler passiert, dann lässt sich die Eingabe mit einem Mausklick auf das rote X oder mit der ESC-Taste abbrechen. Die Eingabe wird dann auf den ursprünglichen Zustand zurückgesetzt.\nWird die aktive Zelle nicht bearbeitet, dann sind der Hacken und das X ausgegraut und können nicht verwendet werden.\nDirekt neben dem Eingabefeld mit dem Inhalt der aktiven Zelle ist das Bedienfeld für den Formelgenerator. Der Formelgenerator ist ein Hilfsdialog, der die Suche nach geeigneten Formeln unterstützt. Der Formelgenerator unterscheidet sich von Menübalken Formeln durch eine kurze Erklärung über die Arbeitsweise einer ausgewählten Funktion.",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bedienoberfläche</span>"
    ]
  },
  {
    "objectID": "kapitel/einleitung/02_oberflaeche.html#statusleiste",
    "href": "kapitel/einleitung/02_oberflaeche.html#statusleiste",
    "title": "3  Bedienoberfläche",
    "section": "3.5 Statusleiste",
    "text": "3.5 Statusleiste\nAm unteren Rand von Excels Anwendungsfenster findet sich die Statusleiste. Die Statusleiste hat drei zentrale Funktionen:\n\nZoom der Tabellenanzeige,\nStatus von Excel und Fehlermeldungen und\nSchnellauswertung eines Zellbereichs.\n\n\n3.5.1 Zoom der Tabellenanzeige\nDer aktuelle Zoom der Arbeitsmappe und die Zoom-Einstellung finden sich ganz rechts in der Statusleiste. Dabei wird der aktuelle Zoom als ein Prozentwert dargestellt. Über den “Schieberegler” links daneben lässt sich der Zoom anpassen.\nWenn der Zoom-Wert angeklickt wird, dann erscheint ein kleiner Dialog, über den Zoom-Wert als Prozentzahl direkt eingegeben kann. Das ist praktisch, wenn für eine Präsentation oder zum Arbeiten ein bestimmter Zoom-Wert bevorzugt wird.\n\n\n\n\n\n\nAchtung\n\n\n\nDie Zoom-Einstellung muss für jedes Arbeitsblatt separat eingestellt werden und wird beim nächsten Speichern zusammen mit der Arbeitsmappe gesichert.\n\n\n\n\n3.5.2 Status und Fehlermeldungen\nAuf der linken Seite der Statusleiste ist der Status Bereich. Normalerweise wird an dieser Stelle den Wert Bereit angezeigt. Wenn eine Zelle bearbeitet wird, dann erscheint der Status Eingeben oder Zeigen.\nWenn einen Fehler bei der Eingabe einer Formel auftritt, dann wird neben dem Status eine Fehlermeldung eingeblendet. Diese unscheinbare Fehlermeldung wird immer dann wichtig, wenn eine Formel oder ein Algorithmus nicht zu rechnen scheint. In solchen Fällen hilft ein Blick auf den linken Rand der Statusleiste bei der Fehlersuche. Bei Fehlern zeit die Statusleiste einen Hinweis auf den Fehler sowie die Adresse der Zelle, an der Excel den Fehler vermutet.\nTritt ein Fehler auf, dann bricht Excel die Berechnung der gesamten Arbeitsmappe sofort ab und ignoriert alle Formeln, die nach der fehlerhaften Zelle berechnet werden müssten, selbst wenn die Formeln unabhängig voneinander wären. Damit Excel wieder arbeitet, müssen zuerst alle Fehler behoben werden.\n\n\n3.5.3 Schnellauswertung eines Zellenbereichs\nIm mittleren Bereich der Statusleiste ist normalerweise leer. Hier versteckt sich eine sehr nützliche Funktion zur schnellen Zusammenfassung der Werte in einem Bereich: Werden mehrere Zellen markiert, dann zeigt Excel den Mittelwert, die Summe und die Anzahl der ausgewählten Zellen an.\n\n\n3.5.4 Anpassen der Statusleiste\nWenn Sie mit der rechten Maustaste (Win) bzw. mit Control-Klick (Mac) auf die Statusleiste klicken, dann erhalten Sie eine Auswahlliste der Funktionen, die in der Statusleiste angezeigt werden sollen.\nSo lassen sich zusätzliche Funktionen in der Statusleiste aktivieren oder störende Elemente deaktivieren.\n\n\n\n\n\n\nWarnung\n\n\n\nDiese Einstellungen beziehen sich ausschliesslich auf die Excel-Installation und werden nicht zusammen mit der Arbeitsmappe gespeichert!",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bedienoberfläche</span>"
    ]
  },
  {
    "objectID": "kapitel/einleitung/01_jargon.html",
    "href": "kapitel/einleitung/01_jargon.html",
    "title": "4  Excel Jargon",
    "section": "",
    "text": "Arbeitsmappe: Bezeichnet eine Excel-Datei.\nArbeitsblatt: Als Arbeitsblatt wird in der Regel eine Tabelle in einer Excel-Arbeitsmappe bezeichnet.\nAdresse: Koordinaten einer Zelle oder eines Bereichs auf einem Arbeitsblatt.\nAktive Zelle: Die Zelle, die für das Bearbeiten ausgewählt ist. Ist nur eine Zelle markiert, dann entspricht die aktive Zelle der Markierung. Ist ein Bereich markiert, dann ist die aktive Zelle, die weiss hervorgehobene Zelle.\nBereich: Eine Auswahl von Zellen auf dem gleichen Arbeitsblatt.\ndynamischer Bereich oder dynamisches Feld oder dynamisches Array: Ein Bereich mit Werten, der durch eine Formel erzeugt wird.\nBezug: Adresse eines Bereichs, um den Wert bzw. die Werte an der Adresse zu erhalten.\nExterne Daten: Tabellen, die aus einer anderen Datei oder einer Datenbank eingebunden wurden.\nFormel: Aufruf von Funktionen in einer Zelle.\nFunktion: Bestandteil einer Formel. Funktionen werden über Parameter gesteuert.\nKommando: Ein Kommando ist eine Interaktion, mit der Excel eine Aktion auslöst. Aktionen ähneln Funktionen, können aber nicht als Formel ausgedrückt werden.\nParameter: Wert, der an eine Funktion übergeben wird. Ein Parameter kann direkt als Wert, indirekt als Adresse oder als Ergebnis einer anderen Funktion übergeben werden.\nPivot-Tabelle: Eine Kreuztabelle, mit der Daten aus mehreren Spalten eines Arbeitsblatts zusammengefasst werden können. Eine Pivot-Tabelle kann Daten von mehreren Arbeitsblättern und Tabellen zusammenfassen.\nRibbon: Menüleiste von Excel.\nTabelle: Eine Tabelle ist eine zwei-dimensionale Datenstruktur für strukturierte Daten. Eine Tabelle besteht aus Spalten und Zeilen.\nZelle: Ein Feld in einer Tabelle. Eine Zelle besteht immer aus einem Werteanteil und einem Formelanteil. Normalerweise wird der Werteanteil angezeigt.",
    "crumbs": [
      "Ausgangslage und Vorbereitung",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Excel Jargon</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-sammeln/kapitel.html",
    "href": "kapitel/daten-sammeln/kapitel.html",
    "title": "5  Daten sammeln",
    "section": "",
    "text": "5.1 Daten mit Formularen sammeln\nDie direkte Eingabe von Daten ist nur für kleine Datensätze mit wenigen Merkmalen geeignet. Bei grösseren Datensätzen ist die direkte Eingabe oft zu aufwändig und fehleranfällig. Für die strukturierte Dateneingabe von grösseren Datensätzen werden Formulare verwendet.\nBei der Dateneingabe über Formulare werden die Daten mithilfe von Fragen mit vorgegebenen Antworttypen gesammelt. Der Antworttyp bestimmt, welche Werte für die Frage zulässig sind.\nDurch das Festlegen des Antworttyps wird gleichzeitig der Wertebereich des gemessenen Merkmals definiert. Dadurch ergibt sich beim Erstellen eines Formulars das Datenschema automatisch.\nExcel hat kein eigenes Formularsystem. Stattdessen kann Microsoft Forms verwendet werden. Microsoft Forms ist ein Online-Formulardienst, der in Microsoft365 integriert ist. Forms sammelt die Eingaben mit einem Formular und speichert die Daten in einer Excel Arbeitsmappe. Diese Formulare können über einen Web-Link geteilt werden und im Web-Browser ausgefüllt werden. Dadurch kann das Datensammeln auf verschiedene Personen verteilt werden.\nMicrosoft Forms unterstützt die folgenden Antworttypen:\nJede dieser Varianten hat die folgenden gemeinsamen Optionen:\nDie Unterschiede ergeben sich in den Antwortmöglichkeiten.",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Daten sammeln</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-sammeln/kapitel.html#sec-datacollection-forms",
    "href": "kapitel/daten-sammeln/kapitel.html#sec-datacollection-forms",
    "title": "5  Daten sammeln",
    "section": "",
    "text": "Hinweis\n\n\n\nIn vielen Formularsystemen wird der Antworttyp als Fragetyp bezeichnet, obwohl die Frage immer in Text-Bildform präsentiert wird und der Typ durch die unterschiedlichen Antwortmöglichkeiten bestimmt wird.\n\n\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nEin Formular kann in Microsoft Forms ein Quiz oder ein Formular sein. Ein Quiz ist ein Formular, bei dem die Antworten mit einer Punktzahl bewertet werden und ein Feedback erhalten können. Ein Formular fokussiert sich auf die reine Dateneingabe.\n\n\n\n\nOffene Antworttypen\n\nOffene Texteingabe\nDatumseingabe\nDatei hochladen\n\nGeschlossene Antworttypen\n\nEinfachauswahl\nMehrfachauswahl\nRangfolge\nLikert-Skala\nBewertung\nNet Promoter Score\n\n\n\n\n\n\n\n\nAbbildung 5.1: MS Forms Fragetypmenu\n\n\n\n\n\nEine einleitende Frage oder Anweisung.\nEin optionaler Untertitel oder eine Beschreibung. (Untertitel)\nDie Möglichkeit eine mathematische Formel zur Validierung des Wertebereichs anzugeben (Mathematik).\nDas erzwingen einer Antwort (Erforderlich).\nEine Verzweigung zu einer anderen Frage, wenn eine bestimmte Antwort gegeben wird (Verzweigung).\n\n\n\n5.1.1 Offene Texteingabe (Text)\nDie offene Texteingabe erlaubt einzeilige und mehrzeilige (lange) offene Antworten möglich sind. Damit können un- oder semistrukturierte Daten erfasst werden. Diese Antwortmöglichkeit lässt sich auf Zahlenwerte und Zahlenintervalle einschränken.\n\n\n5.1.2 Datumseingabe (Datum)\nDiese Eingabe ist eine Variante der offenen Texteingabe zur Eingabe eines Datums. Diese Eingabe wird durch die Option ergänzt, das Datum über eine Kalenderdarstellung auszuwählen.\nDas eingegebene Datum wird als Zahl gespeichert und als Datum dargestellt.\n\n\n5.1.3 Datei hochladen\nDie zweite Variante für offene Antworten ist das Hochladen von Dateien. Mit diesem Antworttyp lassen sich Bilder, Videos oder Tonaufnahmen leicht erfassen.\n\n\n5.1.4 Einfachauswahl (Auswahl)\nDie Einfachauswahl ist ein Single-Choice-Antworttyp. Es sind nur die vorgegebenen Antwortmöglichkeiten möglich, von denen nur eine ausgewählt werden kann. Die Antwortmöglichkeiten können als Text oder als Bild angegeben werden. Die Antwortmöglichkeiten werden immer in einer Liste angezeigt. Dabei kann zwischen einem Auswahlmenu als Dropdown-Liste und frei anwählbaren Antwortmöglichkeiten (Optionen) gewählt werden.\nDie Reihenfolge der Antwortmöglichkeiten kann durch die Option Optionen in zufälliger Reihenfolge für jedes Formular zufällig angeordnet werden. Diese Option ist sinnvoll, wenn die Reihenfolge der Antwortmöglichkeiten die Antwort beeinflussen könnte. Soll ein Formular mehrfach durch die gleichen Personen ausgefüllt werden, dann sollte diese Option nicht aktiviert werden.\nDas Ergebnis der Einfachauswahl ist eine Zeichenkette der ausgewählten Option.\n\n\n5.1.5 Mehrfachauswahl (Auswahl)\nDie Mehrfachauswahl erlaubt die Auswahl mehrerer Antwortmöglichkeiten, indem die Option Mehrere Antworten aktiviert wird. Dieser Antworttyp ist ansonsten identisch mit der Einfachauswahl.\nDas Ergebnis der Mehrfachauswahl ist eine Zeichenkette mit den ausgewählten Optionen. Wurden mehrere Antworten ausgewählt, dann werden die Optionen durch ein Semikolon getrennt.\n\n\n5.1.6 Rangfolge\nDie Rangfolge erlaubt es, dass die angebotenen Antwortmöglichkeiten in eine Reihenfolge gebracht werden können. Bei diesem Antworttyp müssen die Werte sortiert werden und die Sortierung wird als Antwort gespeichert.\nBei der Darstellung werden die Antwortmöglichkeiten in einer Liste angezeigt und für jedes Formular neu sortiert.\nDas Ergebnis der Rangfolge ist eine Zeichenkette mit der Reihung der Optionen. Die Optionen werden durch ein Semikolon getrennt. Im Ergebnis lässt sich die Rangfolge nicht von einer Mehrfachauswahl unterscheiden.\n\n\n5.1.7 Likert-Skala (Likert)\nDer Antworttyp Likert setzt eine Fragebatterie mit Likert-Skalen um. Darüber lässt sich ein semantisches Differential erheben.\nDie Anworten dieser Fragebatterie werden wie mehrere Einfachauswahlen als Zeichenketten gespeichert. Deshalb muss für diesen Antworttyp immer eine Kodierungstabelle für die richtige Reihenfolge der Werte dokumentiert werden.\n\n\n5.1.8 Bewertung\nDie Bewertung ist eine Variante des Antworttyps Likert-Skala. Mit der Bewertung wird über eine festgelegte Skala der gewünschte Wert abgefragt. Optional können für die beiden Extremwerte Beschriftungen angegeben werden.\nDas Ergebnis wird als Zahl gespeichert. Die Zahl entspricht dem Wert der ausgewählten Option beginnend bei 1.\n\n\n5.1.9 Net Promoter Score\nDer Typ Net Promoter Score ist eine spezielle elfstufige Liker-Skala, die zwischen zwei frei wählbaren Extremwerten festgelegt ist. Die offiziell als Net Promoter Score (Reichheld, 2003) bezeichnete Eingabeform ist eine verzerrte Likert-Skala mit dem Mittelpunkt bei 7.5.\nDer Net Promoter Score wird immer als Ganzzahl im Intervall 0 \\le s \\le 10 zurückgegeben.\n\n\n\n\n\n\nWarnung\n\n\n\nDer Net Promoter Score hat im Management-Umfeld eine grosse Verbreitung gefunden. Die Verwendung dieser Skala ist aber umstritten (Keiningham et al., 2007). Speziell die proklamierte Aussagekraft lässt sich nicht belegen (Fisher & Kordupleski, 2019; Grisaffe, 2007). Von der verbreiteten isolierten Verwendung des Net Promoter Score nach der Methode von Reichheld (2003) wird deshalb abgeraten.\nWird diese Eingabe als Likert-Skala verwendet, dann besteht ausser bei der Darstellung kein Unterschied zur Einfachauswahl oder der Bewertung.\n\n\n\n\n5.1.10 Darstellung der Ergebnisse in Excel\nDie Ergebnisse der Formulare werden in einer Excel-Arbeitsmappe als Tabelle gespeichert. Die Antworten sind in der Spalte ID sequenziell durchnummeriert. Zusätzlich enthält die Tabelle zwei sog. Zeitstempel mit Datum und Uhrzeit des Beginns (Startzeit) und des Endes (Fertigstellungszeit) der Datenerfassung eines Formulars. Optional können die Namen und E-Mail-Adressen der ausfüllenden Person miterfasst werden.\nNach diesen Basisinformation folgen die einzelnen Antworten für die Formularelemente. Die Werte in der gleichen Zeile entsprechen dabei den Werten aus dem gleichen Formular. Die Spaltenüberschriften sind Standardmässig der Fragetext.",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Daten sammeln</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-sammeln/kapitel.html#daten-direkt-eingeben",
    "href": "kapitel/daten-sammeln/kapitel.html#daten-direkt-eingeben",
    "title": "5  Daten sammeln",
    "section": "5.2 Daten direkt eingeben",
    "text": "5.2 Daten direkt eingeben\nBei der direkten Eingabe von Daten muss zuerst die Ergebnistabelle manuell erstellt werden, um damit die Daten zu sammeln.\nDamit die Daten einheitlich erfasst werden, benötigt die Tabelle ein Schema. In Excel wird diese Schema über die Tabellenüberschriften definiert und kann bei einer späteren Verarbeitung weiter angepasst werden (s. Kapitel 7).\nEin einfaches Datenschema umfasst nur die Spaltenüberschriften, die erfasst werden sollen. Dazu müssen die Tabellenüberschriften definiert werden. Die Tabellenüberschriften werden in der ersten Zeile der Tabelle eingetragen. Überschriften für weitere Merkmale können zu einem späteren Zeitpunkt noch ergänzt werden. Anschliessend werden die Überschriften markiert und es wird für diesen Bereich eine Tabelle eingefügt. Hierbei muss die Option Tabelle hat Überschriften aktiviert werden (s. Abbildung 5.2).\n\n\n\n\n\n\nAbbildung 5.2: Tabelle erstellen\n\n\n\nDaten werden der Tabelle hinzugefügt, indem in der Zeile unterhalb der Tabelle neue Werte eingetragen werden. Die Tabellenstruktur mit dem Schema wird automatisch erweitert.\n\n5.2.1 Schemadefinition durch Datenüberprüfung\nDie einfache Schemadefinition stellt nicht sicher, dass die Werte einheitlich abgelegt werden. Das kann später die Datenerfassung und die Datenverarbeitung behindern. Wurde die Datentabelle mit einem Überprüfungsschema erstellt, dann können die Werte in die Tabelle eingetragen und bei der Eingabe validiert werden.\nDie Schemadefinition durch Datenüberprüfung erlaubt die Wertebereiche der gemessenen Merkmale vorab festzulegen. Dadurch lassen sich potentielle Fehler bereits bei der Dateneingabe vermeiden. Hierzu ist es notwendig, die Wertebereiche und die zugehörige Datenklasse einer Spalte zu bestimmen.\n\n\n\n\n\n\nPraxis\n\n\n\nDas Erstellen eines Schemas zur Dateneingabe ist in Excel zwar aufwändig, dennoch sollte dieser Schritt nicht übersprungen werden, weil die Datenüberprüfung die Datenqualität verbessert und die Datenverarbeitung erheblich vereinfacht.\n\n\nIn Excel müssen Vektoren durch die Option Datenüberprüfung definiert werden. Die Option Datenüberprüfung findet sich im Ribbon unter Daten (s. Abbildung 5.3) im Abschnitt Datentools (s. Abbildung 5.4).\n\n\n\n\n\n\nAbbildung 5.3: Ribbon Datenüberprüfung\n\n\n\n\n\n\n\n\n\nAbbildung 5.4: Datentools Details\n\n\n\nDie Schemadefinition erfolgt in drei zusätzlichen Schritten:\n\nEs wird eine Platzhalterzeile eingefügt, indem die Zelle unterhalb der ersten Überschrift ausgewählt wird. Die Platzhalterzeile wird benötigt, um die Datenüberprüfung zu definieren.\nFür jeden Vektor wird mit der Option Datenüberprüfung eine Datenüberprüfung für den gewünschten Wertebereich definiert.\nDie Platzhalterzeile wird gelöscht.\n\n\n\n5.2.2 Funktionsweise der Datenüberprüfung\nDie Datenüberprüfung ist eine Funktion, die auf einen Bereich angewendet wird, wobei der Bereich eine einzelne Zelle, einer Zeile oder eine Spalte sein kann. Für das Schema einer Tabelle wird die Datenüberprüfung für eine Spalte eingerichtet.\nDie Datenüberprüfung wird Zellenweise konfiguriert, wobei die erste Zelle eines Bereichs die Referenzzelle ist. Die Datenüberprüfung wird auf die Referenzzelle angewendet und diese Konfiguration wird auf alle Zellen des Bereichs übertragen und automatisch so angepasst, dass die aktuelle Zelle überprüft wird. Dabei sind ein paar Besonderheiten zu beachten.\n\nDie Datenüberprüfung muss mit konstanten Adressen konfiguriert werden. Es muss also die doppelte Dollar-Adressierung (z.B. $A$2) verwendet werden.\nWird nicht die Referenzzelle als Adresse verwendet, dann erfolgt die Datenüberprüfung mithilfe der Werte der angegebenen Adresse. In den folgenden Zellen wird dann der relative Versatz zur Referenzzelle verwendet.\nKonstante Werte müssen in der Datenüberprüfung explizit angegeben und nicht über Bezüge verwiesen werden.\n\nExcel bringt einige vordefinierte Überprüfungen mit, die über die Dropdown-Liste ausgewählt werden können. Die meisten Überprüfungen sind für Zahlenintervalle definiert. Die Standardeinstellung Jeden Wert ist gleichbedeutend mit keiner Überprüfung, weil alle Werte als Eingabe akzeptiert werden. Generelle Überprüfungen von Datentypen sind nicht vorgegeben und müssen über die Option Benutzerdefiniert definiert werden.\n\n\n\n\n\n\nAbbildung 5.5: Dialog Datenüberprüfung mit allen Überprüfungsoptionen\n\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nWird die Datenüberprüfung auf eine Zelle in einer Tabelle angewendet und in der jeweiligen Spalte existieren noch keine anderen Werte, dann wird die Datenüberprüfung für die gesamte Spalte übernommen. Stehen in der Tabelle bereits Werte, dann müssen zuerst alle Werte in der Spalte ausgewählt werden, bevor die Datenüberprüfung eingerichtet wird. Neue Werte übernehmen die Datenüberprüfung der vorangehenden Zeile.\n\n\n\n\n5.2.3 Datenüberprüfung für Zahlen, Zeichenketten oder Wahrheitswerte\nEine generelle Überprüfung für die fundamentalen Datentypen ist in Excel nicht vorgesehen. Solche Überprüfungen müssen über die Option Benutzerdefiniert festgelegt werden.\nIm Eingabefeld Formel kann eine beliebig komplexe Formel stehen. Die Formel muss einen Wahrheitswert zurückgeben. Wird der Wahrheitswert WAHR zurückgegeben, dann wird der Wert akzeptiert. Wird der Wahrheitswert FALSCH zurückgegeben, dann wird der Wert nicht akzeptiert.\nUm die fundamentalen Datentypen zu überprüfen, können die Informationsfunktionen ISTZAHL(), ISTTEXT() und ISTLOG() verwendet werden (s. Tabelle 5.1). Diese Funktionen geben WAHR zurück, wenn der Wert dem angegebenen Datentyp entspricht. Ansonsten geben sie FALSCH zurück.\n\n\n\nTabelle 5.1: Überprüfungsausdrücke für die fundamentalen Datentypen\n\n\n\n\n\nDatentyp\nÜberprüfungsausdruck\n\n\n\n\nZahlen\n=ISTZAHL($A$2)\n\n\nZeichenketten\n=ISTTEXT($A$2)\n\n\nWahrheitswerte\n=ISTLOG($A$2)\n\n\n\n\n\n\n\n\n5.2.4 Datenüberprüfung für ganze Zahlen\nDie Überprüfung ganzer Zahlen ist in Excel über die Option Ganze Zahl möglich. Diese Option überprüft, ob der Wert eine ganze Zahl ist. Diese Option kann aber nicht direkt für alle ganze Zahlen eingesetzt werden. Um alle zulässigen ganzen Zahlen zu erfassen muss unter der Option Daten der Punkt größer als ausgewählt werden. Anschliessend muss als Minimum der Wert -9.99999999999999E+307 eingetragen werden (s. Abbildung 5.6). Dieser Wert ist der kleinste Wert, der in Excel als (ganze) Zahl erfasst werden kann (Microsoft Support, 2023).\n\n\n\n\n\n\nAbbildung 5.6: Dialog Datenüberprüfung für alle ganzen Zahlen\n\n\n\n\n\n5.2.5 Datenüberprüfung für ordinalskalierte Wertebereiche\nFür ordinalskalierte Wertebereiche sollten die Werte am Besten als Ganzzahlen erfasst werden. Damit zu einem späteren Zeitpunkt diese Zahlen den eigentlichen Werten zugeordnet werden können, wird eine Zuordnungstabelle benötigt. Diese Zuordnungstabelle wird in einer separaten Tabelle erstellt. Diese Tabelle besteht aus zwei Spalten: Dem Zahlenwert und dem zugeordneten Wert. Die Ordnung der Werte ergibt sich aus der Ordnung der zugeordneten Zahlen.\n\n\n\n\n\n\nWichtig\n\n\n\nHäufig muss bei ordinalskalierten Wertebereichen die Option einer nicht zutreffenden Antwort berücksichtigt werden. In diesem Fall muss eine zusätzlicher Zahlenwert ausserhalb der regulären Ordnung definiert werden. Dieser Wert wird dann der nicht zutreffenden Antwort (z.B. NA oder nicht zutreffend) zugeordnet.\n\n\nDamit der Wertebereich korrekt eingeschränkt wird, muss die Option Liste verwendet werden. Die Quelle entspricht der Spalte mit den zugeordneten Zahlenwerten in der Zuordnungstabelle. Die Option Zellendropdown kann deaktiviert werden.\n\n\n\n\n\n\nAchtung\n\n\n\nDie Datenüberprüfung kann nicht mit Tabellenadressen umgehen. Deshalb müssen die gültigen Werte als absolute Arbeitsblattadressen angegeben werden (s. Abbildung 5.7).\n\n\n\n\n\n\n\n\nAbbildung 5.7: Datenüberprüfung mit Zuordnungstabelle für ordinalskalierte Wertebereiche\n\n\n\n\n\n5.2.6 Datenüberprüfung für nominalskalierte Wertebereiche\nDie Überprüfung nominalskalierter Wertebereiche wird in Excel durch die Option Liste realisiert. Die Option Liste erlaubt die Auswahl von Werten aus einer Liste in der gleichen Arbeitsmappe. Diese Liste ist einfach ein Bereich mit Werten, eine Spalte in einer anderen Tabelle oder eine benannte Liste (s. Kapitel 8). Die Liste muss in einer Spalte definiert werden, weil die Datenüberprüfung nur auf Spalten angewendet werden kann. Deshalb ist es nicht möglich, eine zeilenorientierte Liste für die Datenüberprüfung anzuwenden.\nFür nominalskalierte Wertebereiche werden alle zulässigen Werte in einer Spalte festgelegt. Anschliessend wird im Dialog Datenüberprüfung unter Quelle der Bereich mit den zulässigen Werten angegeben.\n\n\n\n\n\n\nTipp\n\n\n\nIm Gegensatz zu ordinalskalierten Wertebereichen, sollten nominalskalierte Wertebereiche nicht als Zahlen kodiert werden, sondern als Zeichenketten erfasst werden.\n\n\nBei der Dateneingabe wird anschliessend ein Auswahlliste mit den zulässigen Werten, so dass die Werte nicht mehr direkt eingetippt werden müssen. Diese Auswahlliste kann unterbunden werden, wenn die Option Zellendropdown deaktiviert wird.\n\n\n\n\nFisher, N. I., & Kordupleski, R. E. (2019). Good and bad market research: A critical review of Net Promoter Score. Applied Stochastic Models in Business and Industry, 35(1), 138–151. https://doi.org/10.1002/asmb.2417\n\n\nGrisaffe, D. B. (2007). Questions about the ultimate question: conceptual considerations in evaluating Reichheld’s Net Promoter Score (NPS). 20.\n\n\nKeiningham, T. L., Cooil, B., Andreassen, T. W., & Aksoy, L. (2007). A Longitudinal Examination of Net Promoter and Firm Revenue Growth. Journal of Marketing, 71(3), 39–51. https://doi.org/10.1509/jmkg.71.3.039\n\n\nMicrosoft Support. (2023). Excel specifications and limits. https://support.microsoft.com/en-gb/office/excel-specifications-and-limits-1672b34d-7043-467e-8e27-269d656771c3\n\n\nReichheld, F. F. (2003). The One Number You Need to Grow. Harvard Business Review.",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Daten sammeln</span>"
    ]
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html",
    "href": "kapitel/datentypen/kapitel.html",
    "title": "6  Datentypen",
    "section": "",
    "text": "6.1 Fundamentale Datentypen\nExcel kennt sechs fundamentale Datentypen.",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html#fundamentale-datentypen",
    "href": "kapitel/datentypen/kapitel.html#fundamentale-datentypen",
    "title": "6  Datentypen",
    "section": "",
    "text": "Zahlen\nZeichenketten\nWahrheitswerte\nFehlerwerte\nFormeln\nleere Zelle\n\n\n6.1.1 Zahlen\nZahlen werden in Excel immer als Gleitkommazahlen behandelt. Excel kennt keine ganzen Zahlen. Wenn eine Zahl in eine ganze Zahl umgewandelt wird (z.B. durch die Funktion GANZZAHL), wird lediglich der Nachkommaanteil der Zahl auf 0 gesetzt.\nManche Excel Funktionen arbeiten nur mit ganzen Zahlen. In diesen Fällen wird der Nachkommaanteil der Zahl automatisch abgeschnitten.\nDurch die Verwendung von Gleitkommazahlen können in Excel Zahlen mit einer Genauigkeit von 15 signifikanten Stellen dargestellt werden. Werden zwei Zahlen addiert, und das Ergebnis mehr als 15 signifikante Stellen hätte, werden alle Stellen ab der 15. signifikanten Stelle abgeschnitten. Excel versucht diese Fehler möglichst zu vermeiden.\nDer Datentyp Zahlen wird in Excel mit der Funktion ISTZAHL() geprüft. Die Funktion ISTZAHL() liefert WAHR, wenn der Wert ein Zahl ist, und sonst FALSCH.\n\n\n6.1.2 Zeichenketten\nZeichenketten heissen in Excel Text. Zeichenketten werden von Excel automatisch gewählt, wenn kein anderer Datentyp für eine Eingabe erkannt wurde. Um die automatische Erkennung zu verhindern, muss der Apostroph-Dekorator (s. Abschnitt 6.2.1) verwendet werden.\nIm Formelmodus müssen Zeichenketten in doppelte Anführungszeichen eingeschlossen werden. Im Wertemodus müssen Zeichenketten meist nicht besonders markiert werden.\nDer Datentyp Zeichenkette wird in Excel mit der Funktion ISTTEXT() geprüft. Die Funktion ISTTEXT() liefert WAHR, wenn der Wert eine Zeichenkette ist, und sonst FALSCH.\nBesondere Zeichenketten sind Adressen bzw. im Excel Jargon Bezüge. Die Funktion ISTBEZUG() prüft, ob eine Zeichenkette eine gültige Excel Adresse ist. Die Funktion ISTBEZUG() liefert WAHR, wenn die Zeichenkette eine Adresse ist, und sonst FALSCH.\n\n\n6.1.3 Wahrheitswerte\nWahrheitswerte heissen in Excel WAHR und FALSCH. Wahrheitswerte heissen im Excel Jargon logische Werte. Während der Werteeingabe werden Wahrheitswerte unabhängig von der Gross- und Kleinschreibung automatisch erkannt.\nIm Formelmodus dürfen Wahrheitswerte nicht in Anführungszeichen eingeschlossen werden, weil sonst die Symbole als Zeichenkette behandelt werden.\nDer Datentyp Wahrheitswerte wird in Excel mit der Funktion ISTLOG() geprüft. Die Funktion ISTZLOG() liefert WAHR, wenn der Wert ein Wahrheitswert ist, und sonst FALSCH.\n\n\n6.1.4 Fehlerwerte\nFehlerwerte ist in Excel ein besonderer Datentyp, um Fehler zu signalisieren. Fehler beginnen immer mit einem Gatter (#), das von einem sog. Fehlerbezeichner gefolgt wird. In der Regel werden Fehlerwerte automatisch erzeugt, es ist aber möglich, Fehlerwerte auch manuell einzugeben. Bei der manuellen Eingabe von Fehlerwerten werden nur die gültigen Fehlerbezeichner akzeptiert. Andere Symbolfolgen werden als Zeichenketten interpretiert.\nExcels gültige Fehlerwerte sind #NV, #NULL!, #WERT!, #BEZUG!, #DIV/0!, #ZAHL!, #NAME?, #KALK!, #ÜBERLAUF!, #DATEN_ABRUFEN! und #ZAHL!.\nDer Wert #NV wird in Excel verwendet, um einen ungültigen Wert zu verweisen. Dieser Wert ist nicht gleichbedeutend mit fehlenden Werten.\nDer Datentyp Fehlerwert wird in Excel mit der Funktion ISTFEHLER() geprüft. Die Funktion ISTFEHLER() liefert WAHR, wenn der Wert ein Fehlerwert ist, und sonst FALSCH. Um einen bestimmten Fehlerwert zu prüfen, kann die Funktion FEHLER.TYP() mit dem entsprechenden Fehlerbezeichner als Argument verwendet werden. Diese Funktion gibt einen eindeutigen Zahlenwert für den Fehler zurück. Ist der Wert kein Fehlerwert, dann wird der Fehler #NV zurückgegeben.\n\n\n6.1.5 Formeln\nFormeln sind ein eigener Datentyp, die mit dem Gleich-Dekorator (=) beginnen. Eine Formel besteht immer aus einem Wert, einem Funktionsaufruf oder einer Kombination von Werten und Funktionsaufrufen, die durch Operatoren verknüpft wurden.\nDer Datentyp Formel wird in Excel mit der Funktion ISTFORMEL() geprüft. Die Funktion ISTFORMEL() liefert WAHR, wenn der Wert eine Formel ist, und sonst FALSCH.\nFormeln sind in Excel ein besonderer Datentyp, denn eine Zelle mit einer Formel hat immer zwei Datentypen. Der erste Datentyp ist der Datentyp Formel, der zweite Datentyp ist der Datentyp des Formelergebnisses.\n\n\n6.1.6 Leere Zellen\nLeere Zellen sind Zellen, die keinen Wert enthalten. Leere Zellen zeigen fehlende Werte in Excel an.\nDie leere Zelle ist für Excel ein eigener Datentyp und wird mit der Funktion ISTLEER() geprüft. Die Funktion ISTLEER() liefert WAHR, wenn der Wert eine leere Zelle ist, und sonst FALSCH.\n\n\n\n\n\n\nWarnung\n\n\n\nEine leere Zelle und eine leere Zeichenkette lassen sich mit dem Auge nicht unterscheiden. Die Funktion ISTLEER() liefert für eine leere Zeichenkette FALSCH zurück, weil die Zelle einen Wert enthält.\n\n\nLeere Zellen als Ergebnis einer Formel werden von Excel in die Zahl 0 umgewandelt. Im Kapitel Abschnitt 8.2 wird gezeigt, wie sich leere Zellen von Zellen mit dem Wert 0 unterscheiden lassen. Im Abschnitt 8.4.1 wird auf leere Zellen als Funktionsergebnisse ausführlich eingegangen.",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html#dekoratoren",
    "href": "kapitel/datentypen/kapitel.html#dekoratoren",
    "title": "6  Datentypen",
    "section": "6.2 Dekoratoren",
    "text": "6.2 Dekoratoren\n\nDefinition 6.1 Ein Dekorator ist Sprachelement einer Programmiersprache, mit dem die normale Interpretation von Symbolen verändert werden kann.\n\nExcel hat zwei Dekoratoren, als erstes Symbol einer Zelle stehen müssen. D.h. es dürfen auch keine Leerzeichen vor einem Dekorator stehen. Die beiden Dekoratoren sind:\n\nDer Apostroph-Dekorator (')\nDer Gleich-Dekorator (=)\n\n\n6.2.1 Apostroph-Dekoraktor\nDer Apostroph-Dekorator (') erzwingt, dass die nachfolgenden Symbole als Zeichenkette interpretiert werden müssen.\nMithilfe des Apostroph-Dekorators wird die automatische Typerkennung für die laufende Eingabe deaktiviert. Auf diese Weise lassen sich Zeichenketten eingeben, die nur aus Ziffern bestehen oder Zeichenketten, die Datentumswerten ähneln.\nDer Apostroph-Dekorator muss zwingend verwendet werden, wenn auf eine Zeichenkette eine der folgenden Bedingungen zutrifft.\n\nDie Zeichenkette beginnt mit einem Gleichheitszeichen (=), einem Pluszeichen (+), einem Minuszeichen (-) oder einem Prozentzeichen (%).\nDie Zeichenkette besteht nur aus Ziffern, dem Dezimaltrenner (.) oder dem Tausendertrenner (‘) enthält\nDie Zeichenkette ähnelt der wissenschaftliche Notation für Zahlen mit und ohne Vorzeichen für den Exponenten. Z.B. 5.E3.\nDie Zeichenkette ähnelt einem Datum.\nDie Zeichenkette entspricht einen Fehlerwert, unabhängig von der Schreibweise. Z.B. #nv.\nDie Zeichenkette entspricht einem Wahrheitswert (WAHR oder FALSCH) unabhängig von der Schreibweise.\n\nDas Apostroph kann entfallen, wenn die aktive Zelle vorher bereits als Datentyp Text formatiert wurde. In diesem Fall verlieren alle Symbole ihre spezielle Bedeutung. In solche Zellen können keine Formeln eingegeben werden.\n\n\n6.2.2 Gleich-Dekorator\nDer Gleich-Dekorator (=) zeigt an, dass die nachfolgenden Symbole als Formel interpretiert werden müssen.\nBei der Eingabe des Gleich-Dekorators wechselt Excel für die laufende Eingabe in den Formelmodus. Mit beenden der Eingabe mit der Eingabetaste wird der Formelmodus wieder verlassen und das Ergebnis der eingegebenen Formel wird in der Zelle angezeigt.",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html#komplexe-datenstrukturen",
    "href": "kapitel/datentypen/kapitel.html#komplexe-datenstrukturen",
    "title": "6  Datentypen",
    "section": "6.3 Komplexe Datenstrukturen",
    "text": "6.3 Komplexe Datenstrukturen\nExcel kennt zwei komplexe Datenstrukturen:\n\nBereiche\nTabellen\n\nExcels komplexe Datenstrukturen müssen einen fundamentalen Datentyp haben und können keine komplexen Datenstrukturen schachteln.\n\n6.3.1 Bereiche: Vektoren und Matrizen\nExcels Grundstruktur ist das Rechteck, dass durch die markierten Zellen entsteht. Dieses Rechteck heisst im Excel Jargon ein Bereich.\nObwohl Excel vektorähnliche Bereiche kennt, ist es sinnvolle sich Excels Bereiche immer als Matrizen vorzustellen.\n\nEin Bereich mit nur einer Zelle ist eine 1x1- oder 0-dimensionale Matrix.\nEin Bereich mit nur einer Zeile oder einer Spalte ist für Excel eine 1xn- oder 1-dimensionale Matrix. Diese speziellen Matrizen werden in der Regel als Vektoren bezeichnet.\nEin Bereich mit mehreren Zeilen und Spalten ist eine nxm- oder 2-dimensionale Matrix.\n\nFunktionen können Bereiche als Ergebnis haben. In diesem Fall werden die restlichen Werte zeilen und spaltenweise unterhalb bzw. rechts von der entsprechenden Formel ausgegeben.\n\n\n6.3.2 Tabellen\nTabellen sind benannte Bereiche, die Vektoren enthalten. Tabellen bestehen aus Spalten, in denen die Werte als Vektoren stehen. Excel Tabellen haben immer Überschriften.\nExcel kennt zwei Arten von Tabellen:\n\nWertetabellen\nPivot-Tabellen.\n\n\nDefinition 6.2 Wertetabellen sind Listen, die Listen mit gleicher Länge schachteln.\n\nWertetabellen entsprechen ungefähr einem Datenrahmen (engl. data-frame) in anderen Programmiersprachen. Der Unterschied zu einem Datenrahmen ist, dass Excels Wertetabellen keine Vektoren erzwingen. Deshalb können in der gleichen Spalte einer Wertetabelle verschiedene Datentypen gemischt werden.\n\nDefinition 6.3 Pivot-Tabellen sind ein Werkzeug zum interaktiven Zusammenfassen von Daten.\n\nPivot-Tabellen erleichtern einfache Datenanalysen. Pivot-Tabellen entsprechen einer tabellarischen Darstellung der Daten. Ihre Funktion ist auf wenige analytische Funktionen beschränkt und die dargestellten Werte lassen sich nur umständlich weiterverarbeiten.\nPivot-Tabellen sind Arbeitsmappenelemente aber keine Datenstrukturen. Deshalb werden Pivot-Tabellen in diesem Buch ähnlich einer Visualisierung als Darstellungsform behandelt.",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html#sec-adressierung-ds",
    "href": "kapitel/datentypen/kapitel.html#sec-adressierung-ds",
    "title": "6  Datentypen",
    "section": "6.4 Adressierung von Datenstrukturen",
    "text": "6.4 Adressierung von Datenstrukturen\n\nDefinition 6.4 Ein Bezug ist die Adresse eines Bereichs.\n\nIn Excel gibt es zwei Arten von Bezügen:\n\nArbeitsblattadressen\nTabellenadressen\n\n\n6.4.1 Arbeitsblattadressen\n\nDefinition 6.5 Eine Arbeitsblattadresse enthält die Koordinaten eines Bereichs auf einem Arbeitsblatt.\n\nArbeitsblattadressen besteht aus drei Teilen:\n\nArbeitsblattname\nBereichsbeginn\nBereichsende\n\nDer Bereichsbeginn verweist immer auf die linke obere Zelle des Bereichs. Der Bereichsende verweist immer auf die rechte untere Zelle des Bereichs. Eine Zelle wird immer durch den Spaltenindex (Buchstabe) und den Zeilenindex (Zahl) identifiziert. Werden die Koordinaten des Bereichsbeginns und des Bereichsendes bei der Eingabe vertauscht, dann wird der Bereich automatisch korrigiert.\n\nBeispiel 6.1 (Arbeitsblattadresse)  \nTabelle1!A1:C3\n\nBeispiel 6.1 verweist auf den Bereich mit drei Spalten und drei Zeilen auf dem Arbeitsblatt Tabelle1 beginnend mit der Zelle A1 und endend mit der Zelle C3.\nOft werden Arbeitsblattadressen nicht vollständig sondern gekürzt angegeben. Es gibt zwei Möglichkeiten, um Arbeitsblattadressen zu kürzen:\n\nWerden Bereiche auf dem gleichen Arbeitsblatt adressiert, dann kann der Arbeitsblattname weggelassen werden.\nWird ein Bereich mit nur einer Zelle adressiert, dann wird das Bereichsende weggelassen.\n\nWeil Arbeitsblattadressen von vielen interaktiven Excelkommandos verwendet werden, gibt es zwei Arten von Arbeitsblattadressen:\n\nRelative Adressen\nAbsolute Adressen\n\nDie Art der Adresse legt fest, wie ein interaktives Kommando mit einer Adresse umgehen soll. Die populärste interaktive Funktion ist das Autoauffüllen. Dabei wird eine Zelle mit einer Formel interaktiv auf einen Bereich von Zellen übertragen.\n\n\n\n\n\n\nWarnung\n\n\n\nDas Autoauffüllen ist eine einfache und beliebte Methode, um Formeln in Excel auf verschiedene Werte wiederholt anzuwenden. Bis 2019 war das Autoauffüllen die einzige Möglichkeit für die Datentransformation.\nDie relative und absolute Adressierung ist eine wichtige Voraussetzung für das Autoauffüllen. Leider ist das Autoauffüllen auch die Ursache für viele Fehler beim Umgang mit Excel.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nIn Excel365 kann das Autoauffüllen durch vektorisierte Funktionen fast vollständig ersetzt werden. Dadurch lassen sich viele Excel-typische Fehler vermeiden. Dadurch ist die Unterscheidung zwischen der relativen und absoluten Adressierung nicht mehr so wichtig.\n\n\n\n6.4.1.1 Relative Adressen\n\nDefinition 6.6 Eine relative Adresse ist eine Adresse eines Bereichs, die veränderlich ist.\n\nRelative Adressen werden in Excel von interaktiven Funktionen, wie dem Autoauffüllen verwendet, um die Adressen automatisch anzupassen. Eine relative Adresse wird relativ zur aktuellen Zelle angepasst.\nEin Beispiel für eine relative Adresse ist A1. Diese Adresse bezeichnet die Zelle, die sich in der ersten Zeile und der ersten Spalte auf dem aktuellen Arbeitsblatt befindet. Wird die adressierte Zelle interaktiv nach unten aufgefüllt, dann wird die Adresse automatisch zu A2, A3, usw. angepasst. Wird die adressierte Zelle nach rechts aufgefüllt, dann wird die Adresse automatisch zu B1, C1, usw. angepasst.\n\n\n6.4.1.2 Absolute Adressen\n\nDefinition 6.7 Eine absolute Adresse ist eine Adresse eines Bereichs, die ganz oder teilweise unveränderlich ist.\n\nDer unveränderliche Teil einer Arbeitsblattadresse wird mit einem Dollarzeichen ($) markiert. Dieser Teil der Adresse wird bei der Anpassung der Adresse nicht verändert. So lassen sich Adressen angeben, die durch interaktive Kommandos nicht verändert werden.\nEin Beispiel für eine absolute Adresse ist $A$1. Diese Adresse bezeichnet die Zelle, die sich in der ersten Zeile und der ersten Spalte auf dem aktuellen Arbeitsblatt befindet. Wird die adressierte Zelle interaktiv horizontal oder vertikal aufgefüllt, dann wird die Adresse nicht angepasst.\nAuf diese Weise lassen sich konstante Werte in Formeln einbauen.\n\n\n\n6.4.2 Tabellenadressen\nSpalten und einzelne Werte können über die Tabellenadressierung abgefragt werden (Microsoft Support, 2023). Das Ergebnis einer solchen Adressierung ist immer ein dynamisches Feld bzw. ein dynamischer Bereich (s. Abschnitt 8.1.1).\n\n\n\n\n\n\nHinweis\n\n\n\nJede Tabellenadresse kann auch als Arbeitsblattadresse dargestellt werden. Umgekehrt ist dies nicht möglich.\n\n\nEine Tabellenadresse besteht aus zwei Teilen:\n\nDem Tabellennamen\nDem Spaltennamen\n\n\nBeispiel 6.2 (Tabellenadresse)  \nTabelle1[Spalte1]\n\nDas Beispiel 6.2 verweist auf die Spalte Spalte1 der Tabelle Tabelle1.\n\n\n\n\n\n\nWichtig\n\n\n\nDie Namen von Tabellen sind unabhängig den Arbeitsblattnamen. In der gleichen Arbeitsmappe darf jeweils nur eine Tabelle und nur ein Arbeitsblatt mit dem gleichen Namen existieren. Es ist aber möglich, dass eine Tabelle und ein Arbeitsblatt den gleichen Namen haben. Das kann zu Verwirrungen führen, denn die Adresse Tabelle1[Spalte1] und die Adresse Tabelle1!A:A verweisen nicht zwingend auf die gleiche Spalte, denn eine Tabelle muss nicht auf einem Arbeitsblatt mit dem gleichen Namen stehen!\n\n\nTabellenadressen können auch gekürzt werden:\n\nWerden Spalten in der gleichen Tabelle angesprochen, dann kann der Tabellenname weggelassen werden.\nSoll die gesamte Tabelle angesprochen werden, dann kann der Spaltenname weggelassen werden.\n\n\n6.4.2.1 Tabellenbereiche\nUm mehrere Spalten einer Tabelle anzusprechen kann der Bereichsoperator (:) wie bei der Arbeitsblattadressierung verwendet werden. Zusätzlich müssen die Spalten in ein weiteres Paar eckiger Klammern eingeschlossen werden.\n\nBeispiel 6.3 (Tabellenbereich)  \nTabelle1[[Spalte1]:[Spalte3]]\n\nBeispiel 6.3 verweist auf alle Spalten zwischen Spalte1 und Spalte3 der Tabelle Tabelle1.\n\n\n\n\n\n\nWarnung\n\n\n\nWerden zu einem späteren Zeitpunkt neue Spalten zwischen den adressierten Spalten hinzugefügt, dann werden die neuen Spalten automatisch in die Adressierung einbezogen.\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nEs ist nicht möglich mehrere Spalten einer Tabellen gleichzeitig gezielt zu adressieren, wenn diese nicht unmittelbar nebeneinander stehen. Diese Adressierung ist unmöglich, weil Excel nur rechteckige Bereiche adressieren kann und solche Spalten keinen rechteckigen Bereich bilden.\nDie Adressierung aus Beispiel 6.3 kann nicht angepasst werden, so dass nur Spalte1 und Spalte3 adressiert werden, ausser die Spalten Spalte1 und Spalte3 stehen direkt nebeneinander.\n\n\n\n\n6.4.2.2 Diese Zeile-Operator\nEinzelne Zeilen einer Tabelle können mit dem Diese Zeile-Operator adressiert werden. Der Diese Zeile-Operator wird mit dem Wert [#Diese Zeile] oder mit @ angegeben. Dieser Operator reduziert die Tabelle auf eine einzelne Zeile und wählt anschliessend die gewünschte Spalte aus. Diese Zeile bedeutet für Excel die aktuelle Zeile des Arbeitsblatts.\n\n\nBeispiel 6.4 (Diese Zeile-Operator für eine Tabellenzelle)  \n= Tabelle[@Spalte]\noder\n= @Tabelle[Spalte]\n\n\nDer Operator ist speziell für die Verwendung in Formeln in Tabellenzellen gedacht. Obwohl der Operator in allen Formeln eingesetzt werden kann, sollte der Einsatz auf Formeln beschränkt werden, die sich in einer Tabelle befinden.\n\n\n\n\n\n\nWarnung\n\n\n\nDer Diese Zeile-Operator kann nicht auf Tabellen angewendet werden, um eine ganze Zeile zu adressieren. Es darf immer nur eine einzelne Zelle adressiert werden. Die Adressierung @Tabelle ist also ungültig.\n\n\n\n\n\n\n\n\nWarnung\n\n\n\nDer Diese Zeile-Operator ist immer relativ zum Arbeitsblatt und nicht relativ zur aktuellen Tabelle. Es muss nur der Zeilenindex gleich sein, die Zielzelle kann sich auf einem anderen Arbeitsblatt befinden.\n\n\nWird der Diese Zeile-Operator in Tabellen unterschiedlicher Länge verwendet, dann können zwei Fälle eintreten:\n\nIst die adressierte Tabelle kürzer als die adressierende Tabelle, dann wird für die Zeilen, die keine Entsprechung in der adressierten Tabelle haben, der Fehler #WERT! zurückgegeben.\nIst die adressierte Tabelle länger als die adressierende Tabelle, dann werden alle überzähligen Zeilen ignoriert.\n\n\n\n\n\n\n\nPraxis\n\n\n\nDer Diese Zeile-Operator kann nur auf eine einzelne Zelle in der gleichen Zeile auf einem Arbeitsblatts angewendet werden. Wegen dieser Einschränkung des Diese Zeile-Operators sollten alle Tabellen so gestaltet werden, dass sie in der ersten Zeile des Arbeitsblatts beginnen. Dadurch kann der Diese Zeile-Operator in allen Tabellen verwendet werden.\n\n\n\n\n6.4.2.3 Überschriften adressieren\nEine Excel Tabelle hat immer Spaltenüberschriften. Diese Überschriften können ebenfalls über die Tabellenadressierung adressiert werden. Dazu wird als Spaltenname der Wert #Kopfzeilen verwendet.\n\nBeispiel 6.5 (Kopfzeilen einer Tabelle adressieren)  \nTabelle1[#Kopfzeilen]\n\nUm gezielt Kopfzeilen zu adressieren, kann die Adressierung aus Beispiel 6.5 mit der Adressierung aus Beispiel 6.3 kombiniert werden (Beispiel 6.6).\n\nBeispiel 6.6 (Kopfzeilen einer Tabelle adressieren)  \nTabelle1[[#Kopfzeilen];[Spalte1]:[Spalte3]]\n\n\n\n6.4.2.4 Absolute Adressierung in Tabellen\nEin Tabellenbereich ist immer absolut adressiert. Wird aber nur eine einzelne Spalte einer Tabelle adressiert, dann wird die Adresse relativ adressiert. Damit beim Autoauffüllen diese Adresse nicht verändert wird, muss die Adresse als Bereich angegeben werden.\n\nBeispiel 6.7 (Absolute Tabellenadressierung von einer Spalte)  \nTabelle1[[Spalte1]:[Spalte1]]\n\nWird eine Formel mit dieser Adresse interaktiv aufgefüllt, dann wird die Adresse nicht verändert.\n\n\n\n\nMicrosoft Support. (2023). Using structured references with Excel tables. https://support.microsoft.com/en-gb/office/using-structured-references-with-excel-tables-f5ed2452-2337-4f71-bed3-c8ae6d2b276e",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-importieren/kapitel.html",
    "href": "kapitel/daten-importieren/kapitel.html",
    "title": "7  Daten importieren",
    "section": "",
    "text": "7.1 Datenverbindungen herstellen\nViele Excel Arbeitsmappen kombinieren Berechnungen und Daten. Excel kann allerdings auch Daten aus anderen Quellen importieren. Quellen können andere Dateien, Datenbanken oder Web-APIs sein und in verschiedenen Formaten vorliegen. Dafür stellt Excel Parser für verschiedene Dateiformate bereit, damit die Daten importiert werden können.\nDaten werden korrekt mit dem Kommando Daten abrufen (Power Query) importiert. Das Kommando ist in der Gruppe Daten im Abschnitt Daten abrufen und transformieren zu finden. Das Kommando Daten abrufen startet die sog. Power Query Umgebung. In dieser Umgebung können Daten aus verschiedenen Quellen importiert und vor der Bereitstellung korrigiert werden.\nDas Kernprinzip von Power Query ist das Verbinden einer Datenquelle mit einer Arbeitsmappen. Entsprechend heissen importierte Daten im Excel Jargon Datenverbindungen. Die Datenquelle wird dabei nicht in die Arbeitsmappe übernommen, sondern nur eine Verbindung zu der Datenquelle hergestellt. Dadurch kann eine Datenquelle in mehreren Arbeitsmappen verwendet werden und sich ändern, ohne dass die Arbeitsmappe angepasst werden muss.\nEine Datenverbindung wird über das Kommando Daten abrufen (Power Query) ausgelöst. Das Kommando ist in der Gruppe Daten im Abschnitt Daten abrufen und transformieren zu finden. Das Kommando bereitet den Import durch Power Query vor, indem zuerst das Dateiformat und anschliessend die zugehörige Datenquellen ausgewählt wird. Nach diesen Schritten kann Excel die Daten Laden oder die Daten transformieren (s. Abbildung 7.3).\nWird die Option Daten transformieren ausgewählt, öffnet sich der Power Query Editor. In diesem Editor können die Daten überprüft und transformiert werden. Das Transformieren der Daten umfasst vier Arten der Transformation:\nFür jede Transformation wird ein Schritt in Power Query angelegt. Die Schritte werden in der Reihenfolge der Ausführung angezeigt. Die Reihenfolge der Schritte kann verändert werden, indem die Schritte mit der Maus verschoben werden. In der Mitte des Power Query Fensters wird eine Datenvorschau angezeigt, die die Auswirkungen der Transformationen zeigt.\nStandardmässig werden drei bzw. bei Excel Arbeitsmappen vier Schritte in Power Query automatisch konfiguriert:\nDer Schritt Geänderter Typ enthält die Schemadefinition. Power Query versucht das Schema automatisch zu erkennen. Das funktioniert besonders bei Zahlenwerten nicht immer zuverlässig. Deshalb muss das Schema immer kontrolliert und gegebenenfalls angepasst werden.\nNachdem das Schema kontrolliert wurde, können die Daten nach Excel importiert werden. Dazu wird das Kommando Schließen & laden in Power Query Menukategorie Start ausgeführt.\nNach einem Datenimport liegen die Daten in der Arbeitsmappe als Tabelle vor. Diese Daten sind eine Kopie der Daten in der Datenquelle. Dadurch kann die Arbeitsmappe unabhängig von der Datenquelle verwendet und geteilt werden.",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Daten importieren</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-importieren/kapitel.html#datenverbindungen-herstellen",
    "href": "kapitel/daten-importieren/kapitel.html#datenverbindungen-herstellen",
    "title": "7  Daten importieren",
    "section": "",
    "text": "Praxis\n\n\n\nDie Daten sollten nur in Ausnahmefällen unkontrolliert geladen werden. Die Daten sollten vor dem Importieren in Power Query überprüft und transformiert werden. Dadurch wird sichergestellt, dass die Daten korrekt importiert werden.\n\n\n\n\n\n\n\n\nAbbildung 7.3: Laden oder Transformieren-Auswahl beim Import einer Excel Arbeitsmappe\n\n\n\n\n\nDatentypanpassungen\nSpaltenauswahl\nDatentrennung\nDaten kombinieren\n\n\n\n\nQuelle\n\nBei Excel Arbeitsmappen folgt dem Schritt Quelle der Schritt Navigation zur Auswahl des Arbeitsblattes.\n\nHöherstufen\nGeänderter Typ (Windows) bzw. geänderter Spaltentyp (MacOS)\n\n\n\n\n\n\n\n\nAbbildung 7.4: Schemaanpassung mit Power Query\n\n\n\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nExcel betrachtet jeden Datenimport als Sicherheitsproblem. Daher werden Datenverbindungen beim Öffnen einer Arbeitsmappe standardmässig deaktiviert. Beim Öffnen einer Arbeitsmappe mit einer Datenverbindung wird eine Warnung angezeigt. Um mit den importierten Daten arbeiten zu können, muss die Datenverbindung aktiviert werden.\nWird die Datenverbindung nicht aktiviert, werden Funktionen die auf die Daten zugreifen nicht ausgeführt, sondern nur die Ergebnisse der letzten Ausführung angezeigt.",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Daten importieren</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-importieren/kapitel.html#datenschema-anpassen",
    "href": "kapitel/daten-importieren/kapitel.html#datenschema-anpassen",
    "title": "7  Daten importieren",
    "section": "7.2 Datenschema anpassen",
    "text": "7.2 Datenschema anpassen\nDie einfachste Möglichkeit zur Anpassung des Datenschemas ist die Verwendung der Menukategorie Transformation. Dieses Menu zeigt alle verfügbaren Transformationen an. Die Transformationen sind in sechs Kategorien gegliedert:\n\n\n\n\n\n\nAbbildung 7.5: Power Query Menu Transformation\n\n\n\n\nTabelle\nBeliebige Spalte\nTextspalte\nZahlenspalte\nDatums- & Uhrzeitspalte\nStrukturierte Spalte\n\nFür das Datenschema sind die folgenden Transformationen wichtig:\n\nDatentyp\nUmbenennen\nVerschieben\nSpalte teilen\n\n\n\n\n\n\n\nHinweis\n\n\n\nDie meisten Transformationen gehören konzeptionell zu späteren Kapiteln.\n\nGruppieren nach und Werte ersetzen werden im Kapitel 13 behandelt.\nVertauschen wird im Kapitel 12 behandelt.\nZellen zählen, Ausfüllen und alle Transformationen in den Kategorien Zahlenspalten, Datums- & Uhrzeitspalten und Strukturierte Spalten werden im Kapitel 11 behandelt.\nSpalte pivotisieren und Spalte entpivotisieren werden im Kapitel 14 behandelt.\nFormat, Analysieren und Extrahieren (Kategorie Textspalte) werden im Kapitel 9 behandelt.\n\nIn diesen Kapiteln werden die Transformationen von Power Query separat hervorgehoben.\n\n\n\n7.2.1 Datentyp anpassen\nDie wichtigste Transformation ist die Anpassung des Datentyps. Der Datentyp bestimmt, wie die Daten interpretiert werden. Die Interpretation der Daten bestimmt, welche Operationen auf die Daten angewendet werden können.\n\n\n\n\n\n\nWichtig\n\n\n\nDie Datentypen müssen im Schritt Geänderter Typ (Windows) bzw. geänderter Spaltentyp (MacOS) angepasst werden.\n\n\nPower Query zeigt neben den Spaltenüberschriften mit einem Symbol den Datentyp der Spalte an. Tabelle 7.1 zeigt die Symbole für die verschiedenen Datentypen. Zusätzlich wird der Datentyp im Menubalken neben dem Kommando Datentyp angezeigt. Die Datentypen sind in vier Kategorien unterteilt:\n\nZahlen\nDatum und Uhrzeit\nZeichenketten\nWahrheitswerte\n\nIm Gegensatz zu Excel behandelt Power Query Datum und Uhrzeit als eigenen Datentyp. Power Query muss diese Unterscheidung machen, weil in den Datenquellen diese Werte als Zeichenketten kodiert vorliegen. Dabei handelt es sich um strukturierte Daten. Power Query hat für diese Daten spezielle Parser, die die Zeichenketten aus der Datenquelle in Zahlenwerte für Excel umwandeln.\n\n\n\nTabelle 7.1: Power Query Datentypen mit Symbolen\n\n\n\n\n\n\n\n\n\n\n\nDatentyp\nSymbol\nKategorie\nBemerkungen\n\n\n\n\nText\n\nZeichenketten\n\n\n\nTRUE/FALSE\n\nWahrheitswerte\n\n\n\nDezimalzahl\n\nZahlen\n\n\n\nGanze Zahl\n\nZahlen\n\n\n\nProzentzahl\n\nZahlen\nDezimalzahl mal 100\n\n\nWährung\n\nZahlen\nDezimalzahl mit Währungsformatierung\n\n\nBinärzahl\n\nZahlen\nGanzzahl\n\n\n(Zahl) mit Gebietsschema\n\nZahlen\nDas Gebietsschema legt den Tausender- und Dezimaltrenner fest\n\n\nDatum/Uhrzeit\n\nDatum und Uhrzeit\nZeitstempel als formatierte Dezimalzahl\n\n\nDatum\n\nDatum und Uhrzeit\nGanzzahl mit Datumsformatierung\n\n\nUhrzeit\n\nDatum und Uhrzeit\nDezimalzahl zwischen 0 und 1 mit Zeitformatierung\n\n\nDauer\n\nDatum und Uhrzeit\nDezimalzahl als Zeitdauer\n\n\nDatum/Uhrzeit/Zeitzone\n\nDatum und Uhrzeit\nInternationalisierter Zeitstempel als formatierte Dezimalzahl, die Zeitzone muss in den Werten kodiert sein, sonst wird +1 angenommen.\n\n\n\n\n\n\nDer Datentyp einer Spalte lässt sich mit dem Kommando Datentyp anpassen. Wird auf das Kommando im Menubalken geklickt, öffnet sich eine Auswahlliste, aus der der richtige Datentyp ausgewählt werden kann (Abbildung 7.6). Wird der Datentyp geändert, dann erfolgt eine Abfrage (s. Abbildung 7.7), ob der Datentyp im aktuellen Arbeitsschritt ersetzt werden soll (Aktuelle ersetzen) oder ob ein neuer Arbeitsschritt eingefügt werden soll (Neuen Schritt hinzufügen). Hier kann normalerweise Aktuelle ersetzen ausgewählt werden.\n\n\n\n\n\n\nAbbildung 7.6: Änderung des Datentyps einer Spalte\n\n\n\n\n\n\n\n\n\nAbbildung 7.7: Abfrage vor dem Ändern eines Datentyps\n\n\n\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nGelegentlich müssen Zahlen an das richtige Gebietsschema angepasst werden, damit die Werte korrekt eingelesen werden. Das ist immer dann notwendig, wenn das Dezimaltrennzeichen in der zu importierenden Datei vom aktuellen Gebietsschema abweicht.\nUnter MacOS können gebietsspezifische Datenformate sowohl über den Menübalken Transformieren als auch über die Spaltenüberschrift erreicht und angepasst werden.\nUnter Windows ist die Option mit Gebietsschema nur hinter dem Datentyp-Icon über die Spaltenüberschrift erreichbar. Dazu wird mit der rechten Maustaste auf die Spaltenüberschrift geklickt und anschliessend das Untermenü Typ ändern ausgewählt. Dort findet sich ganz unten der Punkt Mit Gebietsschema.... Alternativ lässt sich dieses Menü auch erreichen, indem mit der linken Maustaste auf das Datentyp-Icon links neben der Spaltenüberschrift geklickt wird. Beide Optionen funktionieren auch unter MacOS.\n\n\n\n\n\n\nAbbildung 7.8: Gebietsschema Datentyp in PowerQuery über das Datentypmenü der Spaltenüberschrift\n\n\n\n\n\n\n\n\n\n\n\nMerke\n\n\n\nBeim Import mit Gebietsschema gilt es folgendes zu beachten:\n\nWenn Zahlen mit Komma als Dezimaltrennung importiert werden sollen, dann muss eine Region ausgewählt werden, in der das Komma verwendet wird (z.B. Deutschland oder Frankreich).\nWenn Zahlen mit Punkt als Dezimaltrennung importiert werden sollen, dann muss eine Region ausgewählt werden, in der ein Punkt verwendet wird (z.B. Schweiz oder Vereinigte Staaten).\n\n\n\n\n\n7.2.2 Spalten umbenennen\nFalls einzelne Spaltenüberschriften einer Datenquelle unhandlich sind, lassen sich diese Spalten umbenennen. Dazu wird das Kommando Umbenennen verwendet. Das Kommando ist im Menuband Transformieren im Abschnitt Beliebige Spalte zu finden. Das Kommando öffnet einen Dialog, in dem der neue Name der Spalte eingegeben werden kann. Die Überschrift wird in einem eigenen Arbeitsschritt geändert.\nSpalten lassen sich auch durch einen Doppelklick auf den Spaltennamen umbenennen.\nDie Spaltenüberschriften müssen für die Datenstruktur eindeutig sein. Wird eine Spaltenüberschrift doppelt verwendet, dann gibt Power Query eine Fehlermeldung aus.\n\n\n\n\n\n\nPraxis\n\n\n\nDas Kommando Umbenennen sollte nur verwendet werden, wenn nur einzelne Spalten umbenannt werden müssen. Falls mehrere Spalten umbenannt werden müssen, sollte dieser Schritt als Transformation in Excel durchgeführt werden.\n\n\n\n\n7.2.3 Spalten verschieben\nIn Excel können nur zusammenhängende Bereiche einer Tabelle mit einer Adressierung gemeinsam angesprochen werden. Diese Reihenfolge ist immer dann hilfreich, wenn Matrix-Operationen mit diesen Daten ausgeführt werden sollen. Falls die Spalten einer Datenquelle in einer ungünstigen Reihenfolge vorliegen, lassen diese sich mit einem Kommando unter Verschieben richtig positionieren.\n\n\n7.2.4 Spalte teilen\nManche Daten fassen mehrere Werte in der einer Spalte zusammen. Falls die Werte als strukturierte Daten vorliegen, kann diese Spalte mit dem Kommando Spalte teilen in mehrere Spalten aufgeteilt werden. Dabei werden drei Varianten unterschieden.\n\nDie Separator-Trennung verwendet Trennzeichen zum Abgrenzen der Werte.\nDie Positions-Trennung trennt Festkodierungen mit festen Positionen in einzelne Spalten.\nDie Längen-Trennung trennt Festkodierungen, deren Werte immer die gleiche Anzahl von Symbolen haben.\n\nDie Separator-Trennung kann ein festes Trennzeichen oder ein Trennungsmuster verwenden. Die möglichen Trennungsmuster sind:\n\nBeim Wechsel zwischen kleinen und grossen Buchstaben.\nBeim Wechsel zwischen grossen und kleinen Buchstaben.\nBeim Wechsel zwischen Ziffern und Nicht-Ziffern.\nBeim Wechsel zwischen Nicht-Ziffern und Ziffern.\n\nBeim trennen von Spalten dürfen nicht semistrukturierte Daten getrennt werden, weil diese nicht für alle Werte die gleiche Struktur haben.",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Daten importieren</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-importieren/kapitel.html#spalten-auswählen-oder-entfernen",
    "href": "kapitel/daten-importieren/kapitel.html#spalten-auswählen-oder-entfernen",
    "title": "7  Daten importieren",
    "section": "7.3 Spalten auswählen oder entfernen",
    "text": "7.3 Spalten auswählen oder entfernen\nZwei besondere Transformationen sind Spalten auswählen und Spalten entfernen. Diese Transformationen werden im Menuband Start angeboten. Mit diesen Transformationen lassen sich nicht benötigte Spalten aus den Daten entfernen. Dadurch werden die Daten in Excel übersichtlicher.\nDiese Funktion kommt bei Excel-Arbeitsmappen häufig zum Einsatz, wenn nach Ende der Daten zusätzliche leere Spalten folgen. Diese Spalten können mit Spalten entfernen entfernt werden.\n\n\n\n\n\n\nAbbildung 7.9: Power Query Kommandos zum auswählen oder entfernen von Spalten (Menu Start)\n\n\n\nBeide Kommandos verändern die Datenstruktur, indem Spalten entfernt werden. Das Kommando Spalten auswählen lässt die ausgewählten Spalten in der Datenstruktur und entfernt alle anderen. Das Kommando Spalten entfernen entfernt nur die ausgewählten Spalten.\n\n\n\n\n\n\nAchtung\n\n\n\nEine spezielle Variante von Spalten auswählen ist das Kommando In Liste konvertieren im Menuband Transformieren. Dieses Kommando entfernt alle bis auf die ausgewählte Spalte. Dieses Kommando ändert jedoch die Spaltenüberschrift und sollte deshalb nicht verwendet werden.",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Daten importieren</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-importieren/kapitel.html#daten-aktualisieren",
    "href": "kapitel/daten-importieren/kapitel.html#daten-aktualisieren",
    "title": "7  Daten importieren",
    "section": "7.4 Daten aktualisieren",
    "text": "7.4 Daten aktualisieren\nDie Daten können sich aber ändern, z.B. weil ein Formular ausgefüllt wurde oder eine Datenbank aktualisiert wurde. Dadurch ändern sich die Daten in der Datenquelle. In solchen Fällen ist die Kopie in der Arbeitsmappe nicht mehr aktuell. Um die Daten zu aktualisieren, muss die Datenverbindung aktualisiert werden.\nDazu wird das Kommando Alle aktualisieren verwendet. Das Kommando ist im Menu Daten im Abschnitt Verbindungen zu finden. Das Kommando aktualisiert alle Datenverbindungen in der Arbeitsmappe entsprechend der Importspezifikation.\n\n\n\n\n\n\nAbbildung 7.10: Menubalken Daten - Kommando Alle aktualisieren\n\n\n\nEs werden nur die importierten Daten aktualisiert. Wurde die Tabelle durch Formeln erweitert, werden diese Formeln nicht gelöscht, sondern auf die neuen Daten erweitert.\n\n\n\n\n\n\nWichtig\n\n\n\nDie importierte Struktur darf nicht verändert werden. Das bedeutet, dass innerhalb der Struktur keine Spalten hinzugefügt oder gelöscht werden dürfen. Neue Spalten für Formeln müssen rechts von der importierten Datenstruktur der Tabelle hinzugefügt werden.",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Daten importieren</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-importieren/kapitel.html#datenverbindung-anpassen",
    "href": "kapitel/daten-importieren/kapitel.html#datenverbindung-anpassen",
    "title": "7  Daten importieren",
    "section": "7.5 Datenverbindung anpassen",
    "text": "7.5 Datenverbindung anpassen\nGelegentlich ändert sich der Ort einer Datenquelle. Sehr häufig tritt diese Situation ein, wenn eine Datei in einen anderen Ordner verschoben wird. In solchen Fällen muss die Datenverbindung angepasst werden. Dazu muss in Power Query die Datenquelle angepasst werden.\n\nPowerquery öffnen\nEinstellungen im Schritt “Quelle” auswählen (s. Abbildung 7.11)\nPfad zur Datenquelle anpassen\n\nNachdem die richtige Datei ausgewählt wurde, sollte immer das Schema kontrolliert werden, ob die Änderung keine Auswirkungen auf das Schema hat. Wird dieser Schritt übersprungen, kann es zu Fehlern beim Import kommen und im schlimmsten Fall werden die Formeln in der Arbeitsmappe durch eine Fehlerfortpflanzung zerstört.\nAbschliessend kann wieder das Kommando Schliessen & Landen ausgeführt werden.\n\n\n\n\n\n\nAbbildung 7.11: Power Query: Quelle Anpassen (Ausschnitt)\n\n\n\nAlle Datenverbindungen werden auch im Dialog Abfragen & Verbindungen (s. Abbildung 7.12) angezeigt. Der Dialog ist in der Gruppe Verbindungen im Abschnitt Daten zu finden. Der Dialog zeigt alle Datenverbindungen an, die in der Arbeitsmappe verwendet werden.\n\n\n\n\n\n\nAbbildung 7.12: Menubalken Daten - Abfragen & Verbindungen\n\n\n\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nUnter Windows lassen sich die Datenquellen im Dialog Abfragen & Verbindungen anpassen. Die Windows Version von Excel von dort immer den Power Query Editor. Die Version für MacOS macht das nicht. Um Änderungen an einer Abfrage vorzunehmen, muss die Abfrage in Power Query über das Kommando Daten abrufen geöffnet werden (s. Abbildung 7.13).\n\n\n\n\n\n\nAbbildung 7.13: Power Query unter MacOS starten",
    "crumbs": [
      "Datenquellen",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Daten importieren</span>"
    ]
  },
  {
    "objectID": "kapitel/variablen/kapitel.html",
    "href": "kapitel/variablen/kapitel.html",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "",
    "text": "8.1 Variablen\nExcel kennt keine strikte Unterscheidung zwischen Konstanten und Variablen. Grundsätzlich sind alle Werte in Excel Konstanten, weil direkt eingegebene oder durch eine Formel erzeugte Werte nicht durch andere Formel verändert werden können.\nIst ein Arbeitsblatt gesperrt, sind die Werte auf diesem Arbeitsblatt unveränderlich und verhalten sich wie Konstanten. Ist ein Arbeitsblatt nicht gesperrt, dann verhalten sich die Werte wie Variablen.\nBezeichner unterliegen in Excel gewissen Beschränkungen.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Variablen, Funktionen und Operatoren</span>"
    ]
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#sec-variablen",
    "href": "kapitel/variablen/kapitel.html#sec-variablen",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "",
    "text": "Warnung\n\n\n\nIn Excel lassen sich Zellen und Bereiche sperren. Damit lassen sich die Werte wie Konstanten behandeln. Diese Sperre ist Teil der Formatierung einer Zelle und muss für das gesamte Arbeitsblatt festgelegt werden. Die Sperre kann nicht für einzelne Zellen oder Bereiche festgelegt werden.\nDie Sperre eines Arbeitsblatts wird im Menuband Überprüfen mit dem Kommando Blatt schützen aktiviert. Richten Sie bei diesem Kommando kein Passwort ein.\n\n\n\n\n\nBezeichner dürfen nur aus Buchstaben, Zahlen, Dollarzeichen, Punkten und Unterstrichen (_) bestehen.\nBezeichner dürfen keine bestehenden Funktionsnamen sein.\nBezeichner dürfen keine gültigen Adressen im A1-Format sein.\nBezeichner dürfen keine gültigen Adressen im Z1S1-Format sein.\n\n\nBeispiel 8.1 (Ungültiger Bezeichner) Der Bezeichner x1 ist ungültig, weil dieser identisch mit der Adresse X1 wäre. Wird Bezeichner um einen Unterstrich zu x_1 erweitert, dann gibt es keine Kollision mit der Adresse mehr und der Bezeichner ist gültig.\n\n\n8.1.1 Dynamische Bereiche\nFormeln können mehr als einen Wert verarbeiten und mehr als einen Ergebnis liefern. Solche Formeln müssen nur in die linke obere Ecke eines Bereichs eingetragen werden. Excel erkennt automatisch, dass die Formel auf einen Bereich angewendet werden soll und erzeugt die entsprechende Formel für alle Zellen des Bereichs. Das Ergebnis einer solchen Formel ist ein dynamischer Bereich.\n\nDefinition 8.1 Vektorisieren heisst das Erzeugen eines dynamischen Bereichs aus einem statischen Bereich.\n\n\nBeispiel 8.2 (Vektorisieren eines statischen Bereichs)  \n=A1:A10\n\nIm Gegensatz zu einem normalen Bereich, ist bei einem dynamischen Bereich nur die linke obere Zelle bekannt. Um trotzdem alle Zellen eines solchen Bereichs zu adressieren, wird die Gatter- (#) Notation verwendet.\nDas Beispiel 8.2 erzeugt einen Bereich mit 10 Zellen. Die Formel wird in die linke obere Zelle des Bereichs eingetragen. Die Formel wird z.B. in die Zelle B1 eingetragen. Anschliessend können die Werte im Bereich B1:B10 über die Gatter-Notation adressiert werden: B1#.\nDer Vorteil des Vektorisierens ist, dass der Bereich durch das Einfügen neuer Zeilen vergrössert werden kann, ohne dass die nachfolgenden vektorisierten Formeln angepasst werden müssen.\n\n\n\n\n\n\nPraxis\n\n\n\nWeil Tabellen automatisch vektorisiert werden, ist es einfacher Werte in einer Tabelle zu erfassen bzw. als Tabelle zu importieren (s. Kapitel 7) und anschliessend über die Tabellenadressierung auf die Werte zu verweisen.\n\n\n\n\n\n\n\n\nMerke\n\n\n\nTabellenadressierungen auf eine Spalte oder einen Spaltenberech sind immer Vektorisiert.\n\n\n\n\nBeispiel 8.3 (Vektorisieren von Tabellenspalten)  \n= Tabelle1[Spalte1]\nDiese Formel vektorisiert die Spalte mit dem Namen Spalte1 aus der Tabelle Tabelle1. Angenommen, dass diese Formel in Zelle A1 des aktuellen Arbeitsblattes steht, dann kann anschliessend auf den Vektor über die Gatter-Notation zugegriffen werden:\n=A1#\n\n\n\n\n8.1.2 Benannte Bereiche\nIm Funktionsbalken wird ganz links die Adresse der aktuellen Zelle angezeigt. Wenn in dieses Feld geklickt wird, dann kann der Adresse ein Name zugewiesen werden. Auf diese Weise kann eine Zelle oder ein Bereich benannt werden. Der Name eines Bereichs darf nur einmal in einer Arbeitsmappe existieren. Dafür kann in jeder Zelle der Arbeitsmappe dieser Namen als Adresse verwendet werden. Dazu ist es nicht notwendig, den die genaue Arbeitsblatt- und Zelladresse zu kennen.\nVerweist ein benannter Bereich mit einer Zelle auf den Anfang eines dynamischen Bereichs, dann kann der gesamte dynamische Bereich mit der Gatter-Notation referenziert werden.\nAuf diese Weise lassen sich oft adressierte Zellen oder Bereiche benennen. Dadurch kann die Adresse für Verwendung in Formeln abstrahiert werden.\nDie Verwendung von benannten Bereichen wird weiter vereinfacht, dass bei der Eingabe von Formeln die Namen der benannten Bereiche als Vorschlag angezeigt werden.\n\nBeispiel 8.4 (Adressierung eines dynamischen benannten Bereichs)  \n=umsatz#\n\nBenannte Zellen helfen, auf wichtige Zellen in einer Arbeitsmappe zuzugreifen.\n\n\n\n\n\n\nMerke\n\n\n\nEin benannter Bereich entspricht einer Variablen in anderen Programmiersprachen.\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nEine benannte Zelle oder ein benannter Bereich sind immer absolut referenziert.\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nWenn einem benannten Bereich Zellen hinzugefügt werden, dann wird der benannte Bereich um diese Zellen erweitert.\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nEine Tabelle ist ein spezieller benannter Bereich, der als Ganzes oder in Teilen referenziert werden kann (s. Abschnitt 6.4.2).",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Variablen, Funktionen und Operatoren</span>"
    ]
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#sec-funktionen",
    "href": "kapitel/variablen/kapitel.html#sec-funktionen",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.2 Funktionen",
    "text": "8.2 Funktionen\nExcel kann nur durch Funktionen und Operatoren programmiert werden.\nExcel hat wenige vordefinierte Operatoren, wobei die Operatoren keine direkte Entsprechung als Funktion haben. Die einzige Ausnahmen sind der Potenzoperator (^) und der Textverkettungsoperator (&). Der Potenzoperator ist funktional gleich mit der POTENZ()-Funktion. Der Textverkettungsoperator entspricht der Funktion TEXTKETTE() mit zwei Argumenten.\n\n\n\n\n\n\nMerke\n\n\n\nDie mit Excel möglichen Programme sind durch die Operatoren und die vordefinierten Funktionen beschränkt.\n\n\nExcel Kommandos können nur durch Interaktion mit den Excel Menus oder Dialogen ausgeführt werden. Diese Funktionalität steht für die Progammierung oft nicht zur Verfügung.\n\n\n\n\n\n\nMakros\n\n\n\nNeben den Funktionen und Kommandos existieren in Excel noch Makros. Mit Makros können neue Kommandos und Funktionen programmiert werden. Makros folgen aber nicht den Regeln von Formeln, weil sie in einer anderen Programmiersprache geschrieben werden.\nMakros unterliegen nicht den Einschränkungen von Excel-Funktionen. Diese Freiheit ist gleichzeitig ein Fluch, denn Makros sind ein Sicherheitsrisiko und Excel präsentiert entsprechende Warnungen, wenn Makros in einer Arbeitsmappe gefunden wurde.\nAktuelle Bestrebungen von Microsoft zielen darauf ab, Makros langfristig durch Funktionen zu ersetzen. Ein Teil dieser Bestrebungen ist die Einführung von LAMBDA()-Funktionen (s. Abschnitt 8.5).\n\n\n\n\n\n\n\n\nMerke\n\n\n\nExcel hat keine Identitätsfunktion. Die Identitätsfunktion wird durch eine Formel simuliert, die nur eine Adresse enthält. Solche Formeln werden für das Vektorisieren (Definition 8.1) von Bereichen eingesetzt.\n\n\n\n8.2.1 Generatoren in Excel\nExcel hat zwei Generatorfunktionen:\n\nDie SEQUENZ()-Funktion\nDie ZUFALLSMATRIX()-Funktion\n\nBeide Generatoren erfordern die Anzahl der Zeilen und Spalten, für die Werte generiert werden sollen. Soll nur ein Spaltenvektor erzeugt werden, muss nur die Anzahl der Zeilen angegeben werden.\nDie SEQUENZ()-Funktion erzeugt eine Sequenz von Werten ausgehend vom ersten Wert (Anfang). Die Schrittweite legt die Abstände zwischen den einzelnen Werten fest. Standardmässig ist die Schrittweite mit 1 festgelegt.\n\n\n\n\n\n\nMerke\n\n\n\nWird die Schrittweite mit 0 festgelegt, dann wird der Anfangswert für die angegebene Anzahl von Spalten und Zeilen wiederholt.\n\n\nDie Funktion ZUFALLSMATRIX() erzeugt Zufallswerte in einem vorgegebenen Intervall. Diese Funktion kann reelle Zahlen oder ganze Zahlen generieren. Der Wertebereich der generierten Zahlen kann durch einen Minimal- und einem Maximalwert eingeschränkt werden. Wird kein Minimal- und Maximalwert angegeben, dann werden Werte im Intervall 0 &lt; z &lt; 1 generiert. Werden Ganzzahlen für dieses Intervall angefordert, dann werden die Werte 0 und 1 erzeugt.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Variablen, Funktionen und Operatoren</span>"
    ]
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#substitution",
    "href": "kapitel/variablen/kapitel.html#substitution",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.3 Substitution",
    "text": "8.3 Substitution\nExcel kennt zwei Formen der Substitution.\n\nDie Substitution über Funktionspfade\nDie Substitution mit der Funktion LET()\n\nBeide Substitutionsformen sind fast gleichwertig. Funktionspfade eigenen sich besonders gut für die Entwicklung von und zur Fehlersuche in komplexen Formeln. LET() erlaubt es, mehrere Arbeitsschritte effizient in einer Formel zusammenzufassen.\n\n8.3.1 Substitution über Funktionspfade\nEine komplexe Operation lassen sich in Excel durch Substitution über Funktionspfade vereinfachen.\n\nDefinition 8.2 Ein Funktionspfad sind Formeln, die sich über ihre Adressen aufeinander beziehen.\n\nBei einem Funktionspfad werden die substituierten Funktionen als Formeln in separate Zellen geschrieben. Die Adresse der jeweiligen Formel wird als Substitution für die Funktion eingesetzt. Sind die Formeln in einem benannten Bereich, dann kann der Name des Bereichs zur Substitution verwendet werden.\n\n\n\n\n\n\nAbbildung 8.1: Funktionspfad\n\n\n\nFunktionspfade können mithilfe des Kommandos Spur zum Vorgänger im Menü Formeln sichtbar gemacht werden (Abbildung 8.1).\n\n\n\n\n\n\nPraxis\n\n\n\nUm komplexe Formeln in bestehenden Arbeitsmappen zu verstehen, hilft das Zerlegen dieser Formeln in Funktionspfade. Dabei kann eine tabellarische Organisation helfen, wiederkehrende Operationen leichter zu erkennen.\n\n\n\n\n8.3.2 Substitution mit LET()\nExcels LET()-Funktion erlaubt das Vereinfachen komplizierter Formeln durch Variablen. Diese Variablen existieren nur im Kontext der LET()-Funktion und können nicht ausserhalb dieser Funktion verwendet werden.\nEine Variable in der LET()-Funktion entspricht einer Substitution eines Teilausdrucks einer Formel.\n\nBeispiel 8.5 (LET()-Funktion zur Substitution)  \n=LET(\n    Daten; 'Unbearbeitete Daten'!A:F;\n    DatenFeld; INDEX(\n        Daten;\n        sequenz(ZEILEN(Daten));\n        sequenz(1; SPALTEN(Daten))\n      ); \n    WENN(ISTLEER(DatenFeld);#NV;DatenFeld)\n )\n\nIn Beispiel 8.5 wird der referenzierte Bereich und der Aufruf der INDEX() substituiert. Die Substitution wird durch die Variablen Daten und DatenFeld realisiert.\n\nBeispiel 8.6 (Formel ohne Substitution)  \n=WENN(ISTLEER(INDEX(\n        'Unbearbeitete Daten'!A:F;\n        sequenz(ZEILEN('Unbearbeitete Daten'!A:F));\n        sequenz(1; SPALTEN('Unbearbeitete Daten'!A:F))\n      ));\n      #NV;\n      INDEX(\n        'Unbearbeitete Daten'!A:F;\n        sequenz(ZEILEN('Unbearbeitete Daten'!A:F));\n        sequenz(1; SPALTEN('Unbearbeitete Daten'!A:F))\n      )\n )\n\nDie beiden Beispiele veranschaulichen, wie mit der LET()-Funktion mehr als eine Substitution umgesetzt wird, um eine komplexe Formel in überschaubare Teilschritte zu zerlegen und so stark zu vereinfachen.\n\n\n\n\n\n\nPraxis\n\n\n\nWird eine Funktion in einer Formel mit den gleichen Parametern mehrfach aufgerufen, dann sollte diese Funktion immer mit LET() substituiert werden. Substituierte Berechnungen werden nur einmal für die Substitution durchgeführt und anschliessend wird nur das Ergebnis verwendet. Nicht substituierte Funktionen werden bei jedem Vorkommen neu ausgeführt.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Variablen, Funktionen und Operatoren</span>"
    ]
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#funktionsketten",
    "href": "kapitel/variablen/kapitel.html#funktionsketten",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.4 Funktionsketten",
    "text": "8.4 Funktionsketten\nFunktionsketten werden in Excel über Substitutionen erzeugt. Gerade bei Matrizen und anderer Transformationen von Datenstrukturen ist die Verwendung von Funktionspfaden aus zwei Gründen unhandlich:\n\nWenn die Ergebnisse mehrerer Arbeistsschritte auf einem Arbeitsblatt dargestellt werden, wird die Übersichtlichkeit behindert.\nWeil Funktionspfade separate Formeln verwenden werden die Ergebnisse für jede Formel serialisiert, was nicht immer zu den erwarteten Ergebnissen führt.\n\nWeil Excel keine Operatoren für die Funktionsverkettung bereitstellt, werden Funktionsketten immer mithilfe der Funktion LET() erzeugt.\n\n8.4.1 LET() und leere Zellen\nNormalerweise werden leere Zellen als Ergebnis einer Funktion durch 0 ersetzt. Dieses Konvertierung findet erst bei der Darstellung des Ergebnisses statt. Innerhalb einer Funktionskette werden leere Zellen als leere Zellen weitergereicht, solange keine Aggregation vorgenommen wird. Es ist deshalb möglich in einer Funktionskette eine Entscheidung mit ISTLEER() für den Fall einer leeren Zelle zu treffen.\nEine Excel-Operation muss einen Wert als Ergebnis einer Formel haben. Wird ein nicht vorhandener Wert (d.h. leere Zelle) in einem Ergebnis einer Formel gefunden, dann wird dieser Wert automatisch in den Wert 0 konvertiert. Diese Umwandlung passiert jedoch erst nachdem die Operation abgeschlossen ist und Excel das Ergebnis auf dem Arbeitsblatt darstellt.\nDieses Verhalten hat zur Folge, dass solange eine Operation nicht abgeschlossen ist, die nicht vorhandenen Werte in ihrer ursprünglichen Form erhalten bleiben. Es ist also möglich undefinierte Werte mit ISTLEER() zu prüfen.\nDie ursprünglichen Daten können unvollständig sein und enthalten dann leere Zellen an den entsprechenden Zellen. Diese fehlenden Werte als 0 darzustellen, kann zu verzerrten Ergebnissen führen. Deshalb sollten solche Werte mit dem Fehler #NV (lies: Nicht Vorhanden) markiert werden. Dieser Fehlerwert wird nicht automatisch in den Wert 0 umgewandelt, so dass die fehlenden Werte korrekt berücksichtigt werden können.\nDiese Umwandlung nutzt aus, dass Excel leere Zellen als Ergebnis von Funktionen zulässt, aber nicht als Ergebnis von Formeln. Entsprechend kann das folgende Funktionsmuster verwendet werden.\nDie beiden Vektoren G1# und H1# sind Hilfsvektoren, die Sequenzen für die Zeilen- und Spaltenindizes der Datenstruktur A:F enthalten.\nDer logische Ausdruck prüft, ob ein Feld mit dem Index G1# und H1# im Stichprobenobjekt leer ist. Falls das Feld in den unbearbeiteten Daten leer ist, dann wird der Wert #NV als Ergebnis zurückgegeben. Sonst soll der Wert im Feld übergeben.\nIn dieser Operation wird die Funktion INDEX() zwei Mal mit den gleichen Parametern aufgerufen. Das ist unpraktisch, weil die Operation an zwei Stellen angepasst müsste, wenn die Daten mehr oder weniger Spalten haben. Besser wäre es, wenn das Zwischenergebnis der INDEX()-Funktion aus der Operation herausgelöst wird und über eine Funktionsverkettung eingebunden wird. Das ist aber nicht möglich, weil Excel bei diesem Zwischenschritt die fehlenden Werte in 0 ändert, sodass anschliessend der logische Ausdruck immer FALSCH liefern würde.\nMittels der LET() Funktion wird das Ergebnis dieses Zwischenschritts in einer temporären Variablen gespeichert. Gegenüber der normalen Funktionsverkettung durch Funktionspfade hat diese Strategie den Vorteil, dass für Excel die Operation nicht abgeschlossen ist und deshalb die fehlenden Werte noch nicht in den Wert 0 umgewandelt werden. Der logische Ausdruck in der WENN()-Funktion kann also WAHR ergeben, wenn in den Daten ein Wert fehlt. Ausserdem muss die Indizierung für eine Position nur einmal durchgeführt werden, was bei komplexen Formeln die Übersichtlichkeit erhöht und die Ausführung beschleunigt.\n\n\n\n\n\n\nWarnung\n\n\n\nDie Namen in der LET() unterliegen den gleichen Beschränkungen, wie alle anderen Bezeichner (Abschnitt Kapitel 8.1).\n\n\nDie ursprüngliche Formel lässt sich also dahingehend vereinfachen, dass der Aufruf der INDEX()-Funktion “ausgeklammert” und in der Hilfsvariablen Feld gespeichert wird.\nDaraus ergibt sich die Lösung als Funktionskette.\n=LET(Feld; INDEX('Unbearbeitete Daten'!A:F;A2#;B1#); \n     WENN(\n        ISTLEER(Feld);\n        #NV;\n        Feld\n     )\n )\nDiese Lösung entspricht ungefähr der Funktionskette Formel 8.1.\n\nIndex() \\triangleright Wenn()\n\\tag{8.1}\nDamit wird der Aufruf der WENN()-Funktion vereinfacht, weil nur noch die Hilfsvariable Feld übergeben müssen. Diese Variable enthält die Daten für die Funktionsverkettung, so dass eine zusätzliche Arbeitsblattadresse nicht notwendig ist.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Variablen, Funktionen und Operatoren</span>"
    ]
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#sec-lambda-funktionen",
    "href": "kapitel/variablen/kapitel.html#sec-lambda-funktionen",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.5 Funktionen selbst definieren",
    "text": "8.5 Funktionen selbst definieren\nIn Excel können eigene Funktionen mit der Funktion LAMBDA() erzeugt werden. Die LAMBDA()-Funktion erzeugt die Funktion aus ihren Parametern. Dabei ist der letzte Parameter immer der Funktionskörper. Die restlichen Parameter sind die Parameter der Funktion. Es können max 253 Parameter angegeben werden, wobei keine optionalen oder vorbelegten Parameter möglich sind. Beispiel 8.7 zeigt eine einfache Funktionsdefinition mit zwei Parametern.\n\nBeispiel 8.7 (Funktionsdefinition mit zwei Parametern ohne Ausführung)  \n= LAMBDA(a; b; a + b)\n\n\n\n\n\n\n\nWarnung\n\n\n\nMit Excels LAMBDA()-Funktion können nur Funktionen durch Verkettung anderer Funktionen erzeugt werden.\n\n\nFür Excel sind Funktionen kein darstellbarer Datentyp. Wird also eine Funktion mit LAMBDA() definiert, ohne dass sie unmittelbar ausgeführt wird, zeigt Excel den Fehler #KALK! an. Dieser Fehler kann dadurch vermieden werden, indem die Funktion unmittelbar ausgeführt wird (s. Beispiel 8.8).\n\nBeispiel 8.8 (Funktionsdefinition mit zwei Parametern mit sofortiger Ausführung)  \n= LAMBDA(a; b; a + b)(1;2)\n\n\n\n\n\n\n\nWarnung\n\n\n\nDer Funktionskörper muss nicht alle Parameter verwenden. Wird eine Funktion aufgerufen, dann müssen alle Parameter angegeben werden, selbst wenn diese im Funktionskörper nicht verwendet werden.\n\n\n\n8.5.1 Map-Reduce und LAMBDA()\nWeil eine mit LAMBDA() erzeugte Funktion als Formel direkt ausgeführt werden muss, ergibt sich kein Vorteil gegenüber normalen Excel-Formeln. Die Funktion wird jedoch zum Erstellen von Callbacks benötigt. Die Hauptanwendung sind Operationen, die mit jedem Wert eines Bereichs durchgeführt werden sollen. Weil Excel normalerweise keine Schleifen zulässt, müssen solche Operationen über die Logikfunktionen MAP(), NACHZEILE(), NACHSPALTE(), REDUCE() und SCAN() erzeugt werden.\nAlle Map-Funktionen erwarten als ersten Parameter einen Bereich mit Werten und als letzten Parameter eine Funktionsdefinition mit LAMBDA().\n\nMAP() erzeugt eine Schleife, welche den Callback für jedes Element genau einmal aufruft. Es ist möglich, mehrere Bereiche anzugeben. Die Parameteranzahl der Callback muss der Anzahl der angegebenen Bereiche entsprechen.\nNACHSPALTE() erzeugt eine Schleife, die eine Funktion für jede Spalte eines Bereichs aufruft. Der Callback darf nur einen Parameter haben. Der Parameter enthält eine Liste mit allen Werten der aktuellen Zeile.\nNACHZEILE() erzeugt eine Schleife, die eine Funktion für jede Zeile eines Bereichs aufruft. Der Callback darf nur einen Parameter haben.\n\nMAP(), NACHSPALTE() und NACHZEILE() behandeln die einzelnen Durchläufe der Schleife als unabhängig. Im Gegensatz dazu sind die Durchläufe einer REDUCE() oder SCAN()-Schleife immer vom voherigen Durchlauf abhängig. REDUCE() und SCAN() erfordern als ersten Parameter einen Initialwert, der als Argument für den ersten Aufruf des Callbacks verwendet wird.\n\nREDUCE() erzeugt eine Schleife, die für jedes Element eines Bereichs den Callback ausführt. Diese Funktion erhält als ersten Parameter, das Callback-Ergebnis des vorherigen Durchlaufs und als zweiten Parameter. Das Ergebnis von REDUCE() ist das Ergebnis des letzten Aufrufs der Schleifenfunktion.\nSCAN() ist eine Variante von REDUCE(). Während REDUCE() nur das letzte Ergebnis der Callbacks ausgibt, erzeugt SCAN() einen Vektor mit allen Ergebnissen der Callback-Aufrufe.\n\n\n\n\n\n\n\nWarnung\n\n\n\nDie Map-Reduce-Funktionen dürfen nur einzelne Werte erzeugen. Datenstrukturen sind auch dann nicht erlaubt, wenn sie alle die gleiche Länge haben und sich in einen rechteckigen Bereich zusammenfügen liessen. Diese Beschränkung gilt auch, wenn die Funktionsergebnisse als Zwischenschritt an eine Kombinationsfunktion für Vektoren (z.B. VSTAPELN()) verknüpft werden. Erzeugt ein Callback eine Datenstruktur, dann erzeugt die jeweilige Funktion den Fehlerwert #KALK!.\nEinzig die Funktion REDUCE() darf Datenstrukturen erzeugen; weil diese Funktion nur ein Ergebnis haben kann.\nDiese Einschränkung bedeutet, dass die Funktionen NACHSPALTE() und NACHZEILE() die Identitätsfunktion nicht als Callback akzeptieren.\n\n\n\n\n8.5.2 Index-Schleifen mit MATRIXERSTELLEN()\nWährend die Funktionen der Map-Reduce-Familie Werte voraussetzen, ist dies nicht immer möglich. Die Funktion MATRIXERSTELLEN() erzeugt eine Schleife über zwei Iteratoren, für die Dimensionen der gewünschten Matrix. Der Callback für die Funktion erfordert deshalb 2 Parameter für die beiden Indizes.\n\n\n\n\n\n\nPraxis\n\n\n\nDie Funktion MATRIXERSTELLEN() kann meistens durch das äussere Produkt (Kapitel 12) ersetzt werden.\n\n\nDer Callback für MATRIXERSTELLEN() darf nur zwei Parameter haben, denen die aktuellen Index-Werte zugewiesen werden. Daraus ergibt sich, dass im Funktionskörper nur diese beiden Parameter bereitgestellt werden. Komplexere Anwendungen lassen sich mit Closures erzeugen. Dazu wird eine Funktion mit LAMBDA() erzeugt, die zusätzliche Werte oder Datenstrukturen als Parameter unterstützt. Diese Funktion erzeugt anschliessend den Callback für MATRIXERZEUGEN(). Der Callback ist also ein Closure der erzeugenden Funktion. Dadurch kann der Callback die Werte und Datenstrukturen der erzeugenden Funktion beim Aufruf durch die Funktion MATRIXERZEUGEN() ebenfalls verwenden (s. Beispiel 8.9).\n\nBeispiel 8.9 (Matrix mit Closure erstellen) Im Bereich A1:A4 stehen beliebige Zeichenketten.\n=MATRIXERSTELLEN(5;3;\n    LAMBDA(namen;\n           LAMBDA(a;b; \n                  ZEILENWAHL(namen; \n                             REST(a+b; \n                                  ZEILEN(namen))+1)\n           )\n    )(A1:A4)\n )\n\n\n\n8.5.3 Neue Funktionen festlegen\nNeben Schleifen können mit LAMBDA() neue Funktionen erzeugt werden. Dazu muss in einem Arbeitsblatt ein Name mit der Funktionsdefinition erzeugt werden. Namen werden über das Menüband Formeln mit dem Kommando Namen definieren erzeugt. Dieses Kommando öffnet einen Dialog, über welchen ein Name definiert werden kann(Abbildung 8.2). In diesem Dialog müssen die beiden Felder Name und Bezieht sich auf ausgefüllt werden.\nDer Name ist der Bezeichner der neuen Funktion. Hier dürfen keine Namen vorhandener Funktionen oder benannter Bereiche verwendet werden. Das Feld Bezieht sich auf muss eine LAMBDA-Formel mit der Funktionsdefinition beinhalten. Als Bereich sollte immer Arbeitsmappe ausgewählt sein, weil sonst die Funktion auf ein einziges Arbeitsblatt beschränkt wäre. Zur Dokumentation sollte im Feld Kommentar zusätzlich eine Kurzbeschreibung der Funktion angegeben werden. Leider zeigt Excel diesen Kommentar nicht als Kurzhilfe für den Funktionsnamen an.\n\n\n\n\n\n\nAbbildung 8.2: Funktionsdefinition mit LAMBDA()\n\n\n\nNachdem eine Funktion einem Namen zugewiesen wurde, kann dieser Name wie jede andere Funktion in Formeln verwendet werden (Abbildung 8.3).\n\n\n\n\n\n\nAbbildung 8.3: Eigene Funktion anwenden\n\n\n\nAls Funktionskörper können beliebige Excel Operationen vorkommen. Es bietet sich jedoch an, für komplexere Funktionen den Funktionskörper mit LET() einzuleiten. Dadurch lassen sich einzelne Arbeitsschritte leichter isolieren und verketten.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Variablen, Funktionen und Operatoren</span>"
    ]
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html",
    "href": "kapitel/zeichenketten/kapitel.html",
    "title": "9  Zeichenketten",
    "section": "",
    "text": "9.1 Die leere Zeichenkette\nBisher wurden Zeichenketten als Werte behandelt. In diesem Abschnitt geht es darum, wie Zeichenketten gesäubert, bearbeitet und aufgeteilt werden.\nEin besonderer Fall ist die leere Zeichenkette. Die leere Zeichenkette wird oft als Platzhalter genutzt. Die leere Zeichenkette ist das neutrale Element für die Verknüpfung von Zeichenketten mit TEXTKETTE() oder TEXTVERKETTEN().\nIn Excel lässt sich die leere Zeichenkette von der leeren Zelle nur unterscheiden, indem die Formel betrachtet wird oder die Zelle mit ISTLEER() (FALSCH) und ISTTEXT() (WAHR) überprüft wird.\nDie leere Zeichenkette wird in Excel nur als Funktionsparameter durch doppelte Anführungszeichen eingerahmt. Soll eine leere Zeichenkette als Wert in eine Zelle eingegeben werden, dann ist ein einfacher Apostroph (’) einzugeben.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Zeichenketten</span>"
    ]
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#die-leere-zeichenkette",
    "href": "kapitel/zeichenketten/kapitel.html#die-leere-zeichenkette",
    "title": "9  Zeichenketten",
    "section": "",
    "text": "Beispiel 9.1 (Leere Zeichenkette in einer Excel-Formel)  \n=WENN(1 = 1; \"\"; \"Fehler\")\n\n\n\n\n\n\n\nMerke\n\n\n\nWenn in Excel eine leere Zeichenkette als Wert in eine Zelle eingetragen werden soll, dann wird ein einfaches Anführungszeichen als Wert eingegeben.\n\n\n\n\n\n\n\n\nAbbildung 9.1: Leere Zeichenkette als Zellenwert in Excel",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Zeichenketten</span>"
    ]
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#nicht-druckbare-zeichen",
    "href": "kapitel/zeichenketten/kapitel.html#nicht-druckbare-zeichen",
    "title": "9  Zeichenketten",
    "section": "9.2 Nicht-druckbare Zeichen",
    "text": "9.2 Nicht-druckbare Zeichen\nIn Excel werden die nicht-druckbaren Zeichen für die Darstellung und für Vergleiche entfernt, jedoch werden die nicht-druckbaren Zeichen bei der Länge und beim Extrahieren berücksichtigt. In Excel kann mit der IDENTISCH()-Funktion geprüft werden, ob zwei Zeichenketten die gleiche Symbolfolge beinhalten. .\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nExcel unter Windows stellt nicht-druckbare Zeichen als Kästchen dar, Excel für MacOS zeigt diese Zeichen nicht an.\n\n\nZu den nicht-druckbaren Zeichen gehören auch Leerzeichen, Tabulatoren und Zeilenumbrüche. Diese speziellen nicht-druckbaren Zeichen sind nur erkennbar, wenn sie von druckbaren Zeichen umgeben sind.\nDeutlich wird das an den folgenden Zeichenketten:\n\nHallo\nHal&lt;0x07&gt;lo, wobei das Symbol 0x07 für einen Piepton steht\nHal&lt;0x08&gt;lo, wobei das Symbol 0x08 für einmal Rückwärtslöschen steht.\n\nDiese drei Zeichenketten haben in Excel die Längen 5, 6 und 6. Excel stellt alle drei Zeichenketten als “Hallo” dar. Ausserdem werden die Zeichenketten als gleich ausgewertet.\nExcel entfernt über die Funktion SÄUBERN() alle nicht-druckbare Zeichen aus einer Zeichenkette.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Zeichenketten</span>"
    ]
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#zeichenketten-trennen",
    "href": "kapitel/zeichenketten/kapitel.html#zeichenketten-trennen",
    "title": "9  Zeichenketten",
    "section": "9.3 Zeichenketten trennen",
    "text": "9.3 Zeichenketten trennen\n\n9.3.1 Einzelne Symbole extrahieren\nIn Excel lassen sich die einzelnen Symbole einer Zeichenkette mit der folgenden Formel extrahieren:\n=TEIL(\"Daten und Information\"; \n      SEQUENZ(LÄNGE(\"Daten und Information\"));\n      1)\nDiese Formel hat drei Funktionsaufrufe.\n\nDie Funktion LÄNGE() bestimmt die Anzahl der Symbole in der Zeichenkette.\nMit der Funktion SEQUENZ() werdem alle Positionen der Symbole durchnummeriert.\nMit TEIL(Zeichenkette; Sequenz; 1) wird ein Teil der Zeichenkette extrahiert, wobei für jede Position der Sequenz aus Schritt 2 eine Teilzeichenkette mit der Länge 1 erzeugt wird.\n\n\n\n9.3.2 Zeichenketten vor und nach einem Trenner erhalten\nDie Funktion LINKS() und RECHTS() geben eine Teilzeichenkette mit einer festen Anzahl von Zeichen zurück. Die Funktion LINKS() zählt die Anzahl der Zeichen vom Beginn der Zeichenkette und RECHTS() vom Ende her.\n\nBeispiel 9.2 (Zeichen links bis und mit der 5. Position zurückgegeben)  \n= LINKS(\"Daten und Information\"; 5)\n\nWeil RECHTS() vom Ende her zählt, kann nicht die gleiche Position wie bei LINKS() verwendet werden. Dazu muss die Position von der Gesamtlänge der Zeichenkette abgezogen werden (s. Beispiel 9.3).\n\nBeispiel 9.3 (Zeichen rechts von der 10. Position zurückgegeben)  \n= RECHTS(\n    \"Daten und Information\"; \n    LÄNGE(\"Daten und Information\")-10)\n\nEtwas eleganter arbeiten die beiden Funktionen TEXTVOR() und TEXTNACH(). Diese Funktionen suchen nach einer Teilzeichenkette und ergeben die Zeichen vor bzw. nach dieser Zeichenkette. Ein zusätzlicher Parameter ermöglicht die Suche solange zu wiederholen, bis die gesuchte Zeichenkette genau so oft gefunden wurde.\n\nBeispiel 9.4 (TEXTVOR() vor dem ersten Treffer)  \n= TEXTVOR(\"Daten und Information\"; \" \")\n\n\nBeispiel 9.5 (TEXTNACH() ab dem zweiten Treffer)  \n= TEXTNACH(\"Daten und Information\"; \" \"; 2)\n\nUm einen Wert zwischen zwei Treffern zu extrahieren, lassen sich die beiden Funktionen verketten. Diese Technik bietet sich immer dann an, wenn ein Wert zwischen zwei unterschiedlichen Markierungen extrahiert werden soll\n\nBeispiel 9.6 (Text zwischen zwei unterschiedlichen Teilketten extrahieren)  \n= TEXTVOR(TEXTNACH(\"Daten und Information\"; \"ten \"); \" Info\")\n\n\n\n9.3.3 Festkodierte Werte trennen\nEine festkodierte Datenstruktur ist eine Zeichenkette, die Werte an festgelegten Positionen mit konstanten Längen enthält. Diese Daten lassen sich mit der Funktion TEIL() extrahieren.\nDie Funktion hat drei Argumente:\n\nDie Zeichenkette, aus der die Daten extrahiert werden sollen.\nDie Position, an der die Daten beginnen.\nDie Länge der Daten als Anzahl von Symbolen.\n\n\n\nBeispiel 9.7 (IBAN in Land, Prüfziffer, Bankkennung und Kontonummer trennen) Die IBAN ist eine festkodierte Datenstruktur. Die IBAN enthält die Länderkennung, die Prüfziffer, die Bankkennung und die Kontonummer. Die Länge der einzelnen Daten ist konstant und die Position der Felder ist festgelegt.\n\n\n\nFeld\nPosition\nLänge\n\n\n\n\nLand\n1\n2\n\n\nPrüfziffer\n3\n2\n\n\nBankkennung\n5\n5\n\n\nKontonummer\n10\nLänge der IBAN - 10\n\n\n\nDie (ungültige) IBAN CH12BANK1002135135 kann mit der TEIL()-Funktion in die einzelnen Felder zerlegt werden. Dazu müssen zuerst die Positionen und Längen der Felder erstellt werden. Dazu werden die Positionen und Längen der Felder untereinander geschrieben.\n\n\n\nA\nB\nC\nD\n\n\n\n\n1\n3\n5\n10\n\n\n2\n2\n5\n= LÄNGE(IBAN_Nummer) - 10\n\n\n\nDiese Werte werden als Vektoren der Funktion TEIL() übergeben.\n= TEIL(IBAN_Nummer; A1:D1; A2:D2)\nDie Funktion TEIL() gibt die einzelnen Felder als Vektor zurück. Das Ergebnis ist {\"CH\"; \"12\"; \"BANK1\"; \"002135135\"}. Hier muss berücksichtigt werden, dass die einzelnen Felder weiterhin Zeichenketten sind.\n\n\n\n\n9.3.4 Zeichenketten mit einem Separator trennen\nSind Werte in einer Zeichenkette durch einen Separator getrennt, dann lassen sich die Werte mit der Funktion TEXTTEILEN(). Die Funktion kann eine Zeichenkette entlang von zwei Trennzeichen trennen. Dabei erzeugt die Funktion eine Matrix, wobei die Spalten durch den ersten Separator und die Zeilen durch den zweiten Separator bestimmt werden.\n\nBeispiel 9.8 (TEXTTEILEN() mit festem Trennzeichen)  \n= TEXTTEILEN(\"Daten und Information\", \" \")\n\n\n\n\n\n\n\nWichtig\n\n\n\nDie Funktion TEXTTEILEN() kann nur auf einen Wert angewandt werden. Wird ein Zeichenkettenvektor der Funktion übergeben, wird aus jeder Zeichenkette immer nur der erste Wert getrennt und als Ergebnis ausgegeben. Excel verhindert so, dass durch das Teilen mehrerer Zeichenketten die Ergebnisse einen nicht eindeutig grossen rechteckigen Bereich mit Datentyp Zeichenkette erzeugen könnten.\n\n\nDieses Problem wird durch einen Trick umgangen: Dazu wird ein zweiter Separator gewählt, der nicht in den Daten vorkommt und sich vom ursprünglichen Separator unterscheidet. Existiert bereits ein Zeilentrennzeichen in den Daten, wird dieses als zweiter Separator verwendet. Anschliessend werden alle Zeichenketten mit diesem zweiten Separator als Trennzeichen mit TEXTVERKETTEN() verkettet. Abschliessend wird die gesamte Zeichenkette mit dem ursprüngliche Separator als Spalten- und dem zweiten Separator als Zeilentrennzeichen getrennt. Dabei werden alle nicht vorhandenen Werte in einer Zeile durch #NV angezeigt.\nBeispiel 9.9 trennt einen Zeichenkettenvektor mit Werten, die durch ein Leerzeichen getrennt sind. Alle Werte sind Buchstaben oder Ziffern, aber keine Satzzeichen. Deshalb kann das Komma (,) als Zeilentrennzeichen verwendet werden. Damit der Fehlerwert #NV nachfolgende Operationen nicht behindert, wird dieser durch die leere Zeichenkette ersetzt.\n\nBeispiel 9.9 (Einen Zeichenkettenvektor entlang eines Trennzeichens teilen.)  \n=WENNFEHLER(\n    TEXTTEILEN(\n        TEXTVERKETTEN(\",\";; Zeichenketten); \n        \" \"; \n        \",\"); \n    \"\"\n)",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Zeichenketten</span>"
    ]
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#suchen-und-ersetzen",
    "href": "kapitel/zeichenketten/kapitel.html#suchen-und-ersetzen",
    "title": "9  Zeichenketten",
    "section": "9.4 Suchen und Ersetzen",
    "text": "9.4 Suchen und Ersetzen\nEine wichtige Operation für Zeichenketten ist das Suchen-und-Ersetzen. Das Suchen-und-Ersetzen lässt sich als eine spezielle Technik zur Mustererkennung vorstellen. Dabei steht eine Anwendung im Vordergrund: Die Korrektur und Vereinheitlichung von Zeichenketten. Anstatt solche Daten umständlich über eine Benutzeroberfläche zu korrigieren, sollte das Bereinigen von Zeichenketten besser automatisch erfolgen. Excel stellt dazu die Funktion WECHSELN() zur Verfügung. Diese Funktion ersetzt entweder alle Vorkommnisse einer Teilzeichenkette oder nur ihr n-tes Auftreten.\n\nBeispiel 9.10 (Alle Vorkommnisse einer Zeichenkette ersetzen)  \n= WECHSELN(\n    \"Daten oder Information oder Wahrscheinlichkeit\"; \n    \"oder\"; \n    \"und\")\n\n\nBeispiel 9.11 (Erstes Auftreten einer Zeichenkette ersetzen)  \n= WECHSELN(\n    \"Daten oder Information oder Statistik\"; \n    \"oder\"; \n    \"und\"; \n    1)\n\n\n9.4.1 Löschen von Teilzeichenketten\nTeilzeichenketten lassen sich löschen, indem die fragliche Zeichenkette durch die leere Zeichenkette ersetzt wird.\n\nBeispiel 9.12 (Teilzeichenkette entfernen)  \n= WECHSELN(\"Daten und Information\"; \"und\"; \"\")\n\n\n\n9.4.2 Zeichenketten durch Ersetzungen vereinheitlichen\nBevor das eigentliche Suchen-und-Ersetzen starten kann, sollten die betreffenden Zeichenketten bereinigt werden. Die einfachste Bereinigung ist das Entfernen von überschüssigen Leerzeichen. Dazu dient die Excel Funktion GLÄTTEN(). GLÄTTEN() entfernt alle Leerzeichen am Anfang und Ende einer Zeichenkette. Alle wiederholten Leerzeichen werden mit GLÄTTEN() zu einem einzelnen Leerzeichen zusammengefasst.\nEine zweite häufig verwendete Bereinigung ist die Transformation auf Kleinbuchstaben oder Grossbuchstaben. Hierzu dienen die drei Funktionen GROSS(), GROSS2() und KLEIN(). Die Vereinheitlichung der Schreibweise ist ein wichtiges Werkzeug um Zeichenketten mit unterschiedlichen Schreibweisen zu vereinheitlichen. Beim Bereinigen sollte eine der verfügbaren Varianten gewählt und konsequent für die Vereinheitlichung verwendet werden. Damit wird sicher gestellt, dass alle Ersetzungen unabhängig von der Schreibweise erfolgen.\nFür das eigentliche Ersetzen wird ein Suchvektor und einen Ersetzenvektor erzeugt. Die beiden Vektoren enthalten Paare aus Suchmuster und Ersetzung. Diese Paare sind geordnet und werden nacheinander ausgeführt.\n\n\n\n\n\n\nPraxis\n\n\n\nSatzzeichen sollte immer durch Leerzeichen und nicht durch eine leere Zeichenkette ersetzt werden. Die überzähligen Leerzeichen können anschliessend mit GLÄTTEN() entfernt werden. Dadurch ist gesichert, dass nicht versehentlich Elemente zusammengefügt werden. Nachdem alle Sonderzeichen entfernt wurden, sollte eine Zeichenkette noch einmal von überschüssigen Leerzeichen bereinigt werden.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Zeichenketten</span>"
    ]
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html",
    "href": "kapitel/boolsche-operationen/kapitel.html",
    "title": "10  Aussagenlogik",
    "section": "",
    "text": "10.1 Wahrheitswerte in Excel\nWie im Kapitel Datentypen bereits erwähnt, kennt Excel den Datentyp der Wahrheitswerte. Diese Wahrheitswerte können entweder den Wert WAHR oder FALSCH haben. Eine Operation, die Wahrheitswerte ergibt wird als logischer Ausdruck bezeichnet. Weil logische Ausdrücke für viele Funktionen und Operationen notwendig sind, wandelt Excel die Werte anderer Datentypen bei Bedarf um. Dabei gelten die folgenden Regeln:\nWerden Wahrheitswerte in mathematischen Operationen und Funktionen verwendet, dann konvertiert Excel den Wert FALSCH in 0 und den Wert WAHR in 1 um.\nWerden Wahrheitswerte als Parameter an Zeichenkettenfunktionen übergeben, dann werden die Wahrheitswerte in die entsprechende Zeichenkette umgewandelt. Aus dem Wert WAHR wird also die Zeichenkette \"WAHR\" und aus dem Wert FALSCH wird die Zeichenkette \"FALSCH\".",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Aussagenlogik</span>"
    ]
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#wahrheitswerte-in-excel",
    "href": "kapitel/boolsche-operationen/kapitel.html#wahrheitswerte-in-excel",
    "title": "10  Aussagenlogik",
    "section": "",
    "text": "0 und die leere Zelle entspricht dem Wert FALSCH.\nAlle Zahlen ungleich 0 entsprechen dem Wert WAHR.\nAlle Zeichenketten inklusive der leeren Zeichenkette entsprechen dem Wert WAHR.\nFehlerwerte bleiben unverändert.\n\n\n\n\n\n\n\n\n\nWarnung\n\n\n\nWahrheitswerte werden in den verschiedenen Sprachversionen von Excel in der eingestellten Sprache angegeben. Beim Wechsel zwischen verschiedenen Excel-Sprachversionen werden die Wahrheitswerte automatisch korrekt angezeigt. Die Umwandlung in Zeichenketten erfolgt dann in der jeweiligen Sprache. Deshalb sollte die Verwendung von in Zeichenketten konvertierten Wahrheitswerten in nachgelagerten Funktionen vermieden werden.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Aussagenlogik</span>"
    ]
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#aussagenlogische-operationen",
    "href": "kapitel/boolsche-operationen/kapitel.html#aussagenlogische-operationen",
    "title": "10  Aussagenlogik",
    "section": "10.2 Aussagenlogische Operationen",
    "text": "10.2 Aussagenlogische Operationen\nFür Wahrheitswerte existieren spezielle Operationen, um die Regeln der Aussagenlogik bzw. der Boole’schen Algebra abzubilden. Diese Operationen verknüpfen Wahrheitswerte und haben Wahrheitswerte als Ergebnis. Die vier Grundoperationen NICHT (\\lnot), UND (\\land), ODER (\\lor, “inklusives Oder”) und XODER (\\oplus, “entweder-oder”) sind in Excel als Funktionen verfügbar.\nDie Funktion NICHT() wandelt einen Wert in den jeweils den anderen Wahrheitswert um. Falls anstelle eines Wahrheitswerts ein anderer Datentyp übergeben wurde, gelten die oben angegebenen Regeln für die Umwandlung.\nDie Funktionen UND(), ODER() und XODER() sind Aggregatoren. Das bedeutet, dass Sie alle Werte in dem angegebenen Bereichen zusammenfassen. Das ist oft nicht das gewünschte Verhalten. Deshalb muss bei der Arbeit mit Vektoren auf die Boolesche Arithmetik zurückgegriffen werden, um logische Ausdrücke richtig auszuwerten.\nZum Beispiel sollen für die folgenden Werte paarweise der logische Ausdruck a \\land b ausgewertet werden, so dass für alle Wertepaare der richtige Wahrheitswert ermittelt wird.\n\n\n\nA\nB\n\n\n\n\nWAHR\nFALSCH\n\n\nFALSCH\nWAHR\n\n\nWAHR\nWAHR\n\n\nFALSCH\nWAHR\n\n\nWAHR\nWAHR\n\n\nFALSCH\nFALSCH\n\n\n\nDie Formel = UND(A1:A6; B1:B6) liefert den Wert FALSCH zurück, weil nicht alle Werte im gesamten Bereich von A1:A6 und B1:B6 gleich WAHR sind. Es gibt keine Funktion und keinen eigenen logischen Operator zur paarweisen logischen Verknüpfung dieser beiden Bereiche. Deshalb werden in Excel oft logische Ausdrücke in der Boole’schen Arithmethik eingesetzt, um nur die Werte aus den gleichen Datensätzen miteinander zu vergleichen. Diese Schreibweise ist immer dann notwendig, wenn logische Ausdrücke sich auf die einzelnen Datensätze beziehen.\nDie Formel = A1:A6 * B1:B6 hat die Werte {0;0;1;0;1;0} zum Ergebnis. Um Wahrheitswerte zu erhalten, kann noch auf die Ungleichheit mit 0 geprüft werden. Dazu wird die Formel wie folgt ergänzt: = (A1:A6 * B1:B6) &lt;&gt; 0. Das Ergebnis ist nun {FALSCH; FALSCH; WAHR; FALSCH; WAHR; FALSCH}. Dieser Schritt ist in der Praxis selten notwendig, weil für die meisten Operationen Zahlenwerte implizit als Wahrheitswerte behandelt werden.\nWeil Excel alle Werte ungleich 0 als WAHR interpretiert, können die Operationen UND() mit * und die Operation ODER() mit + direkt ersetzt werden. Hierbei ist darauf zu achten, dass das nummerische Ergebnis dieser Addition oder Multiplikation ausschliesslich als Wahrheitswert von Bedeutung ist.\nDie Operation XODER() entspricht der Ungleichheit &lt;&gt;. Dabei muss allerdings darauf geachtet werden, das dieser Vergleich als Ersatz für XODER() ausschliesslich für Wahrheitswerte bzw. 0 und 1 erlaubt ist. Für die oben gezeigten Werte ergibt die Formel = (A1:A5 &lt;&gt; B1:B5) die Werte {WAHR; WAHR; FALSCH; WAHR; FALSCH; FALSCH}. Das Ergebnis ist deshalb sichergestellt, weil alle Vergleichswerte 0 oder 1 sind. Werden jedoch auch andere Vergleichswerte zugelassen, dann liefert die Formel = (A1:A6 &lt;&gt; B1:B6) die Werte {WAHR; WAHR; WAHR; WAHR; WAHR; WAHR}. Dieses Verhalten zeigt das folgende Beispiel.\n\n\n\nA\nB\n\n\n\n\n1\n0\n\n\n0\n2\n\n\n1\n2\n\n\n0\n1\n\n\n3\n2\n\n\n0\n0\n\n\n\nDamit das richtige Ergebnis erzeugt wird, müssen die Werte in Wahrheitswerte konvertiert werden. Dazu muss die Formel durch Vergleiche ungleich 0 erweitert werden:\n= (A1:A6 &lt;&gt; 0) &lt;&gt; (B1:B6 &lt;&gt; 0)\nDiese Formel liefert die gewünschten Werte {WAHR; WAHR; FALSCH; WAHR; FALSCH; FALSCH}.\nDie folgende Tabelle zeigt logischen Operatoren und die zugehörigen Terme für die Boole’sche Arithmetik.\n\n\n\nOperator\n Boole’sche Operation\nVereinfachter Operator\n\n\n\n\n\\lnot\n1 - a\nNICHT(a)\n\n\n\\land\na * b\na * b\n\n\n\\lor\na + b - a * b\na + b\n\n\n\\oplus\na + b - 2 * a * b oder ( a - b ) ^ 2\n(a &lt;&gt; b)",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Aussagenlogik</span>"
    ]
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#vergleiche",
    "href": "kapitel/boolsche-operationen/kapitel.html#vergleiche",
    "title": "10  Aussagenlogik",
    "section": "10.3 Vergleiche",
    "text": "10.3 Vergleiche\nEine besondere Art von logischen Ausdrücken sind Vergleiche. Ein Vergleich prüft das Verhältnis zweier Werte zueinander. Excel kennt die üblichen Vergleichsoperatoren, die jeweils einen Wahrheitswert zurückliefern.\nIn Excel werden die Vergleichsoperatoren wie folgt geschrieben:\n\n&gt; (grösser als)\n&lt; (kleiner als)\n&gt;= (grösser oder gleich)\n&lt;= (kleiner oder gleich)\n= (gleich)\n&lt;&gt; (ungleich)\n\nExcel’s Vergleichsoperatoren sind Datentypen sensitiv. Das bedeutet, dass die Operatoren Datentypen vor dem Vergleich nicht angleichen. Der folgende Vergleich ergibt also FALSCH.\n= 3 = \"3\"\n\n\n\n\n\n\nMerke\n\n\n\nZiffern sind keine Zahlen!\n\n\nWeil die Operationen *, + und - normalerweise vor den Vergleichsoperatoren ausgeführt werden, müssen alle Vergleiche eines logischen Ausdrucks für die Boole’sche Arithmetik in Klammern gesetzt werden.\n\n10.3.1 Der \\in-Operator mit XVERWEIS\nMithilfe der Funktion XVERGLEICH() kann der \\in-Operator aus der Mengenlehre in Excel für logische Ausdrücke bereitgestellt werden. Mit dieser Funktion XVERWEIS() können sowohl der \\in als auch der \\notin-Operator mit XVERWEIS() abgebildet werden.\nFür die folgenden Beispiele verwenden wir die Werte:\n\n\n\nA\nB\n\n\n\n\nSuchkriterium\nSuchbereich\n\n\n4\n1\n\n\n7\n3\n\n\n\n4\n\n\n\n8\n\n\n\n\n\\in-Operator: XVERWEIS(A2:A3; B2:B5; B2:B5 = B2:B5; FALSCH)\n\\notin-Operator: XVERWEIS(A2:A3; B2:B5; B2:B5 &lt;&gt; B2:B5; WAHR)\n\nDer Trick besteht darin, dass die Rückgabematrix durch einen Vergleich aus dem Suchbereich erzeugt wird. Dadurch wird die Rückgabematrix mit den gleichen Wahrheitswerten für alle Werte im Suchbereich gefüllt. Die erste Formel ergibt deshalb {WAHR; FALSCH} und die zweite Formel {FALSCH; WAHR}, weil der Wert 4 im Suchbereich vorkommt und der Wert 7 nicht. Diese Werte können direkt in logischen Ausdrücken verwendet werden.\n\n\n10.3.2 Zeichenketten vergleichen\nDie Vergleichsoperatoren zeigen die Unterschiede zweier Zeichenketten bezüglich der alphabetischen Sortierung an. Die “kleinste” Zeichenkette ist die leere Zeichenkette. Gross- und Kleinschreibung wird bei Zeichenkettenvergleichen nicht unterschieden.\nWeil Excel für Vergleiche die nicht-druckbaren Zeichen mit Ausnahme des Leerzeichens und des Tabulators ignoriert, gibt der Vergleichsoperator = WAHR auch für Zeichenketten zurück, die unterschiedliche nicht-druckbare Zeichen enthalten. Das gleiche Problem entsteht beim Vergleich von unterschiedlicher Gross- und Kleinschreibung. Um auch diese Unterschiede zu erkennen, müssen wir die Funktion IDENTISCH() verwenden. Diese Funktion vergleicht die Zeichenketten Zeichen für Zeichen und liefert nur dann WAHR zurück, wenn die Zeichenketten exakt gleich sind.\n\nBeispiel 10.1 ## Anwendung der IDENTISCH() Funktion als Vergleichsoperator.\n= WENN(IDENTISCH(\"A\"; \"a\"); \"Gleich\"; \"Ungleich\")",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Aussagenlogik</span>"
    ]
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#sec-vector-logic",
    "href": "kapitel/boolsche-operationen/kapitel.html#sec-vector-logic",
    "title": "10  Aussagenlogik",
    "section": "10.4 Komplexe logische Ausdrücke und Datenstrukturen",
    "text": "10.4 Komplexe logische Ausdrücke und Datenstrukturen\nExcel hat zwar Funktionen für die logischen Operatoren Und (UND()), Oder (ODER()) und Exklusives Oder (XODER()), diese Funktionen haben aber den Nachteil, dass sie nur Werte zusammenfassen können. In der Praxis werden jedoch oft Datenstrukturen als Variablen für logische Ausdrücke verwendet. Diese sollen durch die logischen Operatoren verknüpft und nicht zusammengefasst werden.\nUm logische Verknüpfungen für Datenstrukturen zu realisieren, müssen die logischen Operatoren mit der Boole’schen Arithmetik umgesetzt werden. Dazu werden die logischen Operatoren durch die entsprechenden arithmetischen Operatoren ersetzt.\n\n\nBeispiel 10.2 Für die folgenden Werte soll der folgende logische Ausdruck geprüft werden.\n\na \\land b \\lor (c &lt; 10) \\land d\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nWAHR\n5\n21\n17\n\n\nFALSCH\n3\n5\n1\n\n\nWAHR\n0\n10\n2\n\n\nFALSCH\n1\n11\n3\n\n\n\nFür diesen Ausdruck werden die Werte {WAHR; WAHR; FALSCH; FALSCH} erwartet.\nDie naive Umsetzung =ODER(UND(A1:A4;B1:B4);UND(C1:C4;D1:D4)) hat als Ergebnis den Wert WAHR.\nDie Formel = A1:A4 * B1:B4 + (C1:C4 &lt; 10) * D1:D4 liefert die Werte {5; 1; 0; 0} diese lassen sich durch einen Vergleich in die entsprechenden Wahrheitswerte konvertieren. Diese Konversion ist nur notwendig, wenn der Ausdruck nicht als logischer Ausdruck an eine Funktion übergeben wird.\n= (A1:A4 * B1:B4 + (C1:C4 &lt; 10) * D1:D4) &lt;&gt; 0\nDiese Formel ergibt die erwarteten Werte {WAHR; WAHR; FALSCH; FALSCH}.\n\n\nDie Ausnahme von dieser Regel ist Verwendung der logischen Funktionen als Tabellenfunktion. In diesem Fall können die Werte zeilenweise auch von den logischen Funktionen verarbeitet werden.\n\n\nBeispiel 10.3 Werden die Werte aus Beispiel 10.2 als Tabelle konvertiert und mit BeispielTabelle benannt, dann können die logischen Funktionen in einer gleich langen Tabelle mit der gleichen Startzeile auch als Tabellenfunktionen verwendet werden. In diesem Fall werden die Werte zeilenweise verarbeitet.\n=ODER(\n      UND(BeispielTabelle[@a];BeispielTabelle[@b]);\n      UND(BeispielTabelle[@c] &lt; 10; BeispielTabelle[@d])\n )\nDiese Formel ergibt die erwarteten Werte {WAHR; WAHR; FALSCH; FALSCH}.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Aussagenlogik</span>"
    ]
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#fälle-unterscheiden",
    "href": "kapitel/boolsche-operationen/kapitel.html#fälle-unterscheiden",
    "title": "10  Aussagenlogik",
    "section": "10.5 Fälle unterscheiden",
    "text": "10.5 Fälle unterscheiden\nLogische Ausdrücke eigenen sich besonders gut, um Fallunterscheidungen zu formulieren, weil ein logischer Ausdruck immer nur zwei Werte als Ergebnis haben kann. Es gibt also für jeden logischen Ausdruck immer nur zwei unterscheidbare Fälle.\nExcel hat zwei zentrale Funktionen für Fallunterscheidungen: WENN() und WENNS(). Die Funktion WENN() ist eine einfache Unterscheidung, die Funktion WENNS() unterstützt mehrfache Unterscheidungen. In anderen Programmiersprachen wird in diesem Zusammenhang auch von Verzweigungen gesprochen.\n\n10.5.1 WENN\nDie Funktion WENN() ist eine einfache Fallunterscheidung. Einfach bedeutet hier, dass die beiden Fälles eines logischen Ausdrucks unterschieden werden. Entsprechend hat die Funktion WENN() drei Parameter:\n\nDer auszuwertende logische Ausdruck.\nDas Ergebnis falls der logische Ausdruck WAHR ergibt.\nDas Ergebnis falls der logische Ausdruck FALSCH ergibt.\n\nDas Ergebnis für den Fall, dass der logische Ausdruck FALSCH ergibt, ist optional. Fehlt dieser Parameter, dann wird der Wert FALSCH zurückgegeben.\nDas Verhalten dieser Funktion lässt sich mit den Wahrheitswerten als logischer Ausdruck direkt überprüfen:\n= WENN(WAHR; \"Guten Tag\"; \"Auf Wiedersehen\")\nWeil der logische Ausdruck in diesem Fall WAHR ist, wird der zweite Parameter als Ergebnis zurückgegeben. Die Formel gibt also den Wert \"Guten Tag\" zurück.\nWird der logische Ausdruck auf FALSCH geändert, dann liefert die Formel den Wert \"Auf Wiedersehen\".\n= WENN(FALSCH; \"Guten Tag\"; \"Auf Wiedersehen\")\nLassen wir den dritten Parameter weg, dann wird der Wert FALSCH zurückgegeben.\n= WENN(FALSCH; \"Guten Tag\")\nAusser der Fallunterscheidung hat WENN() keine weiteren Eigenschaften. Deshalb wird diese Funktion in der Praxis oft mit anderen Funktionen kombiniert. Das kann mit der Funktion WENN() selbst geschehen. In diesem Fall wird von geschachtelten Fallunterscheidungen gesprochen.\nZur Veranschaulichung dient das folgende Beispiel:\n\n\n\n\nA\n\n\n\n\n1\n4\n\n\n2\n7\n\n\n\nEine Fallunterscheidung soll prüfen, ob die Werte in A1:A2 Werte gleich 1, 3, 4 oder 8 sind. Falls das der Fall ist, soll der zugehörige Zahlwert als Zeichenkette ausgegeben werden. Falls das nicht der Fall ist, soll der Wert Ungültig zurückgegeben werden. Als geschachtelte WENN()-Funktion lässt sich diese Fallunterscheidung wie folgt formulieren:\n= WENN(A1 = 1; \"Eins\"; \n       WENN(A1 = 3; \"Drei\"; \n            WENN(A1 = 4; \"Vier\"; \n                 WENN(A1 = 8; \"Acht\"; \n                      \"Ungültig\"))))\nEine solche geschachtelte Fallunterscheidung wird als Entscheidungsbaum bezeichnet.\n\n\n10.5.2 WENNS\nDie Funktion WENN() ist eine einfache Fallunterscheidung. In vielen Excel-Arbeitsmappen existieren geschachtelte Aufrufe von WENN()-Funktionen. Diese Aufrufe machen die Formeln nicht nur schwer lesbar, sondern auch fehleranfällig und ineffizient. Deshalb sollten geschachtelte Fallunterscheidungen unbedingt vermieden werden. Mit der Funktion WENNS() lassen sich geschachtelte Fallunterscheidungen vermeiden, indem alle Fallunterscheidungen in einem einzigen Funktionsaufruf zusammengefasst werden.\n\n\n\n\n\n\nMerke\n\n\n\nGeschachtelte Fallunterscheidungen mit WENN() unbedingt vermeiden!\n\n\nDie Funktion WENNS() erwartet Parameterpaare, bestehend aus einem logischen Ausdruck und dem Ergebnis, falls dieser logische Ausdruck WAHR ergibt. Die Funktion kann bis zu 127 Parameterpaare verarbeiten, so dass sich auch sehr komplexe Fallunterscheidungen mit dieser Funktion abbilden lassen.\n\nBeispiel 10.4 Das folgende Beispiel zeigt die Verwendung der Funktion WENNS() für die geschachtelte Fallunterscheidung aus dem Abschnitt WENN.\n= WENNS(A2:A3 = 1; \"Eins\"; \n        A2:A3 = 3; \"Drei\"; \n        A2:A3 = 4; \"Vier\"; \n        A2:A3 = 8; \"Acht\")\nDas Beispiel bildet aber noch nicht die vollständige Fallunterscheidung ab. Es fehlt noch der Fall, dass keiner der logischen Ausdrücke WAHR ergibt. Leider kann WENNS() ausschliesslich logische Ausdrücke mit ihren Ergebnissen verbinden.\n\n\n\n\n\n\nMerke\n\n\n\nWENNS() kann nur logische Ausdrücke mit ihren WAHR-Ergebnissen verbinden.\n\n\nAnders als bei WENN() gibt es keine direkte Möglichkeit, ein Ergebnis festzulegen, falls alle logische Ausdrücke FALSCH ergeben. Um ein solches Verhalten zu erzeugen, wird ausgenutzt, dass die Funktion WENNS() immer einen wahren logischen Ausdruck mit einem Ergebnis verknüpft. Weil die logischen Ausdrücke in der Reihenfolge ausgewertet werden, wie sie in der Funktion angegeben sind, muss der letzte logische Ausdruck alle Fälle abdecken, die von keinem anderen der vorangegangen logischen Ausdrücke akzeptiert wurden. Der einfachste logische Ausdruck, der immer wahr ist, ist der Wahrheitswert WAHR. Deshalb wird dieser Wert als letzter logischer Ausdruck für WENNS() verwendet.\nMit diesem Wissen lässt sich das Beispiel mit WENNS() vervollständigen:\n= WENNS(A2:A3 = 1; \"Eins\"; \n        A2:A3 = 3; \"Drei\"; \n        A2:A3 = 4; \"Vier\"; \n        A2:A3 = 8; \"Acht\"; \n        WAHR; \"Ungültig\")\nDiese Formel prüft die Werte in A2:A3 auf Gleichheit mit den Werten 1, 3, 4 und 8. Für diese Zahlen wird die zugehörige Zahlwert als Zeichenkette ausgegeben. Falls keiner dieser Werte gefunden wird, wird der Wert Ungültig zurückgegeben.\n\nDie Fallunterscheidung mit WENNS() endet beim ersten logischen Ausdruck, der WAHR ergibt. Die Funktion prüft der Reihe nach alle angegebenen logischen Ausdrücke. Sobald einer dieser Ausdrücke WAHR ist, wird der zugehörige Ergebniswert ausgegeben und die Funktion wird beendet. Diese Eigenschaft begründet, dass die logischen Ausdrücke nur die Fälle prüfen müssen, die von den vorangegangenen logischen Ausdrücken nicht abgedeckt wurden.\n\nBeispiel 10.5 (Fallunterscheidung mit WENNS() vereinfachen) Gegeben ist die Formel mit geschachtelten Entscheidungen.\n= WENN(J2&gt;=O2;\n    (WENN(J2&gt;L2;\n          0;\n          WENN(J2&lt;=L2;\n               WENN((J2&gt;N2)*(J2&gt;=O2);\n                    (K2+((M2-K2)/(N2-L2))*(J2-L2));\n                    WENN((J2&lt;=N2)*(J2&lt;O2);\n                         (M2+((O2-M2)/(O2-N2))*(J2-N2))\n                ))\n          )\n    ));\n    100)\nDiese Formel ist aus zwei Gründen übermässig komplex.\n\nDie Fallunterscheidung mit WENN() ist geschachtelt.\nEs existieren redundante Fallunterscheidungen.\n\nBevor die Fallunterscheidung mit WENNS() vereinfacht wird, werden die redundanten Fallunterscheidungen entfernt. Das betrifft die zweite (J2 &gt; L2) und die vierte Fallunterscheidung (J2 &gt; N2). Im jeweiligen FALSCH-Fall wird der gegenteilige logische Ausdruck geprüft. Das ist in diesem Fall unnötig, weil die äussere Fallunterscheidung diesen Fall bereits abdeckt. Werden die redundanten logischen Ausdrücke und unnötige Klammern entfernt, dann ergibt sich die folgende wesentlich einfachere Formel.\n= WENN(J2&gt;=O2;\n    WENN(J2&gt;L2;\n          0;\n          WENN((J2&gt;N2)*(J2&gt;=O2);\n              K2+(M2-K2)/(N2-L2)*(J2-L2);\n              M2+(O2-M2)/(O2-N2)*(J2-N2)\n          )\n    );\n    100)\nDie äusserste Fallunterscheidung hat für den Fall WAHR eine geschachtelte WENN()-Funktion und im Fall FALSCH ein einfaches Ergebnis. Das ist für WENNS() unhandlich, so dass die äusserste Fallunterscheidung durch Umkehrung des logischen Ausdrucks umgestellt wird.\n= WENN(J2&lt;O2;\n       100; \n       WENN(J2&gt;L2;\n            0;\n            WENN((J2&gt;N2)*(J2&gt;=O2);\n                 K2+(M2-K2)/(N2-L2)*(J2-L2);\n                 M2+(O2-M2)/(O2-N2)*(J2-N2)\n            )\n       )\n  )\nNun lassen sich die vier unterschiedlichen Fälle gut erkennen und mit WENNS() abbilden. Daraus ergibt sich die folgende Formel.\n= WENNS(J2&lt;O2; 100; \n        J2&gt;L2; 0; \n        (J2&gt;N2)*(J2&gt;=O2); K2+(M2-K2)/(N2-L2)*(J2-L2); \n        WAHR; M2+(O2-M2)/(O2-N2)*(J2-N2)\n  )\nDiese Formel ist wesentlich einfacher zu lesen und zu verstehen. Beim Durchgehen der Fälle fällt auf, dass ein Teilausdruck des dritten Falls das Gegenteil des ersten Falls ist. Diese Bedingung wurde bereits im ersten Fall geprüft und würde sie nicht gelten, dann wäre die Formel bereits beendet worden. Deshalb können bereits geprüfte Teilausdrücke in den nachfolgenden Ausdrücken weggefallen. Dadurch wird nicht nur die Verschachtelung, sondern auch die Komplexität der logischen Ausdrücke vereinfacht.\n= WENNS(J2&lt;O2; 100; \n        J2&gt;L2; 0; \n        J2&gt;N2; K2+(M2-K2)/(N2-L2)*(J2-L2); \n        WAHR;  M2+(O2-M2)/(O2-N2)*(J2-N2)\n  )\nDiese Formel hat noch den Makel, dass der letzte Fall WAHR keine Konstante abbildet. Besser wäre es, wenn der zweite und der letzte Fall vertauscht wären, so dass der Wert 0 der letzte Wert ist. Dazu müssen die logischen Ausdrücke umorganisiert werden. Bei der Umorganisation ist die Reihenfolge der logischen Ausdrücke zu beachten: Die letzten beiden Fälle sind nicht unabhängig vom logischen Ausdruck J2&gt;L2. Beim Umorganisieren darf diese Abhängigkeit nicht verloren gehen.\n= WENNS(J2&lt;O2; 100; \n        (J2&lt;=L2)*(J2&gt;N2); K2+(M2-K2)/(N2-L2)*(J2-L2); \n        J2&lt;=L2; M2+(O2-M2)/(O2-N2)*(J2-N2)\n        WAHR; 0\n  )\nDiese Formel ist deutlich einfacher und weniger Fehleranfällig als die ursprüngliche Formel mit geschachtelten WENN()-Funktionen. Es lassen sich auch weitere Fälle hinzufügen, ohne dass die Formel komplexer wird. Dabei ist zu beachten, dass diese Fälle vor dem Fall WAHR angegeben werden müssen.\n\n\n\n10.5.3 Nicht erreichbare Entscheidungen\nEin besonderes Problem sind Entscheidungen, die zwar definiert aber nie erreicht werden können. Solche Entscheidungen sind immer redundant. Eine nicht erreichbare Entscheidung kann nur dann auftreten, wenn eine vorangegangene Entscheidung bereits den geprüften Fall abdeckt. Ergibt ein solcher logischer Ausdruck Falsch, dann wird eine spätere Entscheidung für den gleichen Fall im Falsch-Zweig des Entscheidungsbaums ebenfalls Falsch ergeben. Der Wahr-Zweig dieser Entscheidung kann damit nie erreicht werden.\n\nBeispiel 10.6 (Nicht erreichbare Entscheidung)  \n=WENNS( A1 &gt; 5; \"Sehr gut\"; \n        A1 &gt; 3; \"Genügend\"; \n        A1 &gt; 4; \"Gut\"; \n        A1 &lt;= 3; \"Ungenügend\")\n\nIn Beispiel 10.6 kann nie das Ergebnis “Gut” erzeugt werden, weil der zweite logische Ausdruck (A1 &gt; 3) alle Werte “maskiert”, die durch den dritten logischen Ausdruck (A1 &gt; 4) als “Gut” markiert werden müssten. “Ungenügend” würde trotzdem angezeigt werden, wenn der Wert in A1 entweder 1, 2 oder 3 ist.\n\n\n\n\n\n\nWichtig\n\n\n\nEine nicht erreichbare Entscheidung ist kein technischer Fehler, sondern ein logischer Fehler.\n\n\nIm Beispiel 10.6 kann die Entscheidung A1 &gt; 4 nicht erreicht werden, weil das vorherige und allgemeinere Kriterium A1 &gt; 3 für die gleichen Werte zutrifft.\n\n\n\n\n\n\nMerke\n\n\n\nEs müssen immer die spezielleren Kriterien vor den allgemeineren Kriterien geprüft werden.\n\n\nNicht erreichbare Entscheidungen lassen sich durch das Formale prüfen der logischen Ausdrücke leicht erkennen. Dazu werden logischen Ausdrücke und die zugehörigen Wertebereiche für den Wahr- und Falsch-Fall untereinander aufgeschrieben. Ein logischer Ausdruck kann einen Wertebereich nur dann abdecken, wenn dieser eine Teilmenge des Wertebereichs der aktuellen logischen Verzweigung ist.\n\n\n\nTabelle 10.1: Formale Prüfung der logischen Ausdrücke aus Beispiel 10.6\n\n\n\n\n\nRang\nlogischer Ausdruck\nWahr-Fall\nFalsch-Fall\n\n\n\n\n1\nA1 &gt; 5\nA1 &gt; 5\nA1 &lt;= 5\n\n\n2\nA1 &gt; 3\nA1 &gt; 3\nA1 &lt;= 3\n\n\n3\nA1 &gt; 4\nA1 &gt; 4\nA1 &lt;= 4\n\n\n4\nA1 &lt;= 3\nA1 &lt;= 3\nA1 &gt; 3\n\n\n\n\n\n\nWeil die Funktion WENNS() verwendet wird, ist der Wertebereich für einen logischen Ausdruck durch die Falsch-Fälle der logischen Ausdrücke mit niedrigerem Rang abgedeckt.\nFür Rang 3 muss wegen dieser Tabelle der logischen Ausdruck in Formel 10.1 gelten. Dieser Ausdruck kann jedoch nie Wahr ergeben, weil der gleiche Wert in Variable A1 nicht kleiner oder gleich 3 und gleichzeitig grösser als 4 sein kann.\n\n\\begin{aligned}\n& (A1 &lt;= 5) \\land & (A1 &lt;= 3) \\land & (A1 &gt; 4) \\\\\n\\Leftrightarrow & & (A1 &lt;= 3) \\land & (A1 &gt; 4) \\\\\n\\Leftrightarrow &  & \\text{Falsch}\n\\end{aligned}\n\\tag{10.1}\n\n\n10.5.4 ERSTERWERT\nDie Funktion ERSTERWERT() bildet einen Spezialfall von WENNS() ab: Es wird bei allen logischen Ausdrücken ein Vergleich auf Gleichheit des Suchkriteriums mit verschiedenen Referenzwerten durchgeführt. In diesem Fall können die logischen Ausdrücke mit ERSTERWERT() stark vereinfacht werden. Das lässt sich am ersten Beispiel im Abschnitt WENNS veranschaulichen.\nWeil alle logischen Ausdrücke die Gleichheit über den gleichen Adressbereich prüfen, kann die Operation mit der Funktion ERSTERWERT() vereinfacht wie folgt werden.\n= ERSTERWERT(A2:A3; \n             1; \"Eins\"; \n             3; \"Drei\"; \n             4; \"Vier\"; \n             8; \"Acht\"; \n             \"Ungültig\")\n\n\n10.5.5 XVERWEIS zur Fallunterscheidung\nDie Funktion XVERWEIS() ist als Excels Version des \\in-Operators bereits bekannt. Die Funktion kann auch als Alternative zur Funktion ERSTERWERT() verwendet werden. In diesem Fall werden als Rückgabematrix keine Wahrheitswerte, sondern die Ergebnisse der Fallunterscheidung angegeben.\nDer Vorteil dieser Anwendung ist, dass die Fallunterscheidung nicht mehr auf die Anzahl der Parameterpaare beschränkt ist und die Parameterpaare zum Zeitpunkt der Formelerstellung auch nicht bekannt sein müssen.\nDas folgende Beispiel zeigt die Umsetzung des Beispiels aus dem Abschnitt ERSTERWERT mit XVERWEIS(). Dazu wird zuerst eine Tabelle mit den Vergleichswerten und den zugehörigen Ergebnissen erstellt.\n\n\n\nC\nD\n\n\n\n\n1\nEins\n\n\n3\nDrei\n\n\n4\nVier\n\n\n8\nAcht\n\n\n\nDiese Referenztabelle stell in Spalte C die sog. Suchmatrix und in Spalte D die sog. Rückgabematrix bereit. Mit diesen Werten lässt sich die Fallunterscheidung wie folgt abbilden.\n= XVERWEIS(A2:A3; C2:D5; D2:D5; \"Ungültig\")\nEin weiterer Vorteil von XVERGLEICH() gegenüber ERSTERWERT() sind Vergleiche mit den Operatoren =, &lt;= oder &gt;=. Diese Vergleiche lassen sich über den fünften Parameter von XVERWEIS() konfigurieren. Dabei steht der Wert 0 für die Gleichheit, der Wert -1 für kleiner oder gleich und der Wert 1 für grösser oder gleich. Die Vergleiche sind immer so organisiert, dass der linke Operand dem Suchkriterium entspricht und der rechte Operand dem Wert in der Suchmatrix. Bei einem Treffer wird der Wert aus der Rückgabematrix zurückgegeben. Gibt es keinen Treffer für den Vergleich wird der Wert aus dem vierten Parameter wenn_nicht_gefunden geliefert.\n\n\n10.5.6 Anwendungshilfe für Fallunterscheidungen\nDie Anwendung der verschiedenen Fallunterscheidungsfunktionen hängt von verschiedenen Kriterien ab. Diese sind hier zusammengefasst:\nDie Funktion WENN() wird immer dann eingesetzt, wenn ein logischer Ausdruck geprüft werden muss und nur die beiden Fälle dieses Ausdrucks unterschieden werden müssen.\nDie Funktion WENNS() wird immer dann eingesetzt werden, wenn mehrere logische Ausdrücke geprüft werden müssen. Die logischen Ausdrücke können dabei beliebig komplex sein und sich auf verschiedene Daten und Bereiche beziehen.\nDie Funktion ERSTERWERT() wird immer dann eingesetzt, wenn die Gleichheit des Suchkriteriums mit wenigen Referenzwerten überprüft werden soll. Die Suchkriterien sind für alle Vergleiche identisch.\nDie Funktion XVERWEIS() wird immer dann eingesetzt, wenn ein Vergleich auf Gleichheit, Kleiner-oder-Gleich oder Grösser-oder-Gleich durchgeführt werden muss. Die Suchkriterien und die Vergleichsoperatoren sind für alle Vergleiche identisch.\nDie Funktion XVERWEIS() muss anstatt von ERSTERWERT() verwendet werden, wenn die Referenzwerte des Vergleichs zum Zeitpunkt der Formelerstellung noch nicht bekannt sind oder leicht änderbar bleiben sollen.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Aussagenlogik</span>"
    ]
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#filtern",
    "href": "kapitel/boolsche-operationen/kapitel.html#filtern",
    "title": "10  Aussagenlogik",
    "section": "10.6 Filtern",
    "text": "10.6 Filtern\nExcel bietet die Funktion FILTER() zum Filtern von Daten. Diese Funktion erzeugt einen Ergebnisbereich mit den Werten, die durch den angegebenen logischen Ausdruck ausgewählt wurden.\n\n\n\n\n\n\nWarnung\n\n\n\nIn Excel können in Tabellen und Pivot-Tabellen für einzelne Vektoren Werte für die Darstellung “gefiltert” werden. Dabei verwendet Excel nicht die Filter Funktion, sondern blendet einzelne Datensätze aus. Dadurch können die Ergebnisse nachgereihter Operationen nicht mit den dargestellten Werten zusammenpassen, weil nicht-dargestellte Werte weiterhin Teil der Daten sind und bei Berechnungen weiterhin mitberücksichtigt werden.\n\n\nDas Ergebnis der Funktion FILTER() ist ein dynamischer Bereich mit den ausgewählten Werten. Im Gegensatz zu Tabellen-Filter sind die nicht dargestellten Werte nicht mehr Teil der Daten. Deshalb sind die Ergebnisse der FILTER()-Funktion konsistent mit den Ergebnissen der nachgereihten Operationen.\n\nDefinition 10.1 Excels FILTER()-Funktion wählt aus einem Vektor die Werte aus, für die ein Auswahlvektor den Wert WAHR oder einen Wert, der dem logischen WAHR entspricht.\n\n\n\nBeispiel 10.7 (Filtern mit Excel) Gegeben sind die folgende Werte in den Spalten A und B. Die Filter()-Funktion steht an Adresse D2.\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n1\nBasel\n WAHR\n\n=FILTER(A1:A5; B1:B5)\n\n\n2\nGenf\n FALSCH\n\n Basel\n\n\n3\nLugano\n FALSCH\n\n Zug\n\n\n4\nZug\nWAHR \n\n Zürich\n\n\n5\nZürich\nWAHR \n\n \n\n\n\nWeil die Werte in Spalte B vom Datentyp Wahrheitswert sind, kann &gt; dieser Vektor zur Auswahl der Städtenamen in Spalte A verwendet werden.\nAnstelle eines Vektors mit Wahrheitswerten wird meistens ein Vergleich als zweiter Parameter übergeben. Dieser Vergleich muss einen Vektor erzeugen, der genauso lang ist, wie der Vektor im ersten Parameter. Solche Vektoren werden dynamisch erzeugt, indem ein Vergleich entweder den Vektor selbst oder einen benachbarten Vektor verwendet.\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n1\nBasel\ndeutsch\n\n=FILTER(A1:A5; B1:B5 = \"deutsch\")\n\n\n2\nGenf\n französisch\n\n Basel\n\n\n3\nLugano\nitalienisch\n\n Zug\n\n\n4\nZug\ndeutsch \n\n Zürich\n\n\n5\nZürich\ndeutsch \n\n \n\n\n\n\n\n\n10.6.1 Excel Filter und logische Operationen\nWeil die FILTER()-Funktion immer über Vektoren arbeitet, können die logischen Funktionen nicht verwendet werden, weil sie keine Vektoren erzeugen. Deshalb muss der logische Ausdruck des Filters als Boole’sche Arithmetik formuliert werden (Kapitel 10.4).\n\n\n\n\n\n\nHinweis\n\n\n\nDie Funktion NICHT() ist kein Aggregator und kann mit der FILTER()-Funktion kombiniert werden.\n\n\nUm mit komplexen logischen Ausdrücken in Filtern zu verwenden, müssen wir die logischen Operatoren durch ihre arithmetische Schreibweise ersetzen.\n\n\n\nTabelle 10.2: Beispiel eines komplexen logischen Ausdrucks mit FILTER()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\n\n\n\n\n1\nName\nSprache\nEinwohner:innen\n\nFormel\n\n\n2\nBasel\ndeutsch\n173863\n\n=FILTER(A2:A6;(B2:B6=\"deutsch\")*(C2:C6 &gt; 100000))\n\n\n3\nGenf\n französisch\n203856\n\n Basel\n\n\n4\nLugano\nitalienisch\n62315\n\n Zürich\n\n\n5\nZug\ndeutsch \n30934\n\n\n\n\n6\nZürich\ndeutsch \n421878",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Aussagenlogik</span>"
    ]
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#selektieren",
    "href": "kapitel/boolsche-operationen/kapitel.html#selektieren",
    "title": "10  Aussagenlogik",
    "section": "10.7 Selektieren",
    "text": "10.7 Selektieren\nSehr häufig liegen umfangreiche Daten mit vielen Vektoren vor. Soll sich eine Analyse auf einzelne Vektoren beschränken, dann sollen, analog zum Filtern von Datensätzen, nur diese Vektoren ausgewählt werden.\n\nDefinition 10.2 Das Filtern von Vektoren wird als selektieren bezeichnet.\n\nWeil die Vektoren einer Stichprobe in der Regel benannt sind, werden Vektoren über ihre Namen selektiert.\n\n\n\n\n\n\nMerke\n\n\n\nDie Vektorennamen einer Stichprobe haben besondere Eigenschaften:\n\nVektorennamen sind immer von Datentyp Zeichenkette.\nVektorennamen einer Stichprobe bilden einen Vektor.\nDie Vektorennamen einer Stichprobe sind eindeutig.\n\n\n\nDie dritte Eigenschaft ist nicht ganz offensichtlich, denn in einer manuell eingegebenen zwei-dimensionalen Struktur kann eine Überschrift mehrfach verwendet werden. Sobald eine solche Struktur in eine Excel-Tabelle umgewandelt wird, erzwingt Excel eindeutige Vektorennamen.\nAus diesen Eigenschaften folgt, dass die Auswahl von Vektoren durch die Eigenschaften von Zeichenketten unterstützt wird. Wir können zur Auswahl die folgenden Operationen verwenden:\n\nIdentischer Vektorname\nVektorname beginnt mit einer bestimmten Zeichenkette\nVektorname endet mit einer bestimmten Zeichenkette\nVektorname enthält an einer beliebigen Position eine bestimme Zeichenkette\n\nDiese Operationen lassen sich als logische Ausdrücke formulieren, wodurch sich komplexere Selektoren umsetzen lassen.\nDer einfachste Weg zum Vektoren adressieren ist die Verwendung des Vektornamens über die Tabellenadressierung. Dabei wird der Vektorname in eckige Klammern gesetzt (s. Abschnitt 6.4.2). Die Tabellenadressierung ist jedoch auf vollständige Namen und auf zusammenhängende Bereiche beschränkt.\nDie Verwendung einer Selektor-Funktion zur Auswahl von Vektoren ist nicht auf Tabellen beschränkt, sondern kann mit beliebigen tabellarischen Strukturen angewendet werden. In Excel wird eine Selektor Funktion durch die Funktionskette eines Filters mit der Funktion SPALTENWAHL() erreicht.\nNeben der Tabellenadressierung bietet Excel die Funktion SPALTENWAHL(), um Vektoren aus einem Bereich auszulesen. Diese Funktion benötigt aber die Position der gewünschten Spalte, denn oft sollen aber Vektoren über Namen oder Namensteile ausgewählt werden. Dafür kommt die Funktion XVERGLEICH() zur Anwendung. Mit XVERGLEICH() erhalten wir die Position eines gesuchten Werts in einem angegebenen Bereich.\nDie Idee hinter dem hier beschriebenen Ansatz ist, dass wir herausfinden, wo unser gewünschter Vektor in der Stichprobe steht. Anschliessend wählen wir alle Werte an dieser Position mit der Funktion Spaltenwahl() aus.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Funktion XVERGLEICH() ähnelt der Funktion XVERWEIS() indem wir einen Wert in einem Vektor suchen können. Anstelle eines Referenzwerts aus einem anderen Vektor liefert XVERGLEICH() nur die Position des gesuchten Werts zurück. Falls ein Wert mehrfach vorkommt, dann gibt die Funktion nur die erste Position zurück.\n\n\nDer Funktion XVERGLEICH() können mehrere Suchwerte übergeben werden, für welche die Positionen bestimmt werden.\n\n\n\nBeispiel für Vektorenselektion\n\n\nDer Algorithmus zum Selektieren von Vektoren ist durch die folgenden Schritte definiert:\n\nWir vektorisieren nur die Vektornamen auf einem neuen Arbeitsblatt mit der Identitätsfunktion ab Adresse B1. Zur Veranschaulichung nenne ich dieses Arbeitsblatt Stichprobendaten.\nWir vektorisieren alle Stichprobendaten mittels der Identitätsfunktion auf dem gleichen Arbeitsblatt ab Adresse B2.\nAuf einem neuen Arbeitsblatt geben wir in der ersten Zeile die Vektorennamen ab Adresse A1 ein, die wir auswählen möchten. In diesem Beispiel wird angenommen, dass 3 Vektoren ausgewählt werden sollen.\nWir wählen die einzelnen Vektoren mit der folgenden Formel an der Adresse A2 aus.\n\n\nBeispiel 10.8 (Selektion von Vektoren in Excel)  \n=SPALTENWAHL(Stichprobendaten!$B$2#; \n             XVERGLEICH(A1:C1; Stichprobendaten!$B$1#))\n\nDer Vorteil dieser Strategie ist, dass die Selektion individuelle, nicht-zusammenhängende Vektoren selektieren kann und nicht auf Tabellen beschränkt ist.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Aussagenlogik</span>"
    ]
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#sortieren",
    "href": "kapitel/boolsche-operationen/kapitel.html#sortieren",
    "title": "10  Aussagenlogik",
    "section": "10.8 Sortieren",
    "text": "10.8 Sortieren\nExcel kennt zwei Funktionen zum Sortieren:\n\nSORTIEREN()\nSORTIERENNACH()\n\nDie Funktion SORTIEREN() sortiert einen Bereich zeilen- oder spaltenweise. Für allgemeine Sortierungen nach mehreren Vektoren stellt Excel die Funktion SORTIEREN() zur Verfügung.\n\n\n\n\n\n\nHinweis\n\n\n\nExcels SORTIERENNACH()-Funktion kann einen Bereich zeilen- oder spaltenweise sortieren. Diese Funktion hat vier Parameter:\n\nMatrix - der zu sortierende Bereich, der keine Matrix sein muss.\nSortierindex - die Spalten- oder Zeilennummer, nach der sortiert werden soll. Standardmässig wird die erste Spalte bzw. die erste Zeile angenommen.\nSortierreihenfolge - legt die Sortierreihenfolge fest. 1, um aufsteigend und -1, um absteigend zu sortieren.\nnach_Spalte - Ein Wahrheitswert, ob die Spalten oder die Zeilen sortiert werden sollen. WAHR bedeutet, dass die Spalten (horizontal) sortiert werden sollen. FALSCH bedeutet, dass die Zeilen (vertikal) sortiert werden sollen. Standardmässig wird zeilenweise sortiert.\n\n\n\nDie Funktion ermöglicht es, mehrere Vektoren auf einmal nach mehreren gemeinsamen Kriterien zu sortieren. Dazu müssen zuerst die Sortierkriterien identifiziert werden.\nDie Funktion SORTIERENNACH() deckt den Spezialfall ab, wenn die Sortierung nach einem externen Kriterium erfolgen soll. Während SORTIEREN() erfordert, dass die Sortierindizes im zu sortierenden Bereich enthalten sind, können die Sortierindizes bei SORTIERENNACH() an einer beliebigen Stelle in der Arbeitsmappe liegen.\n\n10.8.0.1 Schritt 1: Sortierkriterien festlegen.\nDie Sortierkriterien sind durch die Werte im Sortierindex festgelegt, nach denen sortiert werden soll. Der Sortierindex ist ein Vektor mit einem Wert für eine Zeile bzw. Spalte der Sortiermatrix. Entlang der Werte im Sortierindex wird die Sortiermatrix sortiert.\nIn Excel können die Vektoren mit den Sortierkriterien an einer beliebigen Position in einer Arbeitsmappe liegen. Dabei müssen zwei Bedingungen erfüllt sein:\n\nDer Sortierindex und die Sortiermatrix müssen die gleiche Länge haben.\nDie Sortierindex und die Sortiermatrix müssen die gleiche Orientierung haben.\n\n\n\n10.8.0.2 Schritt 2:\nIm zweiten Schritt werden die zu sortierenden Vektoren ausgewählt.\nIn R wird dieser zweite Schritt automatisch auf die vorgegebene Stichprobe angewandt. In Excel können wir zusammenhängende Vektoren als “Matrix” an die SORTIERENNACH()-Funktion übergeben. Hängen die Vektoren nicht direkt zusammen, dann müssen mehrere Sortieroperationen mit den gleichen Referenzen auf die Sortierreferenzen durchgeführt werden.\nIn Excel wird die Sortierrichtung als Sortierreihenfolge bezeichnet und als separater Parameter für das jeweilige Sortierkriterium angegeben. Dabei steht 1 für die aufsteigende Sortierung und -1 für die absteigende Sortierung.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Aussagenlogik</span>"
    ]
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#rezepte",
    "href": "kapitel/boolsche-operationen/kapitel.html#rezepte",
    "title": "10  Aussagenlogik",
    "section": "10.9 Rezepte",
    "text": "10.9 Rezepte\n\n10.9.1 Fehlerwerte abfangen\nViele Excel-Funktionen geben einen Fehlerwert zurück, falls die Funktion kein gültiges Ergebnis ermitteln kann. Weil sich diese Fehlerwerte in Operationen fortpflanzen, müssen diese Werte durch einen geeigneten regulären Wert ersetzt werden. Das kann mit der folgenden Entscheidung erreicht werden.\n= WENN(ISTFEHLER(A1); 0; A1)\nDiese Operation ersetzt alle Fehlerwerte durch den Wert 0 und lässt alle anderen Werte unverändert.\nWeil diese Entscheidung sehr oft vorkommt, gibt es die Funktion WENNFEHLER(), mit der die gleiche Operation einfacher ausgedrückt werden kann.\n= WENNFEHLER(A1; 0)\n\n\n10.9.2 Eine Zahl für genau eine Bedingung zurückgeben\nEin häufiger Spezialfall für Unterscheidungen ist die Auswahl von Zahlen, die genau einen logischen Ausdruck erfüllen. Solche Unterscheidungen geben im FALSCH-Fall 0 und im anderen Fall die gesuchte Zahl zurück. In diesem Spezialfall kann der Zielwert ohne Umweg über die WENN()-Funktion mit dem logischen Ausdruck multipliziert werden. Der logische Ausdruck liefert 1 für WAHR und 0 für FALSCH. Die Multiplikation mit 0 liefert immer 0. Die Multiplikation mit 1 liefert den Zielwert.\nDas Beispiel gibt für die folgenden Werte alle Zahlen zurück, die grösser als 10 und kleiner als 20 sind.\n\n\n\nA\n\n\n\n\n13\n\n\n5\n\n\n17\n\n\n20\n\n\n12\n\n\n2\n\n\n29\n\n\n11\n\n\n7\n\n\n32\n\n\n\nNormalerweise würde diese Entscheidung durch die folgende Operation abgebildet:\n= WENN((A1:A10 &gt; 10) * (A1:A10 &lt; 20); A1:A10; 0)\n\n\n\n\n\n\nWarnung\n\n\n\nDiese spezielle Fallunterscheidung sollte auf Korrektheit überprüft werden, wenn im WAHR-Fall der Wert 0 erlaubt ist. In diesem Fall wird der Wert 0 nicht vom logischen Ausdruck unterschieden.\n\n\nWeil alle Werte Zahlen sind, handelt es sich um den Spezialfall, dass der WAHR-Wert eine Zahl und der FALSCH-Fall eine 0 ist. Für diesen Fall lässt sich die Formel vereinfachen, indem die gesuchten Werte mit dem logischen Ausdruck multipliziert werden:\n= A1:A10 * (A1:A10 &gt; 10) * (A1:A10 &lt; 20)\nDas Ergebnis beider Formeln sind die Werte {13;0;17;0;12;0;0;11;0;0}.\nDamit dieses Rezept funktioniert, müssen alle Teile des logischen Ausdrucks genau die Werte FALSCH oder WAHR bzw. 0 oder 1 zurückgeben. Das ist notwendig, weil nur das neutrale Element die Zielwerte unverändert lässt. Eine direkte Übergabe von Zahlen im logischen Ausdruck verfälscht das Ergebnis, weil nicht mit dem neutralen Element gerechnet wird.\nSoll für einen logischen Ausdruck nur der Wert 1 oder 0 zurückgegeben werden, dann kann der Rückgabebereich am Anfang der Formel weggelassen werden. Es wird dann nur der logische Ausdruck angegeben. Die Formel = (A1:A10 &gt; 10) * (A1:A10 &lt; 20) hat die Werte {1;0;1;0;1;0;0;1;0;0} als Ergebnis.\n\n\n10.9.3 Fehlerwerte vergleichen\nFehlerwerte können nicht direkt mit den Vergleichsoperatoren verglichen werden, weil Excel immer den ersten gefundenen Fehlerwert als Ergebnis einer Operation zurückgibt. Deshalb müssen Fehlerwerte zuerst in normale Werte konvertiert werden. Damit verschiedene Fehlerwerte miteinander verglichen werden können, müssen die verschiedenen Fehlerwerte zuerst in eindeutige Zahlen umgewandelt werden. Das übernimmt die Funktion FEHLER.TYP(). Diese Zahlen können anschliessend wie gewohnt weiter verarbeitet werden.\nDas folgende Beispiel weist den gegebenen Fehlerwerten eine Fehlermeldung zu:\n\n\n\nA\n\n\n\n\n#NV\n\n\n#WERT!\n\n\n3\n\n\n\nDie folgende Formel liefert die Werte {\"Fehler: #NV\"; \"Fehlerhafter Wert\", \"Kein Fehler\"}.\n= WENNS(FEHLER.TYP(A1:A2) = 7; \"Fehler: #NV\"; \n        FEHLER.TYP(A1:A2) = 3; \"Fehlerhafter Wert\"; \n        WAHR; \"Kein Fehler\")\nWeil alle Vergleiche die Gleichheit überprüfen, kann die Formel mit der Funktion ERSTERWERT() vereinfacht werden. Die Formel lautet dann:\n= ERSTERWERT( WENNFEHLER(FEHLER.TYP(A1:A3); 0);\n              3; \"Fehlerhafter Wert\";\n              7; \"Fehler: #NV\";\n              \"Kein Fehler\")\nFür diesen Schritt muss die Operation mit der Funktion WENNFEHLER() erweitert werden, weil die Funktion FEHLER.TYP() einen Fehler ausgibt, wenn der übergebene Wert kein Fehlerwert ist. Weil die Fehlertypen mit Werten grösser 0 durchnummeriert sind, bietet sich für reguläre Werte der Wert 0 an.\n\n\n10.9.4 Filtern und Summen\nBis Juli 2020 mussten die Funktionen SUMMEWENN() oder SUMMEWENNS() verwendet werden, um Daten nach Kriterien zu summieren. Diese Funktionen haben allerdings den Nachteil, dass keine echten logischen Ausdrücke verwendet werden können. Seit Juli 2020 steht die FILTER()-Funktion zur Verfügung. Dadurch können echte logische Ausdrücke als Filterkriterien eingesetzt werden. Gleichzeitig hat sich die Bedeutung der Funktionen SUMMEWENN() und SUMMEWENNS()geändert (s. Kapitel 13).\nDie folgende Formel sollten wir jetzt mit der Filter-Technik umschreiben.\n\nBeispiel 10.9 (Summenwenn durch Filter-Summe ersetzen) Alt wurde geschrieben:\n= SUMMEWENN(B2#; \"&lt; 0\")\nNeu ist die gleiche Funktion etwas ausführlicher:\n= SUMME( FILTER(B2#; B2# &lt; 0) )\nDiese Schreibweise hat den Vorteil, dass die einzelnen Schritte nach dem Prinzip der Problemzerlegung getrennt werden und separat untersucht werden können. Das war in der alten Schreibweise nur indirekt möglich.\n\nDas gleiche Prinzip gilt auch für ZÄHLENWENN() und ZÄHLENWENNS() anwenden. In diesem Fall wird entweder die Funktion ANZAHL() oder die Funktion ANZAHL2() als Aggregator eingesetzt.\nDer grösste Vorteil ist aber, dass mit dieser Technik beliebige EXCEL-Aggregatoren mit gefilterten Daten eingesetzbar sind und nicht mehr auf die vordefinierten Aggregatoren eingeschränkt sind. Mit dem Filtern wird es ausserdem möglich, andere logische Ausdrücke als nur einen direkte Vergleich oder, im Fall von SUMMEWENNS() oder ZÄHLENWENNS(), mit Und verknüpfte Vergleiche durchzuführen.\n\n\n\n\n\n\nWarnung\n\n\n\nWenn wir komplexe logische Ausdrücke mit Excels FILTER()-Funktion verwenden wollen, dann müssen wir für die logischen Operatoren die arithmetische Schreibweise für die logischen Ausdrücke verwenden!",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Aussagenlogik</span>"
    ]
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html",
    "href": "kapitel/vektor-operationen/kapitel.html",
    "title": "11  Vektoroperationen",
    "section": "",
    "text": "11.1 Vektorlänge\nVektoren sind zusammengesetzte Datenstrukturen, die Werte vom gleichen Datentyp darstellen. Vektoren werden in Excel entweder als Bereiche (z.B. A1:A5), als Arrays (z.B. B1#) oder als Tabellenspalten (z.B. Tabelle1[[Spalte1]]) adressiert.\nFalls der gleiche Datentyp in einem Vektor nicht vorausgesetzt werden kann, müssen die Daten für die Verarbeitung vorbereitet werden. Das kann beispielsweise dadurch geschehen, dass der gewünschte Datentyp (oder Wertebereich) durch filtern eingeschränkt wird.\nFür viele Vektoroperationen existiert deshalb eine Funktion für Spaltenvektoren und eine für Zeilenvektoren.\nUm Vektoren von der einen zur anderen Orientierung zu überführen, dient die Funktion MTRANS(). Soll eine bestimmte Orientierung für beliebige Vektoren erzwungen werden, dann kann die Funktion ZUSPALTE() zum Erzwingen eines Spaltenvektors oder die Funktion ZUZEILE() zum Erzwingen eines Zeilenvektors verwendet werden.\nJeder Vektor hat eine Länge, wobei diese Länge nicht zwingend der Anzahl der Werte entsprechen muss. Deshalb sollte die Länge eines Vektors mit Excel nicht mit der Funktion ANZAHL() bzw. ANZAHL2() bestimmt werden, sondern über die Funktionen ZEILEN() und SPALTEN(). Der Vorteil dieser beiden Funktionen ist, dass sie die Vektorlänge auch dann korrekt bestimmen, wenn einzelne Werte im Vektor nicht vorhanden sind.\nDie Funktionen ZEILEN() und SPALTEN() geben die Anzahl der Zeilen respektive Spalten für den übergebenen Bereich zurück. Für einen Spaltenvektor gibt die Funktion ZEILEN() die Länge des Vektors zurück und die Funktion SPALTEN() hat den Wert 1. Die Funktion SPALTEN() gibt die Vektorlänge von Zeilenvektoren zurück. Entsprechend hat in diesem Fall die Funktion ZEILEN() immer den Wert 1 als Ergebnis.\nAus den beiden Werten der Funktionen ZEILEN() und SPALTEN() kann die Orientierung eines Vektors mit der Operation ZEILEN(vektor) - SPALTEN(vektor) bestimmt werden. Ist das Ergebnis grösser 0 handelt es sich um einen Spaltenvektor und ist er kleiner 0 handelt es sich um einen Zeilenvektor.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Vektoroperationen</span>"
    ]
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#vektorlänge",
    "href": "kapitel/vektor-operationen/kapitel.html#vektorlänge",
    "title": "11  Vektoroperationen",
    "section": "",
    "text": "Merke\n\n\n\nDie kleinste Excel Struktur ist die Zelle. Deshalb werden keine Vektoren der Länge 0 unterstützt! Es ist unmöglich, Vektoren der Länge 0 durch Funktionen zu erzeugen!\n\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nZur Feststellung der Orientierung muss in der Regel nur die erste Bedingung geprüft werden.\n\n\n\n\n\n\n\n\nMerke\n\n\n\nVektoren, auf die mit der Tabellen-Adressierung zugegriffen wird, sind immer Spaltenvektoren.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Vektoroperationen</span>"
    ]
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#konstante-vektoren",
    "href": "kapitel/vektor-operationen/kapitel.html#konstante-vektoren",
    "title": "11  Vektoroperationen",
    "section": "11.2 Konstante Vektoren",
    "text": "11.2 Konstante Vektoren\nKonstante Vektoren sind Vektoren, die als Konstante in einer Formel eingegeben werden und nur konstante Werte enthalten. Ein konstanter Vektor wird durch geschweifte Klammern eingerahmt und kann Zahlen, Zeichenketten, Wahrheits- und Fehlerwerte enthalten (Beispiel 11.2).\n\n\n\n\n\n\nMerke\n\n\n\nKonstante Vektoren sind immer Spaltenvektoren.\n\n\n\nBeispiel 11.2 (Konstanter Zahlenvektor der Länge 3)  \n= {3; 2; 1}\n\nKonstante Vektoren dürfen keine Referenzen auf Adressen, Bezeichner, Formeln usw. enthalten (Beispiel 11.3). Ungültige konstante Vektoren erzeugen einen #WERT!-Fehler\n\nBeispiel 11.3 (Ungültiger konstanter Vektor)  \n= {1; A2; 3}",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Vektoroperationen</span>"
    ]
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#wertereferenzierung",
    "href": "kapitel/vektor-operationen/kapitel.html#wertereferenzierung",
    "title": "11  Vektoroperationen",
    "section": "11.3 Wertereferenzierung",
    "text": "11.3 Wertereferenzierung\nDie Referenzierung auf einzelne Werte erfolgt durch die Funktionen ZEILENWAHL() für Spaltenvektoren bzw. SPALTENWAHL() für Zeilenvektoren. Der erste Parameter ist immer der Vektor. Mit dem zweiten Parameter wird der Index des gewünschten Werts angegeben. Der zweite Parameter kann als Vektor angegeben werden. In diesem Fall werden alle angegebenen Indizes als Vektor zurückgegeben.\n\n\n\n\n\n\nMerke\n\n\n\nWerden mehrere Indizes angegeben, so werden die Werte in der Reihenfolge der angegebenen Indizes zurückgegeben.\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nBei der Wertereferenzierung dürfen nur gültige Indizes verwendet werden. Werden mehrere Indizes angegeben und mindestens einer von ihnen ist ungültig, dann werden keine Werte. In solchen Fällen ist das Ergebnis ein #WERT!-Fehler.\n\n\n\n11.3.1 Rezept: Wertepaare tauschen\nLiegen Werte in Wertepaaren vor, dann können die Werte mit der Wertereferenzierung vertauscht werden:\n\nBeispiel 11.4 (Werte eines Spaltenvektors der Länge 2 vertauschen)  \n= ZEILENWAHL(A1:A2; {2; 1})",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Vektoroperationen</span>"
    ]
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#sequenzen",
    "href": "kapitel/vektor-operationen/kapitel.html#sequenzen",
    "title": "11  Vektoroperationen",
    "section": "11.4 Sequenzen",
    "text": "11.4 Sequenzen\nSequenzen werden mithilfe der Generatorfunktion SEQUENZ() erzeugt. Die Funktion hat vier Parameter. Die ersten beiden Parameter der Funktion zeigen die Anzahl der Zeilen und Spalten an, über welche sich die Sequenz erstrecken soll. Der dritte Parameter erwartet den Startwert der Sequenz und mit dem letzten Parameter wird die Schrittweite der Sequenz angegeben.\n\nBeispiel 11.5 (Sequenz von geraden Zahlen erzeugen)  \n=SEQUENZ(10; 1; 0; 2)\n\nNur der erste Parameter der Funktion SEQUENZ() muss angegeben werden. In diesem Fall wird für alle anderen Parameter der Wert 1 angenommen.\n\nBeispiel 11.6 (Sequenz der Länge 10 als Spaltenvektor erzeugen)  \n=SEQUENZ(10)\n\nZwei spezielle Sequenzen sind der Nullvektor und der Einsvektor. In beiden Vektoren wiederholt sich der Wert an jeder Position. Die zugehörige Sequenz hat also die Schrittweite 0.\n\nBeispiel 11.7 (Einsvektor der Länge 10 erzeugen)  \n=SEQUENZ(10; 1; 1; 0)\n\nAnalog zum Einsvektor in Beispiel 11.7 wird der Nullvektor erzeugt, wobei der dritte Parameter den Wert 0 haben muss.\n\n11.4.1 Rezept: Vektor umkehren\nDie Wertereihenfolge eines beliebigen Vektors kann durch eine umgekehrte Sequenz umgekehrt werden.\n\nBeispiel 11.8 (Vektorwerte umkehren)  \n= ZEILENWAHL(\n    A1:A10; \n    SEQUENZ(ZEILEN(A1:A10); 1; ZEILEN(A1:A10); -1)\n)",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Vektoroperationen</span>"
    ]
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#konkatenation",
    "href": "kapitel/vektor-operationen/kapitel.html#konkatenation",
    "title": "11  Vektoroperationen",
    "section": "11.5 Konkatenation",
    "text": "11.5 Konkatenation\nDie Konkatenation verbindet zwei Vektoren zu einem neuen Vektor, wobei die Reihenfolge der Werte erhalten bleibt. Deshalb können in Excel nur Vektoren mit gleicher Orientierung konkateniert werden.\nZum Konkatenieren von Spaltenvektoren dient die Funktion VSTAPELN() (für “vertikal stapeln”). Zum Konkatenieren von Zeilenvektoren dient die Funktion HSTAPELN() (für “horizontal stapeln”).\nDie beiden Funktionen HSTAPELN() und VSTAPELN() prüfen die Orientierung von Vektoren nicht! Werden zwei Vektoren mit unterschiedlicher Orientierung mit diesen Funktionen “gestapelt”, entsteht eine Matrix, wobei die Vektoren in der Reihenfolge der Argumentübergabe als Zeile oder Spalte gezeigt werden. Die restlichen Positionen der Matrix werden mit dem Fehlerwert #NV belegt.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Vektoroperationen</span>"
    ]
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#transformationen",
    "href": "kapitel/vektor-operationen/kapitel.html#transformationen",
    "title": "11  Vektoroperationen",
    "section": "11.6 Transformationen",
    "text": "11.6 Transformationen\nDas Ergebnis einer Transformationsoperation ist immer ein Vektor mit der gleichen Länge wie der ursprüngliche Vektor. Dazu wird eine Operation für jeden Wert eines Vektors ausgeführt.\nTypische Funktionen für Transforamtionen sind beispielsweise:\n\nPOTENZ()\nREST()\nNICHT()\nABS()\nTEIL()\n\n\n\n\n\n\n\nMerke\n\n\n\nBeliebige Transformationen lassen sich mit MAP() umsetzen.\n\n\n\n11.6.1 Skalartransformation\nBei Transformationen mit einem Skalar, wird die Transformation für jeden Wert des Vektors und dem Skalar durchgeführt.\n\nBeispiel 11.9 (Verdoppeln von Werten durch Skalartransformation)  \n= 2 * A2:A5\nDiese Operation entspricht den folgenden Einzeloperationen.\n= 2 * A2\n= 2 * A3\n= 2 * A4\n= 2 * A5\n\n\n\n11.6.2 Vektortransformation\nBei der Vektortransformation wird eine Operation paarweise auf die Werte an der gleichen Position von zwei Vektoren angewendet.\n\n\n\n\n\n\nMerke\n\n\n\nDamit das Ergebnis einer Vektor-Transformation in Excel wieder einen Vektor ergibt, müssen beide Vektoren die gleiche Orientierung und die gleiche Länge haben. D.h. es können nur Zeilenvektoren mit Zeilenvektoren bzw. Spaltenvektoren mit Spaltenvektoren transformiert werden\n\n\n\n\n\n\n\n\nMerke\n\n\n\nAlle Excel-Operatoren können für Vektortransformationen verwendet werden.\n\n\n\nBeispiel 11.10 (Werte paarweise addieren)  \n= A1:A5 + B1:B5\nDiese Operation entspricht den folgenden Teiloperationen:\n= A1 + B1\n= A2 + B2\n= A3 + B3\n= A4 + B4\n= A5 + B5\n\n\n\n11.6.3 Bedingungen als Transformationen\nSpezielle Transformationen sind Bedingungen. Dabei wird ein Vektor erzeugt, dessen Werte durch einen oder mehrere logische Ausdrücke bestimmt werden.\nExcel wertet eine Bedingung über Vektoren für jeden Wert des Vektors separat aus. Die Bedingung in Beispiel 11.11 wertet die Bedinung für die Werte an A2, A3, A4 und A5 sowohl im logischen Ausdruck als auch in den Alternativen separat aus.\n\nBeispiel 11.11 (Bedingte Transformation)  \n= LET(vektor; A2:A5; WENN( vektor &gt; 200; vektor; -1))\nDas entspricht den folgenden Operationen.\n= WENN( A2 &gt; 200; A2; -1)\n= WENN( A3 &gt; 200; A3; -1)\n= WENN( A4 &gt; 200; A4; -1)\n= WENN( A5 &gt; 200; A5; -1)\nDie Verwendung von LET() dient nur zum Verdeutlichen, dass der gleiche Vektor sowohl im logischen Ausdruck als auch in der Option Falls Wahr verwendet wird.\n\nWeil die logischen Funktionen UND(), ODER() und XODER() Aggregatoren sind, können sie nicht für Vektortransformationen verwendet werden, sondern müssen in Transformationen durch die entsprechenden arithmetischen Operationen ersetzt werden (Beispiel 11.12).\n\nBeispiel 11.12 (Bedingte Transformation mit einem mit Und verknüpften logischen Ausdruck)  \n= LET(vektor; A2:A5; WENN( (vektor &gt; 200)*(vector &lt; 300); vektor; -1))\nDie Operation entspricht den folgenden Einzeloperationen:\n= WENN( UND(A2 &gt; 200; A2 &lt; 300); A2; -1)\n= WENN( UND(A3 &gt; 200; A3 &lt; 300); A3; -1)\n= WENN( UND(A4 &gt; 200; A4 &lt; 300); A4; -1)\n= WENN( UND(A5 &gt; 200; A5 &lt; 300); A5; -1)\n\n\n\n\n\n\n\nPraxis\n\n\n\nEinzeloperationen über Vektoren sollten in der Praxis immer durch die entsprechenden Vektoroperationen ersetzt werden. Nur so lassen sich typische Excel-Fehler systematisch vermeiden und die Reaktionszeit von komplexen Arbeitsmappen deutlich beschleunigen.\n\n\n\n\n11.6.4 Rezept: Beliebige Werte wiederholen\nExcel fehlt eine Funktion zum Wiederholen von beliebigen Werten. Mithilfe von Sequenzen kann diese Funktionalität leicht nachgebaut werden. Dazu wird eine Sequenz der gewünschten Länge erzeugt und anschliessend für jeden dieser Werte der Wiederholungswert zurückgegeben (Beispiel 11.13). Der Wiederholungswert ist dabei ein Skalar, der für jeden Wert des erzeugten Sequenzvektors zurückgegeben wird.\n\nBeispiel 11.13 (Zeichenkette Daten zehn Mal wiederholen)  \n= WENN(SEQUENZ(10); \"Daten\")",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Vektoroperationen</span>"
    ]
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#aggregationen",
    "href": "kapitel/vektor-operationen/kapitel.html#aggregationen",
    "title": "11  Vektoroperationen",
    "section": "11.7 Aggregationen",
    "text": "11.7 Aggregationen\nBeim Aggregieren werden die Werte eines Vektors durch eine Aggregationsoperation zusammengefasst.\nDass Ergebnis von Aggregationen sind Skalare oder Vektoren mit einer Länge von maximal der Länge des ursprünglichen Vektors.\nHäufig verwendete Funktionen zum Aggregieren sind:\n\nSUMME()\nPRODUKT()\nANZAHL()\nMAX()\nMIN()\nMITTELWERT()\n\n\n\n\n\n\n\nMerke\n\n\n\nBeliebige Aggregationen lassen sich mit REDUCE() umsetzen.\n\n\n\n11.7.1 Filtern als Aggregation\nDas Filtern ist eine spezielle Aggregation, bei der das Ergebnis nur die Werte enthält, auf welche ein logischer Ausdruck zutrifft. Das Ergebnis einer Filter-Operation kann maximal die gleiche Länge haben, wie der zu filternde Vektor. Die Aggregationsfunktion zum Filtern wertet den logischen Ausdruck zur Auswahl der Werte aus.\n\n\n11.7.2 Rezept: Laufende Summe\nEine laufende Summe oder kumulative Summe liefert für jeden Wert eines Vektors die Summe des Werts mit den Vorgängerwerten. Diese Operation ist eine spezielle Aggregation. Excel verfügt keine eigene Funktion für diese Aggregation. Stattdessen kann sie mit Listing 11.1 erzeugt werden.\n\n\n\nListing 11.1: Kumulative Summe\n\n\n= SCAN(0; A2:A100; LAMBDA(accu; wert; accu + wert))\n\n\n\nUm die laufende Summe herzuleiten, muss sich die Aggregation der normalen Summe als Reduktion mit REDUCE() veranschaulicht werden (s. Listing 11.2)\n\n\n\nListing 11.2: Summen-Aggregation\n\n\n= REDUCE(0; A2:A100; LAMBDA(accu; wert; accu + wert))\n\n\n\nBeim Reduzieren mit REDUCE() muss immer ein Initialwert angegeben werden, dem der zu aggregierende Vektor folgt. Abschliessend wird die Aggregationsfunktion angegeben. Beim Reduzieren wird die Aggregationsfunktion für jeden Wert im Vektor nacheinander ausgeführt. Eine Aggregationsfunktion hat zwei Parameter: Der erste Parameter ist das Ergebnis der Aggregationsfunktion für die vorangegangenden Werte, wobei für den ersten Wert der Initialwert verwendet wird. Der zweite Parameter ist der Wert an einer Position im Vektor.\nIn der Praxis ist die Funktion SUMME() dem Reduzieren mit REDUCE() immer vorzuziehen. Für die kumulative Summe fehlt aber eine entsprechende Funktion. Für diese Aggregation kann die Funktion SCAN() anstelle von REDUCE() verwendet werden. SCAN() erzeugt einen Vektor mit den Teilergebnissen einer Aggregationsfunktion. Dieser aggregierte Vektor hat die gleiche Länge wie der ursprüngliche Vektor.\n\n\n11.7.3 Kombinierte Transformation und Aggregation\nSehr häufig werden Vektortransformationen und Aggregationen kombiniert. Zur Veranschaulichung dient hier die Subtraktion von zwei Werten in einem Zahlenvektor. Dazu wird ein Vektor der Länge 2 angenommen. Der erste Wert in diesem Vektor soll von dessen zweiten Wert abgezogen werden. Excel hat allerdings keine Funktion zur Subtraktion, sondern nur die Funktion SUMME(). Für die Subtraktion müssen die Werte so angepasst werden, dass diese Werte summiert werden können. Dazu wird eine Vektortransformation in Form einer Multiplikation mit dem konstanten Vektor {-1; 1} durchgeführt (Listing 11.3).\n\n\n\nListing 11.3: Vorbereitende Vektortransformation\n\n\n= A1:A2 * {-1; 1}\n\n\n\nNun ist sichergestellt, das der erste Wert vom zweiten Wert abgezogen wird. Hier gilt zu beachten, dass die Subtraktion unabhängig von den Werten definiert wird. Diese Vorbereitung ermöglicht es, den transformierten Vektor als Parameter für die Summenfunktion zu verwenden. Die vollständige Lösung ist in diesem Fall die folgende Excel Formel:\n\n\n\nListing 11.4: Subtraktion als kombinierte Vektortransformation und Aggregation\n\n\n= SUMME(A1:A2 * {-1; 1})",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Vektoroperationen</span>"
    ]
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#zählen",
    "href": "kapitel/vektor-operationen/kapitel.html#zählen",
    "title": "11  Vektoroperationen",
    "section": "11.8 Zählen",
    "text": "11.8 Zählen\nBeim Zählen werden zählbare Einheiten von nicht-zählbaren Einheiten getrennt und die Anzahl der zählbaren Einheiten bestimmt. Die einfachste Form des Zählens ist das Bestimmen der Länge eines Vektors. Dabei wird die Anzahl der Werte des Vektors gezählt.\nAlle Zählen-Operationen bestehen entsprechend immer aus zwei Schritten:\n\nEiner Transformation zum Identifizieren der zählbaren Einheiten\nEiner Aggregation zum eigentlichen Zählen.\n\nDie Funktionen ANZAHL() zählt nur Werte vom Datentyp Zahl. Wahrheitswerte, Zeichenketten, Fehler und leere Zellen werden von dieser Funktion ignoriert. Die Funktion ANZAHL2() zählt die nicht leeren Zellen in einem Bereich unabhängig vom Datentyp. Diese Funktion zählt auch Fehlerwerte mit.\n\n11.8.1 Zählen durch Summieren\nBeim Zählen durch Summieren werden die zählbaren Elemente eines Vektors mithilfe eines logischen Ausdrucks transformiert. Daraus ergibt sich ein Vektor aus Wahrheitswerten. Dieser Vektor wird in einem zweiten Schritt mit der SUMME()-Funktion aggregiert.\nAuf diese Weise lassen sich gezielte Häufigkeiten bestimmen.\n\n\n\n\n\n\nMerke\n\n\n\nVektoren, die nur die Werte 0 und 1 bzw. FALSCH und WAHR beinhalten, legen das Zählen durch Summieren nahe.\n\n\n\nBeispiel 11.14 (Zählen durch Summieren)  \n= SUMME(data_ab[Punkte] &lt; 100)\n\n\n\n11.8.2 Zählen durch Filtern\nBeim Zählen durch Filtern werden die zählbaren Einheiten durch eine Filter-Aggregation isoliert. Die Anzahl der zählbaren Einheiten entspricht immer der Länge des gefilterten Vektors.\n\nBeispiel 11.15 (Zählen durch Filtern)  \n= ANZAHL2(FILTER(data_ab[Punkte] &lt; 100))\n\n\n\n\n\n\n\nMerke\n\n\n\nZählen durch Filtern sollte nur dann eingesetzt werden, wenn der Ergebnisvektor für weitere Operationen benötigt wird. Ist dies nicht der Fall, ist das Zählen durch Summieren effizienter.\n\n\n\n\n11.8.3 Zählen durch Nummerieren\nBeim Zählen durch Nummerieren werden die zu zählenden Werte eines Vektors nummeriert. Anschliessend wird der Maximal-Wert der Nummerierung bestimmt. Diese Technik nutzt aus, dass beim Nummerieren im Hintergrund eine Sequenz mit der Schrittweite 1 verwendet wird. Das letzte zählbare Element hat erhält so automatisch die Anzahl aller Element als Nummer.\n\nBeispiel 11.16 (Zählen durch Nummerieren)  \n= MAX(SEQUENZ(ZEILEN(daten_ab[[Punkte]])))\n\n\n\n\n\n\n\nMerke\n\n\n\nZählen durch Nummerieren sollte nur verwendet werden, wenn die Nummerierung entweder bereits vorliegt oder für weitere Operationen benötigt wird.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Vektoroperationen</span>"
    ]
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html",
    "href": "kapitel/matrix-operationen/kapitel.html",
    "title": "12  Matrix-Operationen",
    "section": "",
    "text": "12.1 Matrizen erstellen\nWie auch bei Vektoren übernimmt Excel keine Überprüfung der Bedinungen, ob tatsächlich eine Matrix in einem Bereich vorliegt.\nIn Excel können Matrizen auf drei Arten erstellt werden.\nBei der direkten Eingabe werden die Werte direkt in einen Bereich in Excel eingegeben. Am einfachsten wird dazu der Bereich der Matrix mit der Maus markiert und anschliessend werden die Werte eingegeben und mit der Eingabetaste oder der Tabulatortaste bestätigt. Excel bewegt die Markierung für die aktive Zelle im markierten Bereich automatisch an die nächste freie Position: Wird mit der Eingabetaste bestätigt, dann bewegt Excel die Eingabemarkierung spaltensweise durch den markierten Bereich. Wird die Eingabe mit der Tabulatortaste bestätigt, dann bewegt Excel die Eingabemarkierung zeilenweise durch den markierten Bereich.\nLiegt eine Vektorform einer Matrix vor, dann kann sie mit den Funktionen ZEILENUMBRUCH() oder SPALTENUMBRUCH() in eine Matrix mit einer festen Spalten- bzw. Zeilenzahl erzeugt werden. Neben dem Ausgangsvektor erwarten diese Funktionen die Länge einer Zeile bzw. einer Spalte. Damit ein Vektor in eine Matrix konvertiert werden kann, muss die Länge des Vektors durch die Zeilen- bzw. Spaltenlänge teilbar sein. Erfüllt ein Vektor dieses Kriterium nicht, dann füllt Excel die Positionen bis zur vollständigen Zeile bzw. Spalte mit dem Wert #NV auf.\nJede Transformation mit einem Spalten- und einem Zeilenvektor erzeugt in Excel eine Matrix (s. Abschnitt 12.6.4). Dabei werden die Werte über Kreuz ausgewertet, so dass jede Position der Matrix einer paarweisen Operation entspricht. Die dimensionalität der so erzeugten Matrix ist immer die Zeilenanzahl des Spaltenvektors und die Spaltenanzahl des Zeilenvektors.\nMit den beiden Generatorfunktionen SEQUENZ() und ZUFALLSMATRIX() lassen sich Werte in matrizenartigen Bereichen erzeugen. Dazu wird die gewünschte Zeilen- und Spaltenanzahl als die ersten beiden Argumente übergeben. Die beiden Funktionen füllen anschliessend den angegebenen Bereich mit Werten.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matrix-Operationen</span>"
    ]
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrizen-erstellen",
    "href": "kapitel/matrix-operationen/kapitel.html#matrizen-erstellen",
    "title": "12  Matrix-Operationen",
    "section": "",
    "text": "Durch direkte Eingabe\nDurch das Überführen aus der Vektorform\nDurch eine Operation mit einem Zeilen und einem Spaltenvektors\nErzeugen durch eine Generatorfunktion\n\n\n\n\nBeispiel 12.1 (Matrix aus einer Sequenz erzeugen)  \n=ZEILENUMBRUCH(SEQUENZ(12); 3)\n\n\n\n\n\n\n\n\nMerke\n\n\n\nOperationen über einem Spalten- und einem Zeilenvektor entsprechen dem äusseren Produkt. Das äussere Produkt ist in Excel nur für Vektoren definiert!",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matrix-Operationen</span>"
    ]
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrixdimensionen",
    "href": "kapitel/matrix-operationen/kapitel.html#matrixdimensionen",
    "title": "12  Matrix-Operationen",
    "section": "12.2 Matrixdimensionen",
    "text": "12.2 Matrixdimensionen\nDie Dimensionen einer Matrix ergibt sich aus den Funktionen ZEILEN() und SPALTEN(). Beide Werte müssen getrennt bestimmt werden.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matrix-Operationen</span>"
    ]
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrixwerte-referenzieren",
    "href": "kapitel/matrix-operationen/kapitel.html#matrixwerte-referenzieren",
    "title": "12  Matrix-Operationen",
    "section": "12.3 Matrixwerte referenzieren",
    "text": "12.3 Matrixwerte referenzieren\nDie Werte einer Matrix werden mit der Funktion INDEX() referenziert. Diese Funktion hat drei Parameter.\n\nDie Matrix\nDer Zeilenindex des gesuchten Werts\nDer Spaltenindex der gesuchten Werts.\n\nFür den Zeilen- und den Spaltenindex können Vektoren angegeben werden, um mehrere Werte auf einmal zu referenzieren.\n\n\nBeispiel 12.2 (Werte der Matrix Diagonalen referenzieren)  \n= INDEX(A1:D4; SEQUENZ(4); SEQUENZ(4))\nWeil diese Operation die gleiche Sequenz zwei Mal erzeugt, lässt sie sich mit LET() vereinfachen.\n=LET(\n    diagonalenIndex; SEQUENZ(4);\n    INDEX(A1:D4; diagonalenIndex; diagonalenIndex)\n)\n\n\nUm einzelne Spalten bzw. Zeilen zu referezieren sollten die Funktionen SPALTENWAHL() bzw. ZEILENWAHL() verwendet werden, weil sie nur einen Indexwert benötigen.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matrix-Operationen</span>"
    ]
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#vektorform",
    "href": "kapitel/matrix-operationen/kapitel.html#vektorform",
    "title": "12  Matrix-Operationen",
    "section": "12.4 Vektorform",
    "text": "12.4 Vektorform\nDie Vektorform einer Matrix wird in Excel durch die Funktionen ZUSPALTE() bzw. ZUZEILE() erzeugt. Die beiden Funktionen unterscheiden sich nur durch die Orientierung des Ergebnisvektors. Die zeilenweise Vektorform wird standardmässig von beiden Funktionen erzeugt. Um eine spaltenweise Vektorform zu erhalten, kann der dritte Parameter scan_by_column auf WAHR gesetzt werden.\n\n\n\n\n\n\nPraxis\n\n\n\nEnthält eine Matrix fehlende Werte, die durch den Fehlerwert #NV markiert sind, lassen sich diese in der Vektorform direkt entfernen, indem der zweite Parameter auf 2 (Fehlerwerte ignorieren) bzw. 3 (Leere Zellen und Fehlerwerte ignorieren) gesetzt wird.\nDabei muss beachtet werden, sich die Matrix anschliessend nicht mehr aus dem Vektor reproduzieren lässt.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matrix-Operationen</span>"
    ]
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrizen-vergleichen",
    "href": "kapitel/matrix-operationen/kapitel.html#matrizen-vergleichen",
    "title": "12  Matrix-Operationen",
    "section": "12.5 Matrizen vergleichen",
    "text": "12.5 Matrizen vergleichen\nZwei Matrizen sind genau dann gleich, wenn sie gleiche Anzahl von Zeilen und Spalten sowie an jedem Index den gleichen Wert haben. Intuitiv bietet sich der paarweise Vergleich der Indizes an. Existieren nicht alle Indizes in der jeweils anderen Matrix, füllt Excel die fehlenden Indizes mit einem Fehler auf. Das führt dazu, dass die logische Verknüpfung in diesen Fällen einen Fehler zurückgibt. Deshalb ist es notwendig, dass zusätzlich gprüft wird, ob das Ergebnis dieser Operation einen Fehlerwert ergibt (Beispiel 12.3).\n\nBeispiel 12.3 (Formel zum Vergleich von zwei Matrizen)  \n= WENNFEHLER(\n    UND(\n        Matrix1!A1# = Matrix2!A1#\n    );\n    FALSCH\n)\n\nEin zweiter praktischer Vergleich ist das Überprüfen einer quadratischen Matrix. Dabei wir nur eine Matrix geprüft. Weil die Werte in diesem Fall keine Bedeutung haben ist die Formel sehr einfach (Beispiel 12.4).\n\nBeispiel 12.4 (Überprüfen einer quadratischen Matrix)  \n= ZEILEN(Matrix1!a1#) = SPALTEN(Matrix1!A1#);",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matrix-Operationen</span>"
    ]
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrix-operationen",
    "href": "kapitel/matrix-operationen/kapitel.html#matrix-operationen",
    "title": "12  Matrix-Operationen",
    "section": "12.6 Matrix Operationen",
    "text": "12.6 Matrix Operationen\n\n12.6.1 Matrizen Transponieren\nMatrizen werden mit der Funktion MTRANS() transponiert. Dabei werden die Zeilen- und Spaltenindizes getauscht.\n\nBeispiel 12.5 (Eine Matrix transponieren)  \n= MTRANS(Matrix1!A1#)\n\n\n\n12.6.2 Skalar- und Vektoroperationen\nAlle Skalaroperationen werden von Excel wie erwartet ausgeführt: die Operation wird mit dem Skalar für jeden Wert der Matrix ausgeführt.\nBei Vektoroperationen ist die Orientierung des Vektors für das Verhalten der Operation bestimmend.\n\nSpaltenvektoren werden spaltenweise mit der Matrix verknüpft. Dabei werden die Werte mit dem jeweils gleichen Zeilenindex zusammengefasst.\nZeilenvektoren werden zeilenweise mit der Matrix verknüpft. Dabei werden die Werte mit dem jeweils gleichen Spaltenindex zusammengefasst.\n\n\n\nBeispiel 12.6 (Orientierung bei der Verknüpfung eines Vektors und einer Matrix.)  \n= SEQUENZ(4) + SEQUENZ(4; 4)\nObwohl die folgende Operation sehr ähnlich aussieht, hat sie ein anderes Ergebnis.\n= SEQUENZ(1; 4) + SEQUENZ(4; 4)\n\n\nIn beiden Fällen gilt, dass der Vektor genauso viele Zeilen bzw. Spalten haben muss, wie die verknüpfte Matrix, so dass für die Verknüpfungsoperation beide Operanden vorhanden sind. Fehlt einer der Operanden, dann ist die Verknüpfung für diesen Index nicht definiert, so dass Excel für diese Positionen einen #NV-Fehler erzeugt.\n\nDefinition 12.1 Excel führt eine unvollständige bzw. partielle Vektoroperation durch, wenn nicht alle Indizes entweder im Vektor oder in der Matrix vorhanden sind.\n\n\nBeispiel 12.7 (Orientierung bei der Verknüpfung eines Vektors und einer Matrix.)  \n= SEQUENZ(5) + SEQUENZ(4; 4)\n\n\n\n\n\n\n\nAchtung\n\n\n\nFür Skalar- und Vektoroperationen sind nur Operatoren und Funktionen zulässig, die einen Skalar zum Ergebnis haben. Grundsätzlich sind alle Arithmetischen und Vergleichsoperatoren sowie der Textketten-Operator & für Skalar- und Vektoroperationen geeignet.\nManche Operationen erzeugen einen Fehler, andere geben bei überschüssigen Werten den jeweils ersten Index aus.\n\n\n\n\n12.6.3 Kreuzprodukt/Matrixprodukt\nDas Kreuzprodukt (oder innere Matrixprodukt) ist die Entsprechung zur Multiplikation von zwei Skalaren. Diese Operation wird in Excel durch die Funktion MMULT() ausgeführt. Das Kreuzprodukt ist nicht transitiv. Deshalb ist die Reihenfolge der Operanden wichtig, denn für das Kreuzprodukt muss die Spaltenlänge der linken Matrix mit der Zeilenlänge der rechten Matrix übereinstimmen. Ist diese Bedinung nicht gegeben, dann erzeugt Excel einen #WERT!-Fehler.\nDas Ergebnis des Kreuzprodukts ist eine Matrix mit der Zeilenlänge der linken und der Spaltenlänge der rechten Matrix.\nWeil das Kreuzprodukt die Summe mit der Multiplikation verbindet, ergeben sich interessante Vereinfachungen, wenn die Werte einer Matrix nur die Werte 0 und 1 sind (s. Kapitel 12.8.1 und Kapitel 12.8.3).\n\n\nBeispiel 12.8 (Die Funktion SUMMENPRODUKT() als Kreuzprodukt) Die Funktion SUMMENPRODUKT() zwischen zwei Vektoren lässt sich auch als Kreuzprodukt formulieren:\n= MMULT(SEQUENZ(1;4); SEQUENZ(4))\nDas Ergebnis dieser Operation ist eine 1 \\times 1-Matrix (bzw. ein Skalar), weil die linke Matrix nur eine Zeile und die rechte Matrix nur eine Spalte hat.\n\n\n\n\n12.6.4 Das äussere Produkt\nIn Excel ist das äussere Produkt nur für Vektoren (bzw. 1,n- oder m,1-Matrizen) definiert. Dabei müssen die Vektoren unterschiedliche Orientierungen haben. Das Ergebnis ist dann eine m \\times n-Matrix, wobei m die Länge des Spaltenvektors und n die Länge des Zeilenvektors ist.\n\nBeispiel 12.9 (Multiplikationstabelle für das kleine Einmaleins erstellen)  \n= SEQUENZ(10) * SEQUENZ(1;10)\n\nDas äusser Produkt ist nicht auf die Multiplikation beschränkt, sondern für beliebige Operationen, wobei die Operation einen Skalar zum Ergebnis haben muss. Dieser Wert wird am Kreuzungsindex der Ergebnismatrix eingesetzt.\nDiese Eigenschaft wird dazu ausgenutzt, um Matrizen mit speziellen Eigenschaften zu konstruieren (Abschnitt 12.8.2).\n\n\n\n\n\n\nAchtung\n\n\n\nWerden beliebige Matrizen auf die gleiche Weise verknüpft, führt Excel eine paarweise Verknüpfung aus, die für alle nicht exisiterenden Index-Paare den Fehlerwert #NV erzeugt (Abschnitt 12.6.5).\n\n\nWird ein Vergleich als Operator für das äussere Produkt verwendet, dann ist das Ergebnis der Operation ein Wahrheitswert. Um diesen Wahrheitswert in eine Zahl umzuwandeln, muss eine arithmetische Operation nachgereiht werden. Hierzu ist die Multiplikation mit 1 oder die Addition mit 0 üblich.\n\nBeispiel 12.10 (Äusseres Produkt zum Erzeugen einer Dreiecksmatrix)  \n= 1 * (SEQUENZ(4) &lt;= SEQUENZ(1;4))\n\n\n\n12.6.5 Paarweise Operationen\nWerden beliebige Matrizen miteinander verknüpft, dann führt Excel eine paarweise Verknüpfung aus. D.h. ein Operator oder eine Funktion wird paarweise für die Werte mit den gleichen Indizes ausgeführt. Dabei handelt es sich um eine Verallgemeinerung der Vektoroperation (Abschnitt 12.6.2), wobei wie auch bei den Vektoroperationen die Operation nur ausgeführt werden kann, wenn für beide Operanden in der jeweiligen Matrix ein Wert existiert.\nBei paarweisen Operationen mit zwei Matrizen müssen beide Matrizen die gleichen Dimensionen haben. Ist diese Bedingung nicht gegeben, führt Excel eine partielle Verknüpfung (Definition 12.1) aus.\n\n\n\n\n\n\nMerke\n\n\n\nZwischen den paarweisen Operationen und dem äusseren Produkt besteht kein Zusammenhang. Für Vektoren bzw. 1 \\times n-Matrizen führt Excel immer das äussere Produkt aus, für alle anderen Matrizen paarweise Operationen.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matrix-Operationen</span>"
    ]
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#mathematische-hilfsoperationen",
    "href": "kapitel/matrix-operationen/kapitel.html#mathematische-hilfsoperationen",
    "title": "12  Matrix-Operationen",
    "section": "12.7 Mathematische Hilfsoperationen",
    "text": "12.7 Mathematische Hilfsoperationen\nNeben den bereits vorgestellten Operationen verfügt Excel über drei weitere Funktionen für quadratische Matrizen.\n\nMEINHEIT()\nMINV()\nMDET()\n\n\n12.7.1 Identitätsmatrix erzeugen\nDie Funktion MEINHEIT() erzeugt eine Identitätsmatrix mit der angegebenen Zeilen-/Spaltenanzahl. Die Identitätsmatrix ist eine quadratische Diagonalmatrix mit den Wert 1 entlang der Diagonalen und dem Wert 0 an allen anderen Positionen.\n\nBeispiel 12.11 (Einheitsmatrix der Grösse 5)  \n= MEINHEIT(5)\n\n\n\n12.7.2 Determinante\nEine wichtige Kennzahl für quadratische Matrizen ist die Determinante. Sie wird mit der Funktion MDET() berechnet.\n\nBeispiel 12.12 (Bestimmung der Determinante einer Matrix)  \n=MDET(SPALTENUMBRUCH(SEQUENZ))\n\n\n\n12.7.3 Inverse Matrix\nFür viele Berechnungen ist die Inverse A^{-1} einer quadratischen Matrix A notwendig. Falls eine Matrix invertierbar ist, gibt die Funktion MINV() die Inverse zurück. Diese Funktion löst die Gleichung A \\times A^{-1} = I und bestimmt die Inverse Matrix A^{-1}.\n\nBeispiel 12.13 (Inverse einer 4 \\times 4-Matrix)  \n=MINV(\n    ZEILENUMBRUCH(\n        SEQUENZ(16);\n        4\n    )\n)\n\nIst die Matrix nicht invertierbar, dann gibt die Funktion den Fehler #ZAHL! zurück. In diesem Fall ist die Determinante gleich 0.\n\nBeispiel 12.14 (Nicht-invertiertbare 4 \\times 4-Matrix)  \n=MINV(\n    SPALTENUMBRUCH(\n        SEQUENZ(16);\n        4\n    )\n)\n\nWird der Funktion keine quadratische Matrix übergeben, dann hat diese Funktion einen #WERT! zum Ergebnis.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matrix-Operationen</span>"
    ]
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#rezepte",
    "href": "kapitel/matrix-operationen/kapitel.html#rezepte",
    "title": "12  Matrix-Operationen",
    "section": "12.8 Rezepte",
    "text": "12.8 Rezepte\nDie folgenden Rezepte Nutzen das Kreuzprodukt und das äussere Produkt.\n\n12.8.1 Zeilen- und Spaltensummen\nEs sollen die Summen für jede Zeile einer Matrix (oder Tabelle) berechnet werden und das Ergebnis soll ein Vektor sein.\n\n\n\n\n\n\nHinweis\n\n\n\nFür die Excel-Formeln wird angenommen, dass eine Matrix an der Adresse M1 vektorisiert vorliegt. In der Praxis muss den entsprechenden Parametern die korrekte Adresse der Matrix übergeben werden.\n\n\n\n12.8.1.1 Lösung\n= MMULT(M1#; SEQUENZ(SPALTEN(M1#);1;1;0))\n\n\n\n\n\n\nPraxis\n\n\n\nDiese Operation ist bei der Arbeit mit Excel wichtig, weil diese Operation in Excel effizienter ist, als zeilenweise Aggregationen über vektorisierte oder nicht-verktorisierte Daten.\n\n\n\n\n12.8.1.2 Erklärung\nUm Zeilensummen für eine Matrix zu erstellen, nutzen wir die Eigenschaften des Kreuzprodukts aus und multiplizieren eine Matrix mit dem Einsvektor. Das Ergebnis dieser Operation ist ein Vektor, der in jeder Zeile die Summe der Werte aus der entsprechenden Zeile der Matrix enthält.\nDas Kreuzprodukt ist nur für Matrizen definiert, wenn die erste (linke) Matrix A gleich viele Spalten hat, wie die Zeilenanzahl der zweiten (rechten) Matrix B. Die Ergebnismatrix des Kreuzprodukts hat gleich viele Zeilen, wie die erste Matrix und gleich viele Spalten wie die zweite. Für jede Position c_{ij} der Ergebnismatrix C gilt dann die folgende Formel:\n\nc_{ij} = \\sum^n_{k=1}{a_{ik}b_{kj}}\n\nUm die Zeilensummen einer Matrix A zu erhalten, müssen wir die Matrix B entsprechend konstruieren.\n\nMatrix B darf nur eine Spalte haben, damit die Ergebnismatrix nur eine Spalte hat.\nMatrix B darf die Werte in Matrix A nicht verändern.\nMatrix B muss gleich viele Zeilen haben, wie Matrix A Spalten hat.\n\nDiese Anforderungen 1 und 2 werden durch den Einsvektor mit n-Zeilen erfüllt. Dabei nutzen wir aus, dass ein Spaltenvektor das gleiche wie eine Matrix mit einer Spalte ist.\nDie Anforderungen 3 können wir über die Spaltenzahl der Matrix bestimmen und erstellen dann einen Einsvektor mit entsprechender Zeilenanzahl.\nDaraus ergibt sich für den Einsvektor v_e und der Matrix an Adresse M1 die Formel:\n=SEQUENZ(SPALTEN(M1#); 1; 1; 0)\nWeil der Einsvektor an jeder Position das neutrale Element der Multiplikation enthält, vereinfacht sich die Formel für das Kreuzprodukt stark:\n\nc_{i1} = \\sum^n_{k=1}{a_{ik}}\n\nBei dieser Formel ist zu beachten, dass die 1 in c_{i1} für die einzige Spalte des Einsvektors steht und i für die Zeilen in der Matrix A. Daraus wird deutlich, dass wir nun die Zeilensummen für die Matrix A erhalten.\nDer Einsvektor muss bei dieser Operation als die rechte Matrix eingesetzt werden, sodass gilt:\n\nA \\times v_e\n\nAls Excel-Formel wird das wie folgt ausgedrückt:\n=MMULT(M1#; SEQUENZ(SPALTEN(M1#); 1; 1; 0))\nAus dieser Lösung lässt sich auch die Spaltensumme ableiten: Für die Spaltensumme muss das neutrale Element der Multiplikation in die erste Matrix wandern. Dazu wird ein Zeilenvektor erstellt und mit diesem das Kreuzprodukt mit der Matrix gebildet. Weil in diesem Fall die Spaltensumme gebildet werden soll, kommen die Werte für die Spalten aus der rechten Matrix. Deshalb müssen wir das Kreuzprodukt wie folgt bilden:\n\nv_e \\times B\n\nDaraus ergibt sich die folgende Excel-Formel:\n= MMULT(SEQUENZ(1; ZEILEN(M1#); 1; 0); M1#)\n\n\n\n\n\n\nPraxis\n\n\n\nBei der Zeilen- und Spaltensumme handelt es sich um ein sogenanntes Muster, dass an verschiedenen Stellen verwendet werden kann. Ein Muster ist im Kern eine Funktion, die parametrisiert werden kann.\n\n\nWir können dieses Muster mit der Funktion LET() (zum Exkurs über die LET()-Funktion) so anpassen, dass wir den Bereich für unsere Matrix nur einmal anpassen müssen.\nDaraus ergeben sich die folgenden Excel-Formeln:\n\nZeilensumme: = LET(Matrix; M1#; MMULT(Matrix; SEQUENZ(SPALTEN(Matrix); 1; 1; 0)))\nSpaltensumme: = LET(Matrix; M1#; MMULT(SEQUENZ(1; ZEILEN(Matrix); 1; 0); Matrix))\n\n\n\n\n12.8.2 Dreieckmatrizen erzeugen\nEs soll eine quadratische Dreiecksmatrix mit n-Zeilen erzeugt werden.\n\n12.8.2.1 Lösung\nDie Anzahl der Zeilen befindet sich in diesem Beispiel an Adresse A1.\nObere Dreiecksmatrix\n= 1 * (SEQUENZ(A#) &lt;= SEQUENZ(1; A1#))\nUntere Dreiecksmatrix\n= 1 * (SEQUENZ(A#) &gt;= SEQUENZ(1; A1#))\n\n\n12.8.2.2 Erklärung\nBei einer Dreiecksmatrix steht unterhalb bzw. oberhalb der Diagonalen der Wert 1 und sonst der Wert 0. Gelegentlich (wie in der obigen Lösung) wird die Diagonale zu den mit 1 belegten Positionen hinzugezählt.\nDie Lösung nutzt aus, dass Excel bei unterschiedlich orientierten Vektoren das äussere Produkt bildet und so eine Matrix erzeugt. Die Basis für diese Operation bilden zwei Sequenzen, die über kreuz verglichen werden.\nDie Sequenzen können dabei als Nummerierungen der Matrixpositionen verstanden werden. Der Vergleich ergibt jeweils bis zur Diagonalen FALSCH und ab der Diagonalen WAHR, weil die Nummerierung der Positionen ab der Diagonalen gleich ist.\nDie Multiplikation mit 1 ist notwendig, damit die Matrix Zahlen und keine Wahrheitswerte enthält.\n\n\n\n12.8.3 Kumulative Summe\nEs soll die kumulative Summe eines Vektors gebildet werden.\n\n12.8.3.1 Lösung\nFür Spaltenvektoren:\n=LET(\n    VLAENGE; ZEILEN(A1#); \n    MMULT(\n        A1#; \n        1 * (SEQUENZ(VLAENGE) &gt;= SEQUENZ(1; VLAENGE))\n    )\n)\nFür Zeilenvektoren:\n=LET(\n    HLAENGE; SPALTEN(A1#); \n    MMULT( \n        1 * (SEQUENZ(HLAENGE) &lt;= SEQUENZ(1; HLAENGE));\n        A1#\n    )\n)\n\n\n12.8.3.2 Erklärung\nDie kumulative Summe dreht die Logik der Zeilen- bzw. Spaltensumme um. In diesem Fall wird eine Matrix erzeugt, die für jede Position im Vektor anzeigt, welche Vektorwerte summiert werden sollen. Entsprechend darf diese Matrix nur die Werte 0 oder 1 enthalten, da die Werte im Ausgangsvektor nicht verändert werden dürfen.\nFür die kumulative Summe müssen alle Werte bis und mit der aktuellen Position summiert werden. Eine Dreiecksmatrix leistet genau diesen Zweck: Für Spaltenvektoren zeigt die untere Dreickesmatrix zeilenweise an, welche Positionen für die kumulative Summe berücksichtigt werden müssen.\nWeil die Diagonale der Dreiecksmatrix die gleiche Länge hat wie der Ausgangsvektor, ist sichergestellt, dass der Ergebnisvektor die gleiche Länge wie der Ausgangsvektor hat.\nDieser Trick funktioniert nur, wenn die das neutrale Element der Multiplikation in der Dreiecksmatrix verwendet wird.\n\n\n\n12.8.4 Co-Occurence Matrizen\nEs sollen die gemeinsam auftretenden Werte in zwei diskretskalierten Vektoren gezählt werden und in einer Kreuztabelle gegenübergestellt werden.\n\n12.8.4.1 Lösung\nFür Spaltenvektoren:\n=MMULT(\n    1 * (EINDEUTIG(A1#) = MTRANS(A1#)); \n    1 * (MTRANS(EINDEUTIG(B1#)) = B1#)\n)\n\n\n12.8.4.2 Erklärung\nIm ersten Schritt werden für jeden Vektor separat die Positionen der eindeutigen Werte in einer Matrix markiert. Die eindeutigen Werte sind die Werte vorkommenden Werte des Wertebereichs. Diese Werte werden mit der Funktion EINDEUTIG() bestimmt. Das Ergebnis des ersten Schritts ist eine Matrix, die nur die Werte 1 und 0 enthält. Der Wert 1 ist an der Position gesetzt, an der ein Wert des Wertebeichs im Ausgangsvektor gefunden wurde.Dazu dient die folgende Formel:\n= 1 * (EINDEUTIG(A1#) = MTRANS(A1#))\nDiese Formel lässt sich auf beide Ausgangsvektoren anwenden. Dadurch ergeben zwei Matrizen mit gleich vielen Spalten, die nur die Werte 1 und 0 enthalten.\nDamit die gemeinsamen Vorkommnisse gezählt werden, wird das Kreuzprodukt verwendet. Dabei wird ausgenutzt, dass das Kreuzprodukt die Produkte der Zeilen- und Spaltenwerte summiert. Weil beide Matrizen nur die Werte 0 und 1 enthalten, entspricht diese Operation dem Zählen durch Summieren.\nDiese Operation zählt nur das gemeinsame Auftreten, weil in beiden Matrizen sichergestellt ist, dass in jeder Spalte genau eine 1 vorkommt, werden nur die Werte an den gleichen Positionen in den Ausgangsvektoren gezählt.\nDamit dieser Trick funktioniert, muss eine der beiden Matrizen transponiert werden, bevor das Kreuzprodukt gebildet werden kann. Daraus ergibt sich die folgende Formel.\n= MMULT(\n    1 * (EINDEUTIG(A1#) = MTRANS(A1#));\n    MTRANS(1 * (EINDEUTIG(B1#) = MTRANS(B1#)))\n)\nAn dieser Formel ist wenig elegant, dass für den zweiten Parameter zwei Mal transponiert wird. Dieser Teilterm lässt sich dadurch vereinfachen, indem die zweite Transponierung bereits bei der Erzeugung der Matrix vorweggenommen wird, denn es gilt:\nMTRANS(1 * (EINDEUTIG(B1#) = MTRANS(B1#)))\nist equivalent mit\n1 * (MTRANS(EINDEUTIG(B1#)) = B1#)\nWird diese Vereinfachung in die obige Formel eingesetzt, dann ergibt sich die Formel der Lösung.\nDas Ergebnis ist eine sog. Kontingenztabelle, die die Häufigkeiten der gemeinsam auftretenden Werte anzeigt.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matrix-Operationen</span>"
    ]
  },
  {
    "objectID": "kapitel/kodieren-gruppieren/kapitel.html",
    "href": "kapitel/kodieren-gruppieren/kapitel.html",
    "title": "13  Indizieren und Gruppieren",
    "section": "",
    "text": "13.1 Indizieren\nEs werden drei Arten von Indizes unterschieden:\nWeil ein Index Werte über einen Datensatz enthält, gehört ein Index zum jeweiligen Datensatz und wird über einen Indexvektor in einer Stichprobe abgebildet.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Indizieren und Gruppieren</span>"
    ]
  },
  {
    "objectID": "kapitel/kodieren-gruppieren/kapitel.html#indizieren",
    "href": "kapitel/kodieren-gruppieren/kapitel.html#indizieren",
    "title": "13  Indizieren und Gruppieren",
    "section": "",
    "text": "Der Primärindex, mit dem ein einzelner Datensatz eindeutig identifiziert werden kann.\nFremdschlüssel sind Sekundärindizes für Querverweise auf eine zweite Datenstruktur (eine sog. Indextabelle oder engl. Lookup-Table).\nGruppenindizes sind Sekundärindizes zur Identifikation von Datensätzen mit gemeinsamen Eigenschaften.\n\n\n\n13.1.1 Hashing eines Primärindex\nIn Excel muss zum Durchnummerieren die SEQUENZ()-Funktion verwendet werden. Das erreichen wir mit der folgenden Operation: =SEQUENZ(ZEILEN(DatenBereich)), wobei DatenBereich eine Excel-Adresse sein muss. Weil mit Excel keine leeren Tabellen existieren, führt diese Sequenz in Excel zu keinen Fehlern. Wegen dieser Eigenschaft muss ein entsprechender Bereich mindestens einen Umfang von einem Datensatz haben.\n\n\n\n\n\n\nHinweis\n\n\n\nDiese Eigenschaft gilt auch für Tabellen, die nur aus Überschriften bestehen. Damit die Formel zum Nummerieren eingegeben werden kann, muss mindestens ein Datensatz existeren, weil sonst keine Zelle für die Formel in der Tabelle existiert.\n\n\n\n\n13.1.2 Hashing eines Sekundärindex\nEin Sekundärindex kennzeichnet mehrere Datensätze mit gleichen Eigenschaften. Die einfachste Hashing-Funktion für Sekundärindizes ist WENNS(). Diese Funktion stellt über die Bedingungen sicher, dass alle Hashes einen Datensatz die Merkmale eindeutig auswerten.\nSoll ein Sekundärindex über Zahlen gebildet werden, werden die Ganzzahldivision und der Modulo-Operator häufig als Hashing-Funktion eingesetzt. Die Ganzzahldivision fasst aufeinanderfolgende Werte zu einem Wert zusammen. Der Modulo-Operator weist aufeinanderfolgenden Werte unterschiedlichen Werten zu.\n\n\n\n\n\n\nPraxis\n\n\n\nExcels Funktion für die Ganzzahldivision ist eigentlich die Funktion QUOTIENT(). Diese Funktion kann leider nur mit einzelnen Werten und nicht mit Vektoren oder Matrizen verwendet werden. Deshalb ist die Funktion QUOTIENT() für die Praxis nur bedingt tauglich. Stattdessen muss die Ganzzahldivision in Excel wie folgt simuliert werden.\n= GANZZAHL( A1:A9 / 3 )\n\n\n\n\nBeispiel 13.1 (Tage und Wochen bestimmen) Gegegeben ist eine Sequenz in A1 Startend bei 1. Diese Sequenz bildet die Werktage eines Projekts ab. Der erste Tag ist ein Montag. Feiertage werden nicht berücksichtigt. Aus dieser Sequenz sollen Wochentage und Wochen ermittelt werden.\nDie Wochennummern im Projekt wird mithilfe der Ganzzahldivision ermittelt.\n= GANZZAHL(A1# / 5)\nDie Wochentage werden mit dem Modulo-Operator bestimmt.\n=  REST(A1#; 5)\n\n\n\n\n13.1.3 Indizieren mit einer Referenztabelle\nOft müssen Werte in andere Werte übersetzt werden, wobei die Kodierung keiner mathematischen Logik folgt. In diesem Fall werden sog. Referenz- oder Kodierungstabellen für das Indizieren verwendet. Sehr oft werden diese Tabellen unabhängig von der Datenerhebung erstellt.\nEine Referenztabelle hat mindestens zwei Spalten, wobei per Konvention die erste Spalte die möglichen Werte vor dem Indizieren. Diese Werte können in den Daten auftreten. Alle folgenden Spalten enthalten Kodierungen des ursprünglichen Werts.\n\n\n\n\n\n\nWarnung\n\n\n\nEnthält eine Referenztabelle mehr als eine Kodierung, dann müssen die Werte spaltenweise kodiert werden.\n\n\n\n\nBeispiel 13.2 (Likert-Skala kodieren) Eine Liker-Skala ist ein Messinstrument zur Meinungs- oder Empfindungserhebung. Eine Likert Skala wird in der Regel zwischen zwei Extremfeststellungen erfasst, die später als Zahlen kodiert ausgewertet werden.\nSolche Skalen erfordern eine Referenztabelle, weil die Ordnung der Werte sich nicht aus der alphabetischen Reihenfolge der Zeichenketten ergibt. Für die Auswertung müssen die Zeichenketten in Zahlen kodiert werden. Es ist üblich die Kodierung von Likert-Skalen in Referenztabellen zu dokumentieren. Die folgende Tabelle zeigt eine fünfstufige Liker-Skala mit den entsprechenden Zahlenwerten für die Auswertung.\n\n\n\nWert\nZahl\n\n\n\n\nTrifft gar nicht zu\n-2\n\n\nTrifft eher nicht zu\n1\n\n\nUnentschieden\n0\n\n\n Trifft eher zu\n1\n\n\n Trifft voll und ganz zu\n2\n\n\n\nDie Kodierung erfolgt mit der Funktion XVERWEIS().\n= XVERWEIS(Tabelle1[Aussage_Likert]; \n           KodierungLikert[Wert]; \n           KodierungLikert[Zahl])",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Indizieren und Gruppieren</span>"
    ]
  },
  {
    "objectID": "kapitel/kodieren-gruppieren/kapitel.html#gruppieren",
    "href": "kapitel/kodieren-gruppieren/kapitel.html#gruppieren",
    "title": "13  Indizieren und Gruppieren",
    "section": "13.2 Gruppieren",
    "text": "13.2 Gruppieren\nDas Gruppieren ist in Excel auf die folgenden Funktionen beschränkt:\n\nZÄHLENWENN()\nZÄHLENWENNS()\nSUMMEWENN()\nSUMMEWENNS()\nMINWENNS()\nMAXWENNS()\nMITTELWERTWENN()\nMITTELWERTWENNS()\n\n\n\n\n\n\n\nWichtig\n\n\n\nDie Funktionen ZÄHLENWENN(), ZÄHLENWENNS(), SUMMEWENN() und SUMMEWENNS() wurden bis 2019 zum Erzeugen von bedingten Aggregationen verwendet. Mit der Einführung dynamischer Felder und der FILTER()-Funktion lassen sich bedingte Aggregationen einfacher und flexibler durch Funktionsverkettungen von FILTER() mit einer beliebigen Aggregationsfunktion erreichen.\nSeit dieser Version hat sich die Bedeutung der Funktionen geändert. Die Funktionen werden neu als Gruppierungsfunktionen verwendet.\n\n\n\n\n\n\n\n\nMerke\n\n\n\nWenn für eine Funktion eine WENN und eine WENNS-Variante existieren, dann sollte für gruppierte Aggregationen immer die WENNS-Variante verwendet werden.\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nDie beiden Funktionen WENN() und WENNS() sind keine Gruppierungsfunktionen, sondern Unterscheidungen. Trotz ähnlicher Namen, dürfen sie nicht mit den Gruppierungsfunktionen verwechselt werden.\n\n\nDie WENNS-Varianten sind für alle Aggregationen bezüglich ihrer Parameter konsistent, so dass die Syntax leichter zu merken ist. Die beiden (neuen) Funktionen MINWENNS() und MAXWENNS() veranschaulichen diese Empfehlung, weil für diese Funktionen keine WENN-Variante existiert.\nEine Gruppierungsoperation erfolgt in drei Schritten:\n\nErzeugen der Gruppierungsindizes.\nErmitteln der Gruppierungen\nAusführen der Gruppierungsfunktion für alle Gruppierungen\n\nBeispiel 13.3 zeigt diese drei Schritte. Gegeben sind Werte zwischen 1 und 25, die in drei Bereiche organisiert werden sollen. Es soll die Anzahl der Werte in den einzelnen Bereichen ermittelt werden. Die Werte liegen in einer Tabellenstruktur vor.\nDer Gruppierungsindex ist ein Merkmal und sollte gemeinsam mit den Daten gespeichert und versioniert werden. Dieser Sekundärindex strukturiert die Daten in einer Tabelle oder einem Bereich.\n\n\nBeispiel 13.3 (Gruppiertes Zählen) Die Reihenfolge der Schritte muss eingehalten werden!\nSchritt 1: Sekundärindex erstellen (in A1)\n= WENNS( Tabelle1[Werte] &gt; 18; \"gross\";\n         Tabelle1[Werte] &gt; 10; \"mittel\"; \n         WAHR; \"klein\" )\nDieser Schritt kann entfallen, wenn ein Sekundärindex bereits vorhanden ist.\nSchritt 2: Gruppierungen ermitteln (in C1)\n= EINDEUTIG(A1#)\nSchritt 3: Zählen (in D1)\n= ZÄHLENWENNS( A1#; C1# )\n\n\nBeim Zählen wird der Gruppierungsindex direkt verwendet. Die anderen Gruppierungsfunktionen haben einen zusätzlichen Parameter für den Vektor über den die Operation ausgeführt werden soll.\n\n13.2.1 Mehrere Sekundärindizes\n\n\n\n\n\n\nWichtig\n\n\n\nDie WENNS-Varianten können mehrere Sekundärindizes verknüpfen. Dabei werden die vorkommenden Permutationen der Hash-Werte als Index verwendet. Alle Kriterienvektoren müssen dafür gleich lang sein und die Permutationen abbilden.\n\n\nUm alle vorkommenden Permutationen mehrerer Sekundärindizes zu ermitteln, müssen die Vektoren einen Bereich bilden. Für diese Bereich ermittelt die Funktion EINDEUTIG() dann jede vorkommende Zeile. Dieser Trick funktioniert jedoch nur wenn alle Sekundärindizes nebeneinander stehen, was oft nicht der Fall ist. Die Funktion HSTAPELN() löst dieses Problem, weil sie mehrere Vektoren zu einem Bereich zusammenfügen kann. Beispiel 13.4 zeigt die Vorgehensweise für drei Vektoren.\n\nBeispiel 13.4 (Vorkommende Permutationen mehrerer Sekundärindizes ermitteln in A1)  \n= LET(bereich; HSTAPELN(\n                Tabelle1[Name]; \n                Tabelle1[Durchlauf]; \n                Tabelle1[Gruppe] );\n      EINDEUTIG(bereich)\n)\n\nDiese Permutationstabelle kann nun mit den Gruppierungsfunktionen verwendet werden. Beispiel 13.5 zeigt die Verwendeung der Gruppierungen aus Beispiel 13.4.\n\nBeispiel 13.5 (Gruppieren mit mehreren Indizes)  \n= MITTELWERTWENNS(\n    Tabelle1[Zeit]; \n    Tabelle1[Name];      SPALTENWAHL(A1#; 1);\n    Tabelle1[Durchlauf]; SPALTENWAHL(A1#; 2); \n    Tabelle1[Gruppe];    SPALTENWAHL(A1#; 3)\n)",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Indizieren und Gruppieren</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-formen/kapitel.html",
    "href": "kapitel/daten-formen/kapitel.html",
    "title": "14  Daten formen",
    "section": "",
    "text": "14.1 Die PIVOTMIT()-Funktion\nSpeziell für die Datenvisualisierung, erfordert Excel das Umformen von Daten. Dabei kann es notwendig werden, die Daten von der Normalform in eine Breitform umzuformen. Auch für andere Operationen kann es sinnvoll sein, Daten eine definierte Form zu geben. Zu diesen Operationen gehören z.B. gruppierte Aggregationen.\nSeit 2024 enthält Excel die Funktion PIVOTMIT(). Diese Funktion erlaubt das Überführen von Daten in eine Kreuztabelle. Diese Funktion hat vier verpflichtende Parameter:\nDiese Funktion ähnelt der den klassischen Pivot-Tabellen stark: Die beiden ersten Parameter liefern Gruppierungswerte, über die eine Zusammenfassung erstellt werden soll. Mit dem Parameter values werden die Werte festgelegt, die zusammengefasst werden sollen. Der vierte Parameter legt die Aggregationsfunktion fest, dabei kann jede Aggregrationsfunktion verwendet werden.\nDie Standardausgabe generiert Zeilen- und Spaltensummen. Diese Summen sind für eine Breitform unhantlich und lassen sich durch die optionalen 6. und 8. Parameter unterdrücken, wenn diese Parameter auf den Wert 0 gesetzt werden. Die Zeilensummen werden durch den 6. Parameter und die Spaltensummen werden durch den 8. Parameter beeinflusst.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Daten formen</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-formen/kapitel.html#die-pivotmit-funktion",
    "href": "kapitel/daten-formen/kapitel.html#die-pivotmit-funktion",
    "title": "14  Daten formen",
    "section": "",
    "text": "row_fields (Zeilenwerte)\ncol_fields (Spaltenwerte)\nvalues (Aggregationswerte)\nfunction (Aggregationsfunktion)\n\n\n\n\n\nErgebnis der PIVOTMIT()-Funktion mit MITTELWERT() als Aggregator\n\n\n\n\n\n\nErgebnis der PIVOTMIT()-Funktion ohne Zeilen- und Spaltensummen\n\n\n\n14.1.1 PIVOTMIT() und fehlende Werte\nTritt ein Zeilen-und-Spaltenwertepaar nicht auf, kann PIVOTMIT() keine Werte aggregieren. Anders als andere Excel-Funktionen werden solche fehlenden Werte nicht durch den Wert 0 ersetzt, sondern durch eine leere Zeichenkette. Dieses Verhalten lässt sich nicht anpassen, sondern muss durch eine zusätzliche Operation korrigiert werden.\n= LET(breitform; PIVOTMIT(\n                    data_ab[Interesse]; \n                    data_ab[Bedeutung]; \n                    data_ab[Punkte]; \n                    MITTELWERT;; \n                    0;; \n                    0);\n      WENN(breitform = \"\"; 0; breitform)\n)\n\n\n\n\n\n\nAchtung\n\n\n\nDer Wert 0 darf nicht eingesetzt werden, wenn eine Breitform erzeugt werden soll, weil sonst Werte erzeugt werden, die ursprünglich nicht vorhanden waren.\n\n\n\n\n14.1.2 Eine Breitform mit PIVOTMIT() erzeugen.\nWird als Aggregatorfunktion die Funktion SUMME() verwendet und jedes Wertepaar, dass sich aus den ersten beiden Parametern ergibt, dann ist diese Aggregation mit der Identifitätsfunktion funktional gleich.\n= PIVOTMIT(Zeilenindex; Spaltenindex; Werte; SUMME;; 0;; 0)\n\n\n\n\n\n\nAchtung\n\n\n\nDie Funktion PIVOTMIT() erfordert eine Aggregationsfunktion. Diese Funktion stellt sicher, dass mehrfach vorkommende Wertepaare zu einem eindeutigen Ergebnis führen. Dieses Verhalten führt dazu, dass die PIVOTMIT()-Funktion nicht immer umkehrbar ist, sobald die vorkommenden Wertepaare nicht eindeutig sind.\n\n\n\n\n\n\n\n\nMerke\n\n\n\nEine Langform kann nur in eine Breitform umgeformt werden, wenn alle Wertepaare der Indexvektoren eindeutig sind. Eine solche Langform liegt dann in ihrer Normalform für die beiden Indexvektoren vor.\n\n\n\n\n14.1.3 Vektoren auf ihre Normalform prüfen\nZwei Indexvektoren liegen genau dann in ihrer Normalform vor, wenn alle Wertepaare (bzw. Tupel) eindeutig sind, d.h. genau einmal vorkommen. Damit eine Breitform der Daten für diese Indexvektoren erzeugt werden kann, muss gelegentlich geprüft werden, ob diese auch tatsächlich in ihrer Normalform vorliegen.\nGegeben seien die folgenden Daten im Bereich A1:C6:\n\n\n\nIndex 1\nIndex 2\nWerte\n\n\n\n\na\ne\n 1\n\n\nb\nf\n 2\n\n\nc\ng\n 3\n\n\nd\ne\n 4\n\n\na\ne\n 5\n\n\n\nDie Indexvektoren liegen in Index 1 und Index 2, also in A2:A6 bzw. B2:B6.\nDazu werden alle eindeutigen Wertepaare mit EINDEUTIG() erzeugt. In diesem Beispiel wird diese Operation in Zelle D2 durchgeführt.\n= EINDEUTIG(A2:B6)\nDer Bereich D2# enthält jetzt alle eindeutigen Wertepaare der Indexvektoren.\nDie Normalform ist also dann gegeben, wenn jedes eindeutige Wertepaar höchstens einmal auftritt. Das liesse sich mit der folgenden Formel überprüfen, die als Ergebnis WAHR hat, wenn die Indexvektoren in ihrer Normalform vorliegen.\n= 1 = MAX(NACHZEILE(\n    D2#;\n    LAMBDA(zeile; \n        ZEILEN(\n            FILTER(\n                A2:A6;\n                (SPALTENWAHL(zeile;1)=A2:A6) * \n                (SPALTENWAHL(zeile;2)=B2:B6)\n            )\n        )\n    )\n))\nDiese Prüfung ist recht komplex und lässt sich stark vereinfachen, wenn die Voraussetzungen für die Normalform berücksichtigt werden. Dazu wird die Eigenschaft der Normalform ausgenutzt: Weil eine Normalform erfordert, dass die Wertepaare der Indexvektoren höchstens einmal vorkommen dürfen, muss das Ergebnis der Funktion EINDEUTIG() die gleiche Länge haben, wie die ursprünglichen Vektoren. Weil beide Indexvektoren aus der Definition des Datenrahmens die gleiche Länge haben müssen, lässt sich die Normalform mit der folgenden Operation prüfen.\n= ZEILEN(A2:A6) = ZEILEN(D2#)\nDiese Prüfung lässt sich in eine Operation zusammenfassen.\n= ZEILEN(A2:A6) = ZEILEN(EINDEUTIG(A2:B6))\nErgibt diese Operation WAHR, dann kann die Breitform ohne Informationsverlust erzeugt werden.\n\n\n14.1.4 Breitform ohne Überschriften erhalten\nWeil die Funktion PIVOTMIT() auch Zeilen- und Spaltenüberschriften erzeugt, lassen sich die einzelnen Vektoren nicht direkt mit SPALTENWAHL() extrahieren. Leider lassen sich die Spaltenüberschriften nicht unterbinden.\nDamit die Überschriften nicht in den Daten vorliegen, müssen diese nach der Transformation entfernt werden:\n= LET(breitform; PIVOTMIT(\n                    Zeilenindex; \n                    Spaltenindex; \n                    Werte; \n                    SUMME;; \n                    0;; \n                    0);\n      zeilenwerte; ZEILEN(breitform) - 1;\n      spaltenwerte; SPALTEN(breitform);\n      wertezeilen; SEQUENZ(zeilenwerte; 1; 2);\n      wertespalten; SEQUENZ(1;spaltenwerte; 1);\n      INDEX(breitform; wertezeilen; wertespalten)\n)\nUm auch die Werte des Zeilenindex zu entfernen, muss die Spaltenanzahl ebenfalls verringert werden.\n= LET(breitform; PIVOTMIT(\n                    Zeilenindex; \n                    Spaltenindex; \n                    Werte; \n                    SUMME;; \n                    0;; \n                    0);\n      zeilenwerte; ZEILEN(breitform) - 1;\n      spaltenwerte; SPALTEN(breitform) - 1;\n      wertezeilen; SEQUENZ(zeilenwerte; 1; 2);\n      wertespalten; SEQUENZ(1; spaltenwerte; 2);\n      INDEX(breitform; wertezeilen; wertespalten)\n)\n\n\n\n\n\n\nAchtung\n\n\n\nIntuitiv bietet sich die Funktion BEREICH.VERSCHIEBEN() ebenfalls an. Diese Funktion erfordert jedoch eine Zellbezug, so dass diese Funktion nicht in Operationen mit LET() und LAMBDA() eingesetzt werden kann.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Daten formen</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-formen/kapitel.html#die-index-funktion",
    "href": "kapitel/daten-formen/kapitel.html#die-index-funktion",
    "title": "14  Daten formen",
    "section": "14.2 Die INDEX()-Funktion",
    "text": "14.2 Die INDEX()-Funktion\nDie Funktion PIVOTMIT() hat keine unmittelbare Umkehrfunktion. Mithilfe der INDEX()-Funktion lässt sich eine Umkehrfunktion konstruieren. Diese Funktion wurde bereits im letzten Abschnitt zum entfernen der Werte der Indexvektoren eingesetzt.\nDie INDEX()-Funktion ist eine sog. Referenzfunktion, mit der auf Werte mittels ihrer Position in einem Vektor oder einer Matrix zugegriffen werden kann. Die INDEX()-Funktion erwartet drei Parameter:\n\nDie zu referenzierende Matrix\neinen gültigen Zeilenindex, und\neinen gültigen Spaltenindex.\n\nDer Zeilen- und Spaltenindex sind Ganzzahlen, die sich auf die Position der Werte beziehen. Auf diese Weise lassen sich Werte aus einem Vektor oder einer Matrix extrahieren.\n\n14.2.1 INDEX() mit Vektoren als Indexparameter\nDie INDEX()-Funktion erlaubt Vektoren für den Zeilen- und Spaltenindex. Auf diese Weise lassen sich mehrere Werte auf einmal referenzieren. Liegen die Vektoren in gleicher Orientierung vor, dann bildet die Funktion Indexpaare. Die Operation = INDEX(A1:C5; {1; 2; 4}, {1; 2; 2}) wählt beispielsweise nur die Werte an A1, B2 und B4 aus.\nLiegen die Indizes in verschiedenen Orientierungen vor, dann bildet die INDEX()-Funktion eine Indexmatrix mit allen Permutationen der angegebenen Indizes. Die Werte werden dann als Matrix angeordnet. Z.B. die Operation =INDEX(A1:D4; {1;2;4}; ZUZEILE({1;2;2})) wählt die Werte an A1, A2, A4, B1, B2, B4 sowie nocheinmal B1, B2 und B4 aus. Diese Dopplung entsteht durch die doppelte Angabe des Werts 2 im Spaltenindex. Auf den ersten Blick erscheint dieses Verhalten unpraktisch, im folgenden Abschnitt wird genau diese Eigenschaft ausgenutzt.\nDie Funktion INDEX() behält die Orientierung der Parametervektoren bei. Diese Eigenschaft lässt sich ausnutzen, um eine Verkettung mit MTRANS() zu vermeiden. Die Operation =MTRANS(INDEX(A1:D4; {1;2;4}; ZUZEILE({1;2;2}))) ist mit der Operation =INDEX(A1:D4; ZUZEILE({1;2;4}); {1;2;2}) funktional gleich.\n\n\n14.2.2 Die Umkehrung von PIVOTMIT() konstruieren\nBeim Umformen von der Breitform in die Langform müssen nicht nur die Werte als Vektor dargestellt werden, sondern auch die beiden Indexvektoren wiederhergestellt werden. Entsprechend reicht der naive Aufruf von ZUSPALTE() nicht.\n\n\n14.2.3 SPALTENWAHL() und ZEILENWAHL()\nDie beiden Funktionen SPALTENWAHL() und ZEILENWAHL(), sind Vereinfachungen der INDEX()-Funktion.\nDie Funktion SPALTENWAHL() wählt ganze Spalten aus. Beispielsweise wählt der Aufruf von SPALTENWAHL(A1:D17; 2) die zweite Spalte des Bereichs A1:D17 aus. Man erhält dann die Werte im Bereich B1:B17. Diese Funktion entspricht der folgenden Operation mit INDEX().\n= INDEX(\n    A1:D17;\n    SEQUENZ(ZEILEN(A1:D17));\n    2\n)\nAnalog verhält sich die Funktion ZEILENWAHL(). Sie wählt die angegebene Zeile aus einem Bereich aus. Für den Bereich A1:D17 wählt der Aufruf ZEILENWAHL(A1:D17; 7) die Werte im Bereich A7:D7 aus. Dieser Aufruf entspricht der folgenden Opeation mit INDEX().\n= INDEX(\n    A1:D17;\n    7;\n    SEQUENZ(1; SPALTEN(A1:D17))\n)\nÄhnlich wie die INDEX()-Funktion unterstützen beide Funktionen die Auswahl mehrerer Spalten bzw. Zeilen. Dazu muss entsprechend ein Vektor mit den gewünschten Zeilen- bzw. Spaltennummern übergeben werden.\n\n\n\n\n\n\nPraxis\n\n\n\nDie Funktionen SPALTENWAHL() und ZEILENWAHL() sind der Funktion INDEX() vorzuziehen, wenn nur Spalten oder Zeilen in einer Operation extrahiert werden müssen. Operationen, die SPALTENWAHL() und ZEILENWAHL() verketten, sollten jedoch vermieden werden. In solchen Fällen ist die Funktion INDEX() meist besser geeignet, weil dann die Funktionsverkettung entfällt.",
    "crumbs": [
      "Mathematik der Daten",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Daten formen</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html",
    "href": "kapitel/daten-beschreiben/kapitel.html",
    "title": "15  Daten beschreiben",
    "section": "",
    "text": "15.1 Universelle Kennwerte\nDie universellen Kennwerte von Datenrahmen werden mit Excel auf die Gleicheweise bestimmt, wie die Dimensionen einer Matrix (s. Kapitel 12):\nEs werden die Zeilen und Spalten der Daten bestimmt. Beim Stichprobenumfang müssen ggf. ungültige Datensätzte gefiltert werden. Hierzu hilft meist ein Sekundärindex, mit dem die gültigen Datensätze markiert werden.",
    "crumbs": [
      "Deskriptive Datenanalyse",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Daten beschreiben</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html#variablenumfänge",
    "href": "kapitel/daten-beschreiben/kapitel.html#variablenumfänge",
    "title": "15  Daten beschreiben",
    "section": "15.2 Variablenumfänge",
    "text": "15.2 Variablenumfänge\nDie Variablenumfänge ist durch die Anzahl der gültigen Werte gegeben. Die Funktion ANZAHL() ignoriert sowohl die leeren Zellen als auch Fehlerwerte, Wahrheitswerte und Zeichenketten. Sie eignet sich damit zur Bestimmung des Variablenumfangs für Zahlenvektoren.\nFür alle anderen Vektoren bietet sich die Funktion ANZAHL2() an. Diese Funktion ignoriert jedoch keine Fehlerwerte. Deshalb müssen für Zeichenkettenvektoren fehlenden Werte, die mit #NV markiert wurden, gefiltert werden, bevor der Vektorumfang bestimmt wird.",
    "crumbs": [
      "Deskriptive Datenanalyse",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Daten beschreiben</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html#ungültige-werte-entfernen",
    "href": "kapitel/daten-beschreiben/kapitel.html#ungültige-werte-entfernen",
    "title": "15  Daten beschreiben",
    "section": "15.3 Ungültige Werte entfernen",
    "text": "15.3 Ungültige Werte entfernen\nWird diese Operation über mehrere Adressen verteilt, wandelt Excel die leeren Zellen in den Wert 0 um. Deshalb müssen zuerst alle leeren Zellen und anschliessend alle Fehlerwerte gefiltert werden.\n\nBeispiel 15.1 (Entfernen ungültiger Werte)  \n= FILTER(\n    Tabelle[Vektor]; \n    NICHT(ISTLEER(Tabelle[Vektor]) + ISTFEHLER(Tabelle[Vektor]))\n)\n\nErst über diese bereinigten Daten darf der Vektorumfang bestimmt werden. Weil durch das Entfernen der ungültigen Werte die Vektorlänge identisch mit dem Vektorumfang ist, kann der Vektorumfang auch mittels der Funktion ZEILEN() bzw. SPALTEN() bestimmt werden.\nIst der Datentyp eines Vektors festgelegt, dann lässt sich das Filtern ungültiger Werte stark vereinfachen. Dazu wird die Typenerkennung mit der entsprechenden IST-Funktion als Filter eingesetzt.\n\nBeispiel 15.2 (Entfernen ungültiger Werte durch erzwingen des Datentyps Zeichenkette)  \n= FILTER(\n    Tabelle[Vektor]; \n    ISTTEXT(Tabelle[Vektor])\n)\n\nDiese Strategie hat den Vorteil, dass auch alle Werte mit falschen Datentyp als ungültig erkannt und entfernt werden.\n\n\n\n\n\n\nMerke\n\n\n\nUngültige Werte müssen auch für alle Lagemasse entfernt werden.",
    "crumbs": [
      "Deskriptive Datenanalyse",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Daten beschreiben</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html#lagemasse",
    "href": "kapitel/daten-beschreiben/kapitel.html#lagemasse",
    "title": "15  Daten beschreiben",
    "section": "15.4 Lagemasse",
    "text": "15.4 Lagemasse\n\n15.4.1 Median\nDer Median wird mit der Funktion MEDIAN() bestimmt. Dabei muss beachtet werden, dass diese Funktion ausschliesslich mit Rohdaten verwendet werden muss. Werden aggregierte Werte dieser Funktion übergeben, liefert diese Funktion den Median der aggregierten Werte und nicht den gesuchten Wert.\nOrdinalskalierte Daten können auch als Zeichenketten vorliegen. Diese Werte müssen zuerst in Zahlen kodiert werden, um den Median bestimmen zukönnen.\n\nBeispiel 15.3 (Bestimmen des Medians)  \n=MEDIAN(\n    FILTER(\n        Tabelle[Vektor]; \n        ISTZAHL(Tabelle[Vektor])\n    )\n)\n\n\n\n15.4.2 Mittelwert\nDer Mittelwert wird mit der Funktion MITTELWERT() bestimmt. Dieser Kennwert darf nur für metrisch-skalierte Daten bestimmt werden. Diese Daten liegen immer als Zahlen vor, weshalb diese Werte nicht kodiert werden müssen.\n\nBeispiel 15.4 (Bestimmen des Medians)  \n=MEDIAN(\n    FILTER(\n        Tabelle[Vektor]; \n        ISTZAHL(Tabelle[Vektor])\n    )\n)",
    "crumbs": [
      "Deskriptive Datenanalyse",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Daten beschreiben</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html#streumasse",
    "href": "kapitel/daten-beschreiben/kapitel.html#streumasse",
    "title": "15  Daten beschreiben",
    "section": "15.5 Streumasse",
    "text": "15.5 Streumasse\n\n15.5.1 Bandbreite\nDie Bandbreite ergibt sich aus der Differenz zwischen dem kleinsten und dem grössten gemessenen Wert. Die Bandbreite wird nur als eigenständiger Wert angegeben, um ähnliche Bandbreiten in unterschiedlichen Wertebereichen anzuzeigen. Sonst wird nur das Minimum mit MIN() und das Maximum mit MAX() für den Vektor bestimmt.\n\n\n15.5.2 Quartiele\nDie Quartile werden mit der Funktion QUARTILE.INKL() bestimmt. Dazu wird der bereinigte Vektor als erster Parameter übergeben und anschliessend der das jeweilige Quartil. Das untere Quartil wird mit dem Wert 1 als zweiten Parameter berechnet und das obere Quartil mit dem Wert 3.\nWie beim Median können die Werte für die Quartile mit Zahlenwerten berechnet werden.\nDie Funktion QUARTILE.INKL() erlaubt es, die Minimalwert, den Maximalwert und den Median mit einem Aufrug zu bestimmen. Dazu wird als zweiter Parameter eine Sequenz von 0-4 übergeben.\n\nDer Wert 0 steht für das Minimum,\nDer Wert 1 für das untere Quartil,\nDer Wert 2 für den Median,\nDer Wert 3 für das obere Quartil und\nDer Wert 4 steht für das Maximum.\n\n\nBeispiel 15.5 (Bandbreite, Median und Quartile mit QUARTILE.INKL() bestimmen.)  \n=QUARTILE.INKL(\n    FILTER(\n        Tabelle[Vektor]; \n        ISTZAHL(Tabelle[Vektor])\n    );\n    SEQUENZ(1; 5; 0)\n)\n\n\n\n15.5.3 Varianz und Standardabweichung\nDie Varianz der gemessenen Werte eines Vektors werden mit der Funktion VAR.S() bestimmt. Die Standardabweichung der gemessenen Werte wird mit der Funktion STABW.S() bestimmt. Excel kennt für die echte Varianz und die echte Standardabweichung die Funktionen VAR.P() udn STABW.P(), diese werden für die Beschreibung gemessener Daten nicht verwendet.\n\n\n15.5.4 Interquartilsabstand\nExcel kennt keine Funktion für den Interquartilsabstand. Dieser muss aus den beiden Quartilen mit der Formel aus Beispiel 15.6 berechnet werden.\n\nBeispiel 15.6  \n= Quartil3 - Quartil1\n\n\n\n15.5.5 Mittlere Absolute Abweichung (MAD)\nDie mittlere absolute Abweichung muss in EXCEL ebenfalls händisch berechnet werden.\n\nBeispiel 15.7  \n=LET(\n    Werte; FILTER(\n        Tabelle[Vektor]; \n        ISTZAHL(Tabelle[Vektor])\n    ); \n    MEDIAN(\n        ABS(\n            Werte - MEDIAN(Werte)\n        ) \n    )\n)",
    "crumbs": [
      "Deskriptive Datenanalyse",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Daten beschreiben</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html",
    "href": "kapitel/daten-visualisieren/kapitel.html",
    "title": "16  Daten visualisieren",
    "section": "",
    "text": "16.1 Diagramme erstellen",
    "crumbs": [
      "Deskriptive Datenanalyse",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Daten visualisieren</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html#diagramme-erstellen",
    "href": "kapitel/daten-visualisieren/kapitel.html#diagramme-erstellen",
    "title": "16  Daten visualisieren",
    "section": "",
    "text": "Warnung\n\n\n\nExcels Diagrammtypen erfordern, dass die Daten in einem bestimmten Format vorliegen. Das notwendige Format hängt vom Diagrammtyp ab. Es lassen sich deshalb nicht alle Visualisuerungen aus den gleichen Datenstrukturen erzeugen.\n\n\n\n16.1.1 Datenvorbereitung\nDie verschiedenen Diagrammtypen erfordern unterschiedliche Datenformate. Deshalb müssen die Daten für die Visualisierung vorbereitet und in eine geeignete Form gebarcht werden.\nAlle Werte, die visualisiert werden sollen, müssen einen Bereich bilden. Dieser Bereich kann innerhalb einer Tabelle liegen oder dynamische Felder umfassen.\nExcel organisiert die Werte für die Darstellung in Datenreihen. Je nach Visualisierung besteht eine Datenreihe aus einer Überschrift und einer, zwei oder drei Spalten mit Werten.\n\n\n\n\n\n\nPraxis\n\n\n\nEs vereinfacht die Arbeit, wenn die Spalten einer Datenreihe möglichst nebeneinander geschrieben werden. Alternativ können die gleichen Teilspalten organisiert werden. Letzteres bietet sich immer dann an, wenn die Werte in die Breitform transponiert werden müssen.\n\n\nErlaubt ein Diagramm horizontale oder vertikale Achsbeschriftungen, dann werden diese normalerweise in den Spalten vor den eigentlichen Werte für den Darstellungsbereicht positioniert.\n\n\n16.1.2 Diagrammerstellung\nUm ein Diagramm zu erstellen müssen die vorbereiteten Daten markiert werden. Excel Diagramme können nicht mit dynamischen Feldern umgehen, so dass alle darzustellenden Werte markiert werden müssen.\nAusser den Spaltenüberschriften sollten keine weiteren Daten markiert werden. Dazu gehören auch die Werte, die für die Beschriftung der X-Achse benötigt werden. Abbildung 16.1 zeigt eine solche Markierung.\n\n\n\n\n\n\nAbbildung 16.1: Markierung der zu visualisierenden Werte\n\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nOft liegen Daten als Tabellen oder Dynamische Felder vor. Verändert sich die Anzahl der Werte einer solchen Datenstruktur, betrifft diese Änderung nicht den markierten Wertebereich. Liegen neue Werte ausserhalb des markierten Bereichs für ein Diagramm, dann werden diese Werte nicht dargestellt. In solchen Fällen muss der Bereich für die Darstellung nachträglich erweitert werden.\n\n\nNachdem wie zu visualisierenden Werte markiert wurden, kann das eigentliche Diagramm eingefügt werden. Dazu muss aus dem Menübalken Einfügen im Abschnitt Diagramme (Abbildung 16.2) die gewünschte Darstellung ausgewählt werden.\n\n\n\n\n\n\nAbbildung 16.2: Menübalken Einfügen/Diagramme\n\n\n\nDie Auswahl erzeugt das gewünschte Diagramm für die markierten Daten auf dem aktuellen Arbeitsblatt.\n\n\n16.1.3 Diagrammbearbeitung\nSobald ein Diagramm erstellt wurde, kann es über das Menüband Diagrammentwurf angepasst werden. Dieses Menüband wird nur angezeigt, wenn ein Diagramm ausgewählt wurde.\n\n\n\n\n\n\nAbbildung 16.3: Menüband Diagrammentwurf\n\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nFür die Datenvisualisierung sind das Untermenü Diagrammelement hinzufügen und das Kommando Daten auswählen zentral, weil über sie die Darstellung gesteuert wird.\nDaneben wird das Farbschema über das Menü Farben ändern gesteuert.\n\n\nDas Untermenu Diagrammelement hinzufügen erlaubt es, einzelne Diagrammelement zur Visualisierung hinzuzufügen oder zu entfernen. Die möglichen Diagrammelemente hängen vom jeweiligen Diagrammtyp ab.\nDas Untermenu Schnelllayout bietet Vorlagen für die einzelnen Diagrammelemente. Diese Vorlagen dienen oft als Basis für die weitere Verfeinerung mit dem Untermenü Diagrammelement hinzufügen.\nMit dem Untermenü Farbenändern können die im Diagramm verwendeten Farben angepasst werden. In diesem Menü finden sich verschiedene Farbpaletten. Diese Farbpaletten werden durch das aktuelle Farbschema der Arbeitsmappe bestimmt.\nIm Bereich Diagrammformatvorlagen kann die allgemeine Darstellung angepasst werden. Diese Einstellungen sollten nur angepasst werden, um ein Diagramm für eine besondere Präsentation vorzubereiten. Normalerweise werden über diesen Bereich keine Änderungen vorgenommen.\nDas Kommando Zeile/Spalte tauschen ist bei guter Vorbereitung der Daten nicht notwendig. Dieses Kommando ändert für eine Visualisierung die Verwendung von Spalten in die Verwendung von Zeilen. Dieses Kommando ist entsprechend nur Notwendig, wenn die Daten zeilenweise anstatt spaltenweise vorbereitet wurden.\n\n\n\n\n\n\nWarnung\n\n\n\nManche Visualisierungen verwenden ein komplexes internes Datenmodell, so dass die mehrfache Anwendung des Kommandos Zeile/Spalte tauschen nicht zwingend zur ursprünglichen Darstellung führt.\n\n\nMit Daten auswählen werden die Datenreihen und Quellen für Achsbeschriftungen in der Arbeitsmappe festgelegt. Dieses Kommando öffnet den Dialog Datenquelle auswählen, mit dem die Daten den einzelnen Darstellungselementen zugewiesen werden. Mit diesem Kommando können die Datenreihen korrigiert werden, wenn die automatische Erkennung von Excel nicht das gewünschte Ergebnis erzielt hat.\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nDas Kommando Daten auswählen heisst unter MacOS Daten markieren.\n\n\nDas Untermenü Diagrammtyp ändern erlaubt es, den Typ eines Diagramms zu verändern, ohne den Diagrammbereich zu verändern. Weil die verschiedenen Diagrammtyp recht unterschiedliche Anforderungen an die Datenorganisation haben, sollte hier nur Diagrammtypen innerhalb der gleichen Gruppe ausgewählt werden. Beispielsweise könnte so ein Balkendiagramm in ein Säulendiagramm geändert werden.\nDas Kommand Diagramm verschieben erlaubt es, ein Diagramm auf einem eigenen Arbeitsblatt zu platzieren. Dieses Kommando ist nur dann sinnvoll, wenn eine Arbeitsmappe zur Präsentation der Daten verwendet wird.\n\n\n16.1.4 Dialog Datenquelle auswählen\nÜber das Kommando Daten markieren wird der Dialog Datenquelle auswählen (Abbildung 16.4) geöffnet, über den die Daten den Darstellungselementen zugewiesen werden.\n\n\n\n\n\n\nAbbildung 16.4: Dialog Datenquelle auswählen (Windows)\n\n\n\nDurch einen Doppelklick auf eine Datenreihe öffnet sich ein zweiter Dialog, um eine Datenreihe zu konfigurieren (Abbildung 16.5). Über diesen Dialog sollten die Datenreihen konfiguriert werden, damit sicher gestellt wird, dass die Datenreihen auf die richtigen Werte verweisen.\n\n\n\n\n\n\nAbbildung 16.5: Datenreihe konfigurieren (Windows)\n\n\n\n\n\n\n\n\n\nMacOs vs. Windows\n\n\n\nUnter MacOS ist die gleiche Funktion etwas anders angeordnet.\n\n\n\n\n\n\nAbbildung 16.6: Dialog Datenquelle auswählen (MacOS)\n\n\n\nDer Dialog besteht aus drei Teilen:\n\nDer Teil Bereichdetails zeigt den Datenbereich des Diagramms an. Der angezeigte Bereich sollte nicht in diesem Teil verändert werden.\nDer Teil Legendeneinträge (Reihen) weist Spalten mit Werten den Datenreihen des Diagramms zu. In diesem Teil werden die verwendeten Datenbereiche angepasst, die im Teil Bereichdetails zusammengefasst angezeigt werden.\nIm Teil Ausgeblendete und leere Zellen wird die Behandlung von leeren Zellen und #NA-Werten festgelegt. In diesem Teil sind nur selten Anpassungen notwendig.\n\n\n\n\n\n16.1.5 Diagramme formatieren\nDie Darstellungselemente von Diagrammen können über den Formatierungsbereich angepasst werden. Über den Formatierungsbereich lassen sich die alle Details eines Diagramms anpassen.\n\n\n\n\n\n\nMacOs vs. Windows\n\n\n\nZur Formatierung der Datenreihen wird der Formatierungsbereich benötigt. Dieser wird unter Windows über das Kommando Auswahl formatieren geöffnet. Die wichtigsten Formatierungen sind die Datenreihenformatierungen. Je nach Diagrammtyp lassen sich in dieser Rubrik Formatierungen in Abhängigkeit zu den abgebildeten Daten justieren.\n\n\n\n\n\n\nAbbildung 16.7: Formatierungsbereich öffnen (Windows)\n\n\n\nUnter MacOS wird der Formatierungsbereich über das Kommando Formatierungsbereich im Menüband Format geöffnet.\n\n\n\n\n\n\nAbbildung 16.8: Formatierungsbereich öffnen (MacOS)\n\n\n\nNach dem Öffnen des Formatierungsbereichs können die einzelnen Darstellungselemente gezielt formatiert werden. Immer wenn ein Darstellungselement sich auf Datenreihen bezieht, lassen sich zuätzliche Formatierungen unter der Rubrik Reihenoptionen konfigurieren. Diese Optionen werden unter MacOs und Windows leicht unterschiedlich dargestellt (Abbildung 16.9)\n\n\n\n\n\n\n\n\n\n\n\n(a) Windows\n\n\n\n\n\n\n\n\n\n\n\n(b) MacOS\n\n\n\n\n\n\n\nAbbildung 16.9: Datenreihen formatieren\n\n\n\n\n\n\n\n16.1.6 Diagramme exportieren\nUm ein Diagramm zum Einbetten in andere Programme bereitzustellen, muss das Diagramm aus Excel exportiert werden. Dazu ein Rechtsklick auf das Diagramm öffnet ein Kontextmenü, in welchem sich der Punkt Als Grafik speichern ... findet (Abbildung 16.10).\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nDas Kommando zum Speichern von Diagrammen heisst unter MacOS Als Bild speichern ... und unter Windows Als Grafik speichern ....\n\n\n\n\n\n\n\n\nAbbildung 16.10: Kontextmenu zum Exportieren eines Diagramms\n\n\n\nAnschliessend erscheint ein Dialog zum Speichern der Diagrammdatei (Abbildung 16.11). Standardmässig bietet dieser Dialog als Dateityp das Grafikformat PNG an, was in den meisten Fällen gewählt werden sollte. Alternativ können Diagramme in den Formaten JPEG, GIF, PDF, BMP und SVG exportiert werden. Hier sind für die Praxis nur die beiden Formate PDF und SVG von Bedeutung.\n\n\n\n\n\n\nPraxis\n\n\n\nDas PDF-Format sollte gewählt werden, wenn eine Grafik einzeln ausgedruckt werden soll.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nDas SVG-Format sollte gewählt werden, wenn das Diagramme grossformtig oder in hoher Qualität auf Web-Seiten veröffentlicht werden soll.\n\n\n\n\n\n\n\n\nAbbildung 16.11: Auswahl zum Speichern eines Diagramms",
    "crumbs": [
      "Deskriptive Datenanalyse",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Daten visualisieren</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html#diagrammtypen",
    "href": "kapitel/daten-visualisieren/kapitel.html#diagrammtypen",
    "title": "16  Daten visualisieren",
    "section": "16.2 Diagrammtypen",
    "text": "16.2 Diagrammtypen\nAlle Excel Diagramme visualisieren Werte vom Datentyp Zahl. Um andere Datentypen zu visualisieren, müssen diese zuerst in Zahlen kodiert werden.\n\n16.2.1 Balkendiagramme\nExcel unterscheidet zwischen Balken- oder Säulendiagrammen. Technisch unterscheiden sich die beiden Diagrammtype nur durch die Orientierung der Balken. Im Folgenden werden beide Diagrammtypen als Balkendiagramme bezeichnet.\n\n\n\n\n\n\nMerke\n\n\n\nFür ein Balkendiagramm entspricht jeder Wert einem Balken und der Wert bestimmt dessen Grösse.\n\n\nDie Anzahl der Werte entspricht der Anzahl der Balken. Daraus folgt, dass ein Balkendiagramm immmer diskrete Daten auf der X- und Zahlenwerte auf der Y-Achse abbildet.\nBalkendiagramme können keine Werte zusammenfassen. Deshalb müssen Daten vor der Visualisierung als Balkendiagramm aggregiert werden. Normalerweise erfolgt ein gruppiertes Zählen mit ZÄHLENWENNS().\nDie Werte können als Zeile oder als Spalte angegeben werden. Wird ein zweiter Vektor mit Textwerten angegeben, dann übernimmt Excel diese Werte als Beschriftung der X-Achse.\n\n\n\n\n\n\n\n\n\n\n\n(a) Daten\n\n\n\n\n\n\n\n\n\n\n\n(b) Diagramm\n\n\n\n\n\n\n\nAbbildung 16.12: Vorbereitete Datentabelle mit Balkendiagramm\n\n\n\n\n\n\n\n\n\nMerke\n\n\n\nFür Balkendiagramme mit zwei oder mehr Gruppen, müssen die Daten in der Breitform vorliegen.\n\n\nGruppierte Daten werden farblich voneinander abgehoben. Die Farben können über das Farbschema der Arbeitsmappe über das Kommando Farben ändern angepasst werden.\n\n\n\n\n\n\n\n\n\n\n\n(a) Daten\n\n\n\n\n\n\n\n\n\n\n\n(b) Diagramm\n\n\n\n\n\n\n\nAbbildung 16.13: Gruppierte Datentabelle mit Balkendiagramm\n\n\n\nSollen einzelne Kategorien farblich hervorgehoben werden, dann müssen die Werte gruppiert organisiert werden, wobei jeder Wert in einer eigenen Gruppe geführt wird (Abbildung 16.14).\n\n\n\n\n\n\n\n\n\n\n\n(a) Daten\n\n\n\n\n\n\n\n\n\n\n\n(b) Diagramm\n\n\n\n\n\n\n\nAbbildung 16.14: Datentabelle und Balkendiagramm mit farblich abgehobenen Kategorien.\n\n\n\n\n16.2.1.1 Darstellung optimieren\nBei der Darstellung von Balkendiagrammen verwendet Excel immer Standardeinstellungen. Diese nutzen die Fläche des Diagramms nicht unbedingt optimal: Auf der Y-Achse wird immer eine Hauptbeschriftung oberhalb des grössten Wers eingefügt und die Abstände zwischen den Balken sind grösser als die Balken (Abbildung 16.15).\n\n\n\n\n\n\nAbbildung 16.15: Balkendiagramm mit Standardeinstellungen\n\n\n\nDie Y-Achse kann immer auf den Maximalwert begrenzt werden. Dazu wird die Achsbeschriftung mit der Maus ausgewählt. Anschliessend können in den Achsenoptionen die Grenzen der Y-Achse festgelegt werden. Hier sollte das Maximum auf den grössten dargestellten Wert gesetzt werden (s. Abbildung 16.16).\n\n\n\n\n\n\nAbbildung 16.16: Konfiguration der Achseneinstelleungen\n\n\n\n\n\n\n\n\n\nMerke\n\n\n\nFür Balkendiagramme sollte das Minimum der Y-Achse immer 0.0 sein.\n\n\nDie Abstände zwischen den Balken werden über die Formatierung der Balken gesteuert. Dazu muss ein Balken mit der Maus ausgewählt werden. Die einzige Einstellungskategorie für die Datenformatierung sind die Reihenoptionen, wo sich die beiden Einstellungen Reihenüberlappungen und Abstandsbreite finden (s. Abbildung 16.17).\n\n\n\n\n\n\nAbbildung 16.17: Balkenbreite und -abstände konfigurieren\n\n\n\nAbbildung 16.18 zeigt die Bedeutung der beiden Optionen.\n\n\n\n\n\n\nAbbildung 16.18: Unterschied zwischen Reihenüberlappung und Abstandsbreite\n\n\n\nDie Option Reihenüberlappung legt die Abstände ziwschen Balken in der gleichen Kategorie fest. Die Abstände werden in Prozent der Überlappung angegeben. 0% bedeutet keine Überlappung ohne Abstand. 100% bedeutet vollständige überlappung und -100% bedeutet einen Abstand einer Balkenbreite.\nDie Option Abstandsbreite legt die Abstände zwischen den Kategorien fest. Die Abstände werden in Prozent der Balkenbreite angegeben.\n\n\n\n\n\n\nAchtung\n\n\n\nDie Überlappung und die Balkenbreite wird auch dann berücksichtigt, wenn ein Balken nicht dargestellt wird!\n\n\nUm farblich voneinander unterschiedene Kategorien mit gleicher Balkenbreite wie in Abbildung 16.14 zu erzeugen, muss die Reihenüberlappung auf 100% gesetzt werden. Anschliessend können die Abstände mit der Option Abstandsbreite kontrolliert werden. Abbildung 16.14 verwendet eine Abstandsbreite von 10%.\n\n\n\n16.2.2 Spezielle Balkendiagramme\nExcel bietet zwei spezielle Formen von Balkendiagrammen: Trichterdiagramme und Wasserfall-Diagramme. Beide Diagramme sind eindimensional.\nTrichterdiagramme stellen die Balken horizontal zentriert dar, wobei nur positive Werte zulässig sind. Deshalb haben Excels Trichterdiagramme keine Beschriftung der X-Achse (Abbildung 16.19).\n\n\n\n\n\n\nMerke\n\n\n\nTrichterdiagramme unterscheiden sich von anderen Balkendiagrammen nur in der Anordnung der Balken.\n\n\n\n\n\n\n\n\nAbbildung 16.19: Trichterdiagramm mit fünf Werten\n\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nWeil Trichterdiagrammen keine beschriftete X-Achse haben und die Anordnung der Balken schwerer zu dekodieren ist, sollten diese Diagramme nicht verwendet werden.\n\n\nWasserfalldiagramme stellen die Balken so dar als Folge dar. Diese Diagramme stellen positive und negative Werte gerichtet nebeneinander. Der Start des von links nach rechts gelesenene nächste Balken beginnt bei dem Wert, an dem der vorherige Balken endete. Bei positiven Werten befindet sich der Endpunkt über dem Startpunkt, bei negativen Werten darunter (Abbildung 16.20).\n\n\n\n\n\n\nAbbildung 16.20: Wasserfalldiagramm mit Leserichtungen\n\n\n\n\n\n\n\n\n\nMerke\n\n\n\nWasserfalldiagramme werden zur Visualisierung von Veränderungen über die Zeit verwendet.\n\n\nBei Wasserfalldiagrammen kann die Beschriftung der X-Achse über ein zweite Datenspalte mitgegeben werden. Bei Trichterdiagrammen können auf die gleiche Weise die Beschriftungen der Y-Achse angepasst werden. In beiden Fällen müssen die Beschriftungen in der Spalte vor den Werten gespeichert sein.\n\n\n16.2.3 Histogramm\n\n\n\n\n\n\nMerke\n\n\n\nEin Histogramm ist eine Visualisierung der Werteverteilung als Balkendiagramm.\n\n\nHistogramme visualisieren kontinuierliche bzw. metrischskalierte Wertebereiche, indem zwischen dem kleinsten und dem grössten Wert gleichmässige Intervalle gebildet werden und anschliessend die Anzahl der Werte in den Intervallen bestimmt wird.\n\n\n\n\n\n\nMerke\n\n\n\nFür ein Excel-Histogramm müssen die Werte vor der Visualisierung nicht aggregiert werden.\n\n\nEin Histogramm wird oft über einen Vektor erstellt. Werden die Daten so vorbereitet, dass unter den Werten keine anderen Daten stehen, dann kann die gesamte Spalte markiert werden, indem auf den Spaltenbuchstaben mit der Maus geklickt wird. Anschliessend kann das Histogramm in die Arbeitmappe eingefügt werden (Abbildung 16.21)\n\n\n\n\n\n\nAbbildung 16.21: Histogramm erstellen\n\n\n\nEin Excel-Histogramm ist immer ein eindimensionales Balkendiagramm. Werden Werte aus mehreren Spalten übergeben, dann fliessen alle Werte in das Histogramm ein.\n\n16.2.3.1 Histogramme optimieren\n\n\n\n\n\n\nPraxis\n\n\n\nIm Gegensatz zu Balkendiagrammen wird die Y-Achse von Histogrammen in der Regel nicht angepasst.\n\n\nExcel versucht die Intervalle für ein Histogramm aus dem vorliegenden Wertebereichen automatisch zu ermitteln. Dazu werden zwischen dem minimalen und maximalen Werten gleichgrosse Intervalle proportional zur Anzahl der Werte gewählt. Das bedeutet, dass Excel grössere Intervalle wählt, wenn weniger Werte vorhanden sind. Das ist nicht immer gewünscht oder die Intervallgrenzen liegen ungeeignet.\nDie Intervalle eines Histogramms lassen sich über die Formatierung kontrollieren. Dazu wird mit der Maus ein Balken angeklickt und anschliessend die Datenreihenoptionen ausgewählt.\n\n\n\n\n\n\nAbbildung 16.22: Histgrammintervalle konfigurieren\n\n\n\nDie Option Intervalle steht nach dem Erstellen des Histogramms auf Auto. Hier stehen die beiden Optionen Invervallbreite und Anzahl der Intervalle zur Auswahl.\nMit Intervallbreite wird der Abstand zwischen zwei Intervallen angegeben (Abbildung 16.23 (a)). Die Intervallgrenzen werden durch den kleinsten und grössten Wert definiert. Wird beispielsweise die Intervallbreite mit 500 angegeben und der kleinste Wert ist 33, dann sind die Intervallgrenzen 33, 533, 1066 usw. Diese Grenzen sind nicht immer intuitiv, besonders wenn Histogramme zum Vergleich von Daten verwendet werden. Mit der Option Unterlaufintervall kann die erste Intervallgrenze festgelegt werden. Es bietet sich an, das Unterlaufintervall genauso breit zu machen, wie die Intervallbreite.\nMit Anzahl der Intervalle wird die Anzahl der Balken im Histogramm festgelegt (Abbildung 16.23 (b)). Excel berechent aus diesem Wert einen geeigneten Intervallabstand.\nDie beiden Optionen Überlaufintervall und Unterlaufintervall ermöglichen es die Ober- bzw. Untergrenze der regulären Intervalle zu definieren. Die beiden Intervalle entsprechen dem ersten bzw. letzen Balken im Histogramm. Diese beiden Intervalle werden für die Intervallbreite nicht berücksichtigt, zählen aber zur Anzahl der Intervalle. Diese Intervalle können verwendet werden, wenn unterhalb der Grenze des Unterlaufintervalls bzw. oberhalb der Grenze des Überlaufintervalls vereinzelt “Ausreisser” mit grösseren Abständen als die Intervallbreite auftreten.\n\n\n\n\n\n\n\n\n\n\n\n(a) Intervallbreite\n\n\n\n\n\n\n\n\n\n\n\n(b) Intervallanzahl\n\n\n\n\n\n\n\nAbbildung 16.23: Einstellungsmöglichkeiten für Histogrammintervalle\n\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nFür die erste Sichtung neuer Daten ist es leichter ein Histogramm über die Anzahl der Intervalle zu definieren. Wird anschliessend auf Intervallbreite gewechselt, zeigt Excel die verwendete Intervallbreite an. So lassen sich die Intervalle einfach feinjustieren.\n\n\n\n\n16.2.3.2 Histogramme für diskrete Daten\nIn der Datenreihenformatierung findet sich zusätzlich die Option Nach Kategorie, die keine weiteren Konfigurationsmöglichkeiten bietet. In diesem Fall akzeptiert Excel einen Vektor mit diskreten und einen mit numerischen Daten. Wird diese Option für die Intervalle gewählt, dann bilden die eindeutigen diskreten Daten Kategorien. Über diese Kategorien summiert Excel den numerischen Vektor, um die Höhe der Balken zu bestimmen. Das Ergebnis ist in den meisten Fällen kein Histogramm im eigentlichen Sinn, weil es eine Summe anstatt einer Anzahl anzeigt.\nWird als numerischer Vektor der Einsvektor (Kapitel 11)verwendet, dann entspricht die Summe der einzelnen Kategorien der Anzahl der Werte in der Kategorie. Ein solcher Einsvektor wird mit der Listing 16.1 erzeugt.\n\n\n\nListing 16.1: Einsvektor für Kategorien aus einer Tabelle\n\n\n= 1 * (Tabelle1[disktrekeWerte] == Tabelle1[diskreteWerte])\n\n\n\nAuf diese Weise lässt sich in Excel ein Histogramm für diskrete Daten erstellen (Abbildung 16.24).\n\n\n\n\n\n\nAbbildung 16.24: Beispiel eines Histogramms diskreter Daten\n\n\n\nIm Fall von nominalskalierten Werten ist es oft wünschenswert die Balken in der Reihenfolge der Häufigkeiten zu organisieren. Das ist mit der Histogrammvisualisierung von Excel nicht möglich. Für solche Visualisierungen muss auf ein reguläres Balkendiagramm zurückgegriffen werden und die Daten vor der Darstellung entsprechend aufbereitet werden.\n\n\n\n16.2.4 Box-Plot\nBoxplots oder Kastendiagramme dienen der Visualisierung von Verteilungen. Im Gegensatz zu den festen Intervallen von Histogrammen, mit denen Häufigkeiten bestimmt werden, wird für Boxplots von festen Häufigkeiten ausgegangen. Diese Darstellung erlaubt es, auch sehr unterschiedliche Verteilungen miteinander zu vergleichen.\n\n\n\n\n\n\nAbbildung 16.25: Beispiel eines Boxplots\n\n\n\nWeil Boxplots auch für ordinalskalierte Wertebereiche erstellt werden können, sind sie ein flexibles Werkzeug zur Visualisierung von Verteilungen.\n\n\n\n\n\n\nMerke\n\n\n\nFür Boxplots dürfen Werte nicht aggregiert werden.\n\n\nWerden einem Boxplot aggregierte Werte übergeben, dann bestimmt Excel die Intervallgrenze für die aggregierten Werte und nicht die ursprüngliche Verteilung.\nIn der Regel wird eine ganze Arbeitsblattspalte ausgewählt, um alle relevanten Werte zu markieren. Anschliessend wird aus der Diagrammkategorie Statistik der Diagrammtyp Kastendiagramm ausgewählt.\nExcel kann gruppierte Bloxplots erstellen. Dazu muss ein zweiter Vektor mit diskreten Daten angegeben werden. Excel gruppiert dann die Werte entlang des zweiten Vektors.\n\n\n\n\n\n\nAbbildung 16.26: Beispiel eines gruppierten Boxplots\n\n\n\n\n16.2.4.1 Boxplots optimieren\nWie auch bei Balkendiagrammen fügt Excel zusätzliche Werte auf der Y-Achse ein. Diese Werte sind nur für offene Wertebereiche zulässig. Für geschlossene Wertebereiche müssen diese zusätzlichen Werte entfernt werden. Dazu wird die Beschriftung der Y-Achse ausgewählt und in der Datenreihenformatierung unter Optionen angepasst (Abbildung 16.27). Damit die Werte auch tatsächlich übernommen werden, muss die automatische Feststellung des Wertebereichs deaktiviert werden.\n\n\n\n\n\n\nAbbildung 16.27: Wertebereich der Y-Achse beim Boxplot anpassen\n\n\n\nDie Breite der Box kann über die Datenformatierung der X-Achse festgelegt werden (Abbildung 16.28). Die Option Abstandsbreite gibt den Abstand der Box zur nächsten Box als Vielfaches der Boxbreite an. Der Abstand zum Diagrammrand ist die Hälfte des Abstands zur nächsten Box. Aus den Abständen berechnet Excel die Breite der Boxen.\n\nEin Wert von 1.0 bedeutet, dass der Abstand genauso breit wie die Box ist.\nEin Wert von 0.5 bedeutet, dass der Abstand halbso breit wie die Box ist. Dadurch wird die Box breiter.\nEin Wert von 2.0 bedeutet, dass der Abstand doppelt so breit wie die Box ist. Dadurch wird die Box schmaler.\n\n\n\n\n\n\n\nAbbildung 16.28: Konfiguration der Breite eines Boxplots\n\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nWerten mehrere Vektoren gleichzeitig als Boxplot dargestellt, werden die Boxen unmittelbar nebeneinander dargestellt. Diese Abstände können nicht konfiguriert werden (Abbildung 16.29)\n\n\n\n\n\n\n\n\nAbbildung 16.29: Gruppierter Boxplot mit mehreren Vektoren (Blau und Orange)\n\n\n\n\n\n\n16.2.5 Punktdiagramm\nEin Punktdiagramm stellt zwei Vektoren mit kontinuierlichen Daten gegenüber. Ein Vektor wird der X-Achse zugewiesen, der andere der Y-Achse. Entsprechend besteht jede Datenreihe für ein Punktdiagramm immer aus zwei Vektoren.\n\n\n\n\n\n\nAbbildung 16.30: Beispiel eines Punktdiagramms mit einer Ausgleichsgeraden\n\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nDiskrete Daten können in Excel nicht als Punktdiagramm dargestellt werden, weil die Möglichkeit des Jitterplots fehlt.\n\n\nWerden mehr als zwei Vektoren für ein Punktdiagramm markiert, dann verwendet Excel standardmässig die äusserst linke Spalte immer für die Werte auf der X-Achse. Um dieses Verhalten zu ändern, müssen die Datenreihen unter Daten auswählen angepasst werden.\n\n\n\n\n\n\nPraxis\n\n\n\nSollen mehrere Gruppen von Wertepaaren in einem Punktdiagramm dargestellt werden, sollten die Gruppen dem Punktdiagramm schrittweise als separate Datenreihen hinzugefügt werden.\n\n\n\n16.2.5.1 Ausgleichsgeraden\nAusgleichsgeraden heissen in Excel Trendlinien. Drei Arten von Trendlinien können direkt in ein Punktdiagramm eingebettet werden.\n\nLinear\nLineare Prognose\nGleitender Durchschnitt\n\nVon diesen drei Trendlinienarten ist nur Linear eine Ausgleichsgerade im eigentlichen Sinn. Die Lineare Prognose ist identisch mit der Ausgleichsgeraden und unterscheidet sich nur dadurch, dass die X-Achse einen etwas grösseren positiven Wertebereich erhält.\nZusätzlich können die folgenden Ausgleichslinien konfiguriert werden.\n\nExponentiell\nLogarithmisch\nPolynomisch\nPotenz\n\n\n\n\n\n\n\nWarnung\n\n\n\nExponentielle, logarithmische und Potenzierte Ausgleichslinien sind nur für geeignete Wertebereiche (\\mathbb{R}^+) zulässig\n\n\nDie Trendlinie Gleitender Durchschnitt setzt voraus, dass die Werte auf der X-Achse aufsteigend sortiert sind. Diese Trendlinie wird meist nur dann verwendet, wenn die Werte auf der X-Achse Zeitangaben sind.\nEine Ausgleichsgerade wird über den Menübalken Diagrammentwurf das Untermenu Diagrammelement hinzufügen unter Trendlinien die Option Linear gewählt.\n\n\n\n\n\n\nAbbildung 16.31: Einfügen einer Ausgleichsgeraden\n\n\n\nEine Ausgleichsgerade kann angepasst werden, indem die Linie angelickt wird und unter Trendlinie formatieren die Trendlinienoptionen verändert werden. In diesem Dialog können auch die weiteren Ausgleichslinien konfiguriert werden (Abbildung 16.32).\n\n\n\n\n\n\nAbbildung 16.32: Konfigurationsmöglichkeiten für Ausgleichsgeraden\n\n\n\n\n\n\n16.2.6 Blasendiagramm\n\n\n\n\n\n\nMerke\n\n\n\nBlasendiagramme sind Punktdiagramme mit drei dargestellten Merkmalen.\n\n\nFür Blasendiagramme gelten die gleichen Optionen und Konfigurationen, wie für Punktdiagramme.\nWeil drei Merkmale kodiert werden, müssen die Daten in drei Spalten vorliegen. Dabei wird die linke Spalte für die X-Achse verwendet. Die mittlere Spalte wird für die Y-Achse verwendet. Die rechte Spalte enthält die Werte für die Grösse der Punkte. Prinzipiell lassen sich die Werte nachträglich noch umorganisieren, oft ist es aber einfacher, die Spalten vorher anzuordnen.\n\n\n\n\n\n\nAbbildung 16.33: Beispiel eines Blasendiagramms\n\n\n\nEine Datenreihe eines Blasendiagramms besteht aus drei Merkmalen.\n\n\n\n\n\n\nAbbildung 16.34: Konfiguration der Datenreihen eines Blasendiagramms (MacOS)\n\n\n\nIn Blasendiagrammen lassen sich die Grössenwerte auf zwei Arten abbilden:\n\nÜber den Durchmesser der Kreise.\nÜber die Fläche der Kreise.\n\nWird der Durchmesser gewählt, werden die Kreise für grössere Werte schneller grösser als bei der Einstellung, über die Fläche zu kodieren. Die Kodierung über den Durchmesser ist sinnvoll, wenn nur ein kleiner Wertebereich (3-5) mit dicht zusammenliegenden Werten dargestellt werden muss. In allen anderen Fällen sollte die Kodierung über die Fläche der Kreise erfolgen.\nDie Blasengrösse wird konfiguriert, indem zuerst auf einen Kreis mit der Maus geklickt wird und anschliessend unter Datenreihen formatieren unter Reihenoptionen die Strategie für die Blasengrösse angepasst wird (Abbildung 16.35)\n\n\n\n\n\n\nAbbildung 16.35: Konfiguration der Blasengrösse\n\n\n\n\n\n16.2.7 Linien-, Kreis- und Donutdiagramme\nLinien-, Kreis- und Donutdiagramme sind in Excel Varianten von Balkendiagrammen: Sie verwenden das gleiche Format für die Datenreihen und werden ansonsten gleich konfiguriert. Wie bei Balkendiagrammen, wird die X-Achse als eine diskrete Datenskalierung behandelt. Die Daten können also nominal- oder ordinalskaliert sein.\n\n\n\n\n\n\nPraxis\n\n\n\nKreis- und Donutdiagramme sind identisch mit Balkendiagrammen, wenn alle Werte positiv sind. Für mehr als drei Werte können die meisten Menschen sich diese Diagramme oft nicht richtig interpretieren. Deshalb sollten Kreis- und Donutdiagramme möglichst nur zur Darstellung (extremer) Mengenverhältinisse verwendet werden. Grundsätzlich ist ein Balkendiagramm einem Kreis- oder Donutdiagramm vorzuziehen. (s. Abbildung 16.36 und Abbildung 16.37)\n\n\n\n\n\n\n\n\nAbbildung 16.36: Kreisdiagramm mit ähnlich grossen Werten\n\n\n\n\n\n\n\n\n\nAbbildung 16.37: Balkendiagramm für die gleichen Werte aus Abbildung 16.36\n\n\n\nExcels Liniendiagramme zeichnen für jeden Wert auf der Y-Achse einen Punkt und verbinden die Punkte mit geraden Linien.\n\n\n\n\n\n\nAchtung\n\n\n\nWeil die X-Achse immer diskrete Daten abbildet, dürfen Liniendiagramme nicht mit Punktdiagrammen mit interpolierten Linien verwechselt werden.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nExcels Liniendiagramme sollten nur für sog. Paralleldiagramme verwendet werden, in denen mehrere diskrete Merkmale mit dem gleichen Wertebereich gegenübergestellt werden. Durch die Linien werden Unterschiede in den Ausprägungsprofilen sichtbar.\nAbbildung 16.38 zeigt ein solches Paralleldiagramm. Dieses Beispiel macht die Grenzen dieses Diagrammtyps sichbar, weil Excel sich überlagernde Linien nicht nebeneinander darstellen kann.\n\n\n\n\n\n\n\n\nAbbildung 16.38: Anwendung eines Liniendiagramms als Paralleldiagramm\n\n\n\nEine Variante von Paralleldiagrammen sind sog. Netzdiagramme (bzw. Spider-Web-Diagramme).\n\n\n\n\n\n\nMerke\n\n\n\nNetzdiagramme ordnen die Kategorien der X-Achse sternförmig an.\n\n\nIn Excel finden sich Netzdiagramme unter der Kategorie Wasserfalldiagramme. Diese Diagramme werden oft zum Vergleich von Merkmalsprofilen verwendet, z.B. als Ergänzung einer Stärken- und Schwächen-Analyse (SWOT-Analyse)\n\n\n\n\n\n\nAbbildung 16.39: Netzdiagramm mit den gleichen Daten wie Abbildung 16.38",
    "crumbs": [
      "Deskriptive Datenanalyse",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Daten visualisieren</span>"
    ]
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html#mathematische-funktionen-visualisieren",
    "href": "kapitel/daten-visualisieren/kapitel.html#mathematische-funktionen-visualisieren",
    "title": "16  Daten visualisieren",
    "section": "16.3 Mathematische Funktionen visualisieren",
    "text": "16.3 Mathematische Funktionen visualisieren\n\n\n\n\n\n\nMerke\n\n\n\nMathematische Funktionen werden immer über Punktdiagramme oder Punkte mit interpolierten Linien dargestellt.\n\n\nExcel kann mathematische Funktionen nicht direkt visualisieren. Stattdessen müssen die Funktionen für einen gewünschten Wertebereich berechnet werden. Dazu werden Punkte auf der X-Achse ausgewählt und berechnet. Zwischen diesen Punkten berechnet Excel die Funktion nicht, sondern verbindet diese Punkte nur durch eine Linie. Diese Linie muss keine Gerade sein. Stattdessen versucht Excel eine Kurve so durch einen Punkt zu legen, sodass die Kurve keine Ecke hat. Die Folge dieses Verbinden von Punkten ist, dass je weniger Werte auf der X-Achse ausgewählt werden, desto ungenauer wird die Funktionsdarstellung.\nUm eine mathematische Funktion mit Excel zu visualisieren, muss eine Wertetabelle erstellt werden. Diese Tabelle wird in den folgenden Schritten erstellt.\n\nDie Unter- und Obergrenze des Darstellungsbereichs auf der X-Achse werden festgelegt.\nAus diesen Intervallgrenzen wird die Differenz gebildet, woraus sich die Länge des Intervalls ergibt.\nDie Anzahl der Punkte in diesem Intervall festgelegt.\nDie Länge des Intervalls wird durch die Anzahl der Punkte geteilt. Daraus ergibt sich der Abstand der Punkte im Intervall.\nEs wird eine Sequenz mit einer Länge der Anzahl der Punkte plus Eins gebiltet. Der Startwert dieser Sequenz ist die Untergrenze des Darstellungsbereichs. Die Schrittweite entspricht dem Abstand der Punkte Abstand der Punkte.\nDie mathematische Funktion wird als Formel in die Spalte rechts neben der Sequenz eingegeben. Die Werte der Sequenz werden als Argumente der mathematischen Funktion verwendet.\n\n\n\n\n\n\n\nHinweis\n\n\n\nDie Sequenz für die Wertetabelle muss die Anzahl der Punkte plus Eins enthalten, damit sowohl die Untergrenze als auch die Obergrenze des Darstellungsbereichs als Argumente verwendet werden.\n\n\nSollen mehrere Funktionen über das gleiche Intervall dargestellt werden, dann wird der letzte Schritt für jede zusätzliche Funktion wiederholt werden. Das Intervall der Funktionsargumente bildet immer die erste Wertespalte. Anschliessend wird die gesamte Wertetabelle visualisiert.\nDiese Wertetabelle kann als Punktdiagramm dargestellt werden. Dazu wird die gesamte Wertetabelle markiert und als Punkte mit interpolierten Linien visualisiert.\n\n\n\n\n\n\nAbbildung 16.40: Beispiel der Visualisierung der Funktionen f(x) = 2x^2 -3 und g(x)=2x+4",
    "crumbs": [
      "Deskriptive Datenanalyse",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Daten visualisieren</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referenzen",
    "section": "",
    "text": "Fisher, N. I., & Kordupleski, R. E. (2019). Good and bad market\nresearch: A critical review of net promoter score. Applied\nStochastic Models in Business and Industry, 35(1),\n138–151. https://doi.org/10.1002/asmb.2417\n\n\nGrisaffe, D. B. (2007). Questions about the ultimate question:\nConceptual considerations in evaluating reichheld’s net promoter score\n(NPS). 20.\n\n\nKeiningham, T. L., Cooil, B., Andreassen, T. W., & Aksoy, L. (2007).\nA longitudinal examination of net promoter and firm revenue growth.\nJournal of Marketing, 71(3), 39–51. https://doi.org/10.1509/jmkg.71.3.039\n\n\nMicrosoft Support. (2023a). Excel specifications and limits. https://support.microsoft.com/en-gb/office/excel-specifications-and-limits-1672b34d-7043-467e-8e27-269d656771c3\n\n\nMicrosoft Support. (2023b). Using structured references with excel\ntables. https://support.microsoft.com/en-gb/office/using-structured-references-with-excel-tables-f5ed2452-2337-4f71-bed3-c8ae6d2b276e\n\n\nReichheld, F. F. (2003). The one number you need to grow. Harvard\nBusiness Review.",
    "crumbs": [
      "Referenzen"
    ]
  }
]