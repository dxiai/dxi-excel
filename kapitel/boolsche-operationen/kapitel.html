<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Einführung in die Datenwissenschaft mit Excel - 10&nbsp; Aussagenlogik</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../kapitel/vektor-operationen/kapitel.html" rel="next">
<link href="../../kapitel/zeichenketten/kapitel.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zusätzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zurücksetzen",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../kapitel/variablen/kapitel.html">Mathematik der Daten</a></li><li class="breadcrumb-item"><a href="../../kapitel/boolsche-operationen/kapitel.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Aussagenlogik</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Einführung in die Datenwissenschaft mit Excel</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/dxiai/dxi-excel" rel="" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Vorwort</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Ausgangslage und Vorbereitung</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/einleitung/kapitel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Einleitung</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/einleitung/excel-versionen.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Excel Versionen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/einleitung/02_oberflaeche.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Bedienoberfläche</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/einleitung/01_jargon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Excel Jargon</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Datenquellen</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/daten-sammeln/kapitel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Daten sammeln</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/datentypen/kapitel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Datentypen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/daten-importieren/kapitel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Daten importieren</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Mathematik der Daten</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/variablen/kapitel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Variablen, Funktionen und Operatoren</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/zeichenketten/kapitel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Zeichenketten</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/boolsche-operationen/kapitel.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Aussagenlogik</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/vektor-operationen/kapitel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Vektoroperationen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/matrix-operationen/kapitel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Matrix-Operationen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/kodieren-gruppieren/kapitel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Kodieren und Gruppieren</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/daten-formen/kapitel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Daten formen</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
 <span class="menu-text">Deskriptive Datenanalyse</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/daten-beschreiben/kapitel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Daten beschreiben</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/daten-visualisieren/kapitel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Daten visualisieren</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../kapitel/daten-visualisieren/pivot-tabellen.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Pivot-Tabellen</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referenzen</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Inhaltsverzeichnis</h2>
   
  <ul>
  <li><a href="#wahrheitswerte-in-excel" id="toc-wahrheitswerte-in-excel" class="nav-link active" data-scroll-target="#wahrheitswerte-in-excel"><span class="header-section-number">10.1</span> Wahrheitswerte in Excel</a></li>
  <li><a href="#aussagenlogische-operationen" id="toc-aussagenlogische-operationen" class="nav-link" data-scroll-target="#aussagenlogische-operationen"><span class="header-section-number">10.2</span> Aussagenlogische Operationen</a></li>
  <li><a href="#vergleiche" id="toc-vergleiche" class="nav-link" data-scroll-target="#vergleiche"><span class="header-section-number">10.3</span> Vergleiche</a>
  <ul class="collapse">
  <li><a href="#der-in-operator-mit-xverweis" id="toc-der-in-operator-mit-xverweis" class="nav-link" data-scroll-target="#der-in-operator-mit-xverweis"><span class="header-section-number">10.3.1</span> Der <span class="math inline">\in</span>-Operator mit XVERWEIS</a></li>
  <li><a href="#zeichenketten-vergleichen" id="toc-zeichenketten-vergleichen" class="nav-link" data-scroll-target="#zeichenketten-vergleichen"><span class="header-section-number">10.3.2</span> Zeichenketten vergleichen</a></li>
  </ul></li>
  <li><a href="#fälle-unterscheiden" id="toc-fälle-unterscheiden" class="nav-link" data-scroll-target="#fälle-unterscheiden"><span class="header-section-number">10.4</span> Fälle unterscheiden</a>
  <ul class="collapse">
  <li><a href="#wenn" id="toc-wenn" class="nav-link" data-scroll-target="#wenn"><span class="header-section-number">10.4.1</span> WENN</a></li>
  <li><a href="#wenns" id="toc-wenns" class="nav-link" data-scroll-target="#wenns"><span class="header-section-number">10.4.2</span> WENNS</a></li>
  <li><a href="#ersterwert" id="toc-ersterwert" class="nav-link" data-scroll-target="#ersterwert"><span class="header-section-number">10.4.3</span> ERSTERWERT</a></li>
  <li><a href="#xverweis-zur-fallunterscheidung" id="toc-xverweis-zur-fallunterscheidung" class="nav-link" data-scroll-target="#xverweis-zur-fallunterscheidung"><span class="header-section-number">10.4.4</span> XVERWEIS zur Fallunterscheidung</a></li>
  <li><a href="#anwendungshilfe-für-fallunterscheidungen" id="toc-anwendungshilfe-für-fallunterscheidungen" class="nav-link" data-scroll-target="#anwendungshilfe-für-fallunterscheidungen"><span class="header-section-number">10.4.5</span> Anwendungshilfe für Fallunterscheidungen</a></li>
  </ul></li>
  <li><a href="#rezepte" id="toc-rezepte" class="nav-link" data-scroll-target="#rezepte"><span class="header-section-number">10.5</span> Rezepte</a>
  <ul class="collapse">
  <li><a href="#fehlerwerte-abfangen" id="toc-fehlerwerte-abfangen" class="nav-link" data-scroll-target="#fehlerwerte-abfangen"><span class="header-section-number">10.5.1</span> Fehlerwerte abfangen</a></li>
  <li><a href="#eine-zahl-für-genau-eine-bedingung-zurückgeben" id="toc-eine-zahl-für-genau-eine-bedingung-zurückgeben" class="nav-link" data-scroll-target="#eine-zahl-für-genau-eine-bedingung-zurückgeben"><span class="header-section-number">10.5.2</span> Eine Zahl für genau eine Bedingung zurückgeben</a></li>
  <li><a href="#fehlerwerte-vergleichen" id="toc-fehlerwerte-vergleichen" class="nav-link" data-scroll-target="#fehlerwerte-vergleichen"><span class="header-section-number">10.5.3</span> Fehlerwerte vergleichen</a></li>
  <li><a href="#sortierreihenfolge" id="toc-sortierreihenfolge" class="nav-link" data-scroll-target="#sortierreihenfolge"><span class="header-section-number">10.5.4</span> Sortierreihenfolge</a></li>
  <li><a href="#einfache-verzweigungen" id="toc-einfache-verzweigungen" class="nav-link" data-scroll-target="#einfache-verzweigungen"><span class="header-section-number">10.5.5</span> Einfache Verzweigungen</a></li>
  <li><a href="#abbruchbedingungen" id="toc-abbruchbedingungen" class="nav-link" data-scroll-target="#abbruchbedingungen"><span class="header-section-number">10.5.6</span> Abbruchbedingungen</a></li>
  <li><a href="#komplexe-entscheidungen" id="toc-komplexe-entscheidungen" class="nav-link" data-scroll-target="#komplexe-entscheidungen"><span class="header-section-number">10.5.7</span> Komplexe Entscheidungen</a></li>
  <li><a href="#excels-wenns" id="toc-excels-wenns" class="nav-link" data-scroll-target="#excels-wenns"><span class="header-section-number">10.5.8</span> Excels WENNS</a></li>
  <li><a href="#sonstige-entscheidungen-in-excel" id="toc-sonstige-entscheidungen-in-excel" class="nav-link" data-scroll-target="#sonstige-entscheidungen-in-excel"><span class="header-section-number">10.5.9</span> Sonstige Entscheidungen in Excel</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/dxiai/dxi-excel/issues/new" class="toc-action">Problem melden</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-chapter-boolsche-operationen" class="quarto-section-identifier"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Aussagenlogik</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="abstract-title">Zusammenfassung</div>
    <p>Dieses Kapitel befasst sich mit der Anwendung der Aussagenlogik in Excel. Es werden die logischen Operatoren NICHT, UND, ODER und XODER behandelt. Auf dieser Grundlage werden die wichtigsten Vergleichsoperation zum Formulieren logischer Ausdrücke vorgestellt. Das Kapitel schliesst mit der Anwendung von Fallunterscheidungen.</p>
    <p>Es werden die folgenden Funktionen behandelt: <code>NICHT()</code>, <code>UND()</code>, <code>ODER()</code>, <code>XODER()</code>, <code>WENN()</code>, <code>WENNS()</code>, <code>ERSTERWERT()</code>, <code>WENNFEHLER()</code>, <code>FEHLER.TYP()</code>, <code>ISTFEHLER()</code>, <code>XVERWEIS()</code>, <code>IDENTISCH()</code></p>
  </div>
</div>

</header>

<section id="wahrheitswerte-in-excel" class="level2" data-number="10.1">
<h2 data-number="10.1" class="anchored" data-anchor-id="wahrheitswerte-in-excel"><span class="header-section-number">10.1</span> Wahrheitswerte in Excel</h2>
<p>Wie im Kapitel Datentypen bereits erwähnt, kennt Excel den Datentyp der Wahrheitswerte. Diese Wahrheitswerte können entweder den Wert <code>WAHR</code> oder <code>FALSCH</code> haben. Eine Operation, die Wahrheitswerte ergibt wird als <em>logischer Ausdruck</em> bezeichnet. Weil logische Ausdrücke für viele Funktionen und Operationen notwendig sind, wandelt Excel die Werte anderer Datentypen bei Bedarf um. Dabei gelten die folgenden Regeln:</p>
<ul>
<li><code>0</code> und die <em>leere Zelle</em> entspricht dem Wert <code>FALSCH</code>.</li>
<li>Alle Zahlen ungleich <code>0</code> entstprechen dem Wert <code>WAHR</code>.</li>
<li>Alle Zeichenketten inklusive der <em>leeren Zeichenkette</em> entsprechen dem Wert <code>WAHR</code>.</li>
<li>Fehlerwerte bleiben unverändert.</li>
</ul>
<p>Werden Wahrheitswerte in mathematischen Operationen und Funktionen verwendet, dann konvertiert Excel den Wert <code>FALSCH</code> in <code>0</code> und den Wert <code>WAHR</code> in <code>1</code> um.</p>
<p>Werden Wahrheitswerte als Parameter an Zeichenkettenfunktionen übergeben, dann werden die Wahrheitswerte in die entsprechende Zeichenkette umgewandelt. Aus dem Wert <code>WAHR</code> wird also die Zeichenkette <code>"WAHR"</code> und aus dem Wert <code>FALSCH</code> wird die Zeichenkette <code>"FALSCH"</code>.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warnung
</div>
</div>
<div class="callout-body-container callout-body">
<p>Wahrheitswerte werden in den verschiedenen Sprachversionen von Excel in der eingestellten Sprache angegeben. Beim Wechsel zwischen verschiedenen Excel-Sprachversionen werden die Wahrheitswerte automatisch korrekt angezeigt. Die Umwandlung in Zeichenketten erfolgt dann in der jeweiligen Sprache. Deshalb sollte die Verwendung von in Zeichenketten konvertierten Wahrheitswerten in nachgelagerten Funktionen vermieden werden.</p>
</div>
</div>
</section>
<section id="aussagenlogische-operationen" class="level2" data-number="10.2">
<h2 data-number="10.2" class="anchored" data-anchor-id="aussagenlogische-operationen"><span class="header-section-number">10.2</span> Aussagenlogische Operationen</h2>
<p>Für Wahrheitswerte existieren spezielle Operationen, um die Regeln der <em>Aussagenlogik</em> bzw. der <em>Boole’schen Algebra</em> abzubilden. Diese Operationen verknüpfen Wahrheitswerte und haben Wahrheitswerte als Ergebnis. Die vier Grundoperationen <code>NICHT</code> (<span class="math inline">\lnot</span>), <code>UND</code> (<span class="math inline">\land</span>), <code>ODER</code> (<span class="math inline">\lor</span>, “inklusives Oder”) und <code>XODER</code> (<span class="math inline">\oplus</span>, “entweder-oder”) sind in Excel als Funktionen verfügbar.</p>
<p>Die Funktion <code>NICHT()</code> wandelt einen Wert in den jeweils den anderen Wahrheitswert um. Falls anstelle eines Wahrheitswerts ein anderer Datentyp übergeben wurde, gelten die oben angegebenen Regeln für die Umwandlung.</p>
<p>Die Funktionen <code>UND()</code>, <code>ODER()</code> und <code>XODER()</code> sind <em>Aggregatoren</em>. Das bedeutet, dass Sie alle Werte in dem angegebenen Bereichen zusammenfassen. Das ist oft nicht das gewünschte Verhalten. Deshalb muss bei der Arbeit mit Vektoren auf die Bool’sche Arithmetik zurückgegriffen werden, um logische Ausdrücke richtig auszuwerten.</p>
<p>Zum Beispiel sollen für die folgenden Werte <em>paarweise</em> der logische Ausdruck <span class="math inline">a \land b</span> ausgewertet werden, so dass für alle Wertepaare der richtige Wahrheitswert ermittelt wird.</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>WAHR</code></td>
<td style="text-align: center;"><code>FALSCH</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>FALSCH</code></td>
<td style="text-align: center;"><code>WAHR</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>WAHR</code></td>
<td style="text-align: center;"><code>WAHR</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>FALSCH</code></td>
<td style="text-align: center;"><code>WAHR</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>WAHR</code></td>
<td style="text-align: center;"><code>WAHR</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>FALSCH</code></td>
<td style="text-align: center;"><code>FALSCH</code></td>
</tr>
</tbody>
</table>
<p>Die Formel <code>= UND(A1:A6; B1:B6)</code> liefert den Wert <code>FALSCH</code> zurück, weil nicht alle Werte im <em>gesamten Bereich</em> von <code>A1:A6</code> und <code>B1:B6</code> gleich <code>WAHR</code> sind. Es gibt keine Funktion und keinen eigenen logischen Operator zur paarweisen logischen Verknüpfung dieser beiden Bereiche. Deshalb werden in Excel oft logische Ausdrücke in der Boole’schen Arithmethik eingesetzt, um nur die Werte aus den gleichen Datensätzen miteinander zu vergleichen. Diese Schreibweise ist immer dann notwendig, wenn logische Ausdrücke sich auf die einzelnen Datensätze beziehen.</p>
<p>Die Formel <code>= A1:A6 * B1:B6</code> hat die Werte <code>{0;0;1;0;1;0}</code> zum Ergebnis. Um Wahrheitswerte zuerhalten kann noch auf die Ungleichheit mit <code>0</code> geprüft werden. Dazu wird die Formel wie folgt ergänzt: <code>= (A1:A6 * B1:B6) &lt;&gt; 0</code>. Das Ergebnis ist nun <code>{FALSCH; FALSCH; WAHR; FALSCH; WAHR; FALSCH}</code>. Dieser Schritt ist in der Praxis selten notwendig, weil für die meisten Operationen Zahlenwerte implizit als Wahrheitswerte behandelt werden.</p>
<p>Weil Excel alle Werte ungleich <code>0</code> als <code>WAHR</code> interpretiert, können die Operationen <code>UND()</code> mit <code>*</code> und die Operation <code>ODER()</code> mit <code>+</code> direkt ersetzt werden. Hierbei ist darauf zu achten, dass das nummerische Ergebnis dieser Addition oder Multiplikation <em>ausschliesslich</em> als Wahrheitswert von Bedeutung ist.</p>
<p>Die Operation <code>XODER()</code> entspricht der Ungleichheit <code>&lt;&gt;</code>. Dabei muss allerdings darauf geachtet werden, das dieser Vergleich als Ersatz für <code>XODER()</code> <em>ausschliesslich</em> für Wahrheitswerte bzw. <code>0</code> und <code>1</code> erlaubt ist. Für die oben gezeigten Werte ergibt die Formel <code>= (A1:A5 &lt;&gt; B1:B5)</code> die Werte <code>{WAHR; WAHR; FALSCH; WAHR; FALSCH; FALSCH}</code>. Das Ergebnis ist deshalb sichergestellt, weil alle Vergleichswerte <code>0</code> oder <code>1</code> sind. Werden jedoch auch andere Vergleichswerte zugelassen, dann liefert die Formel <code>= (A1:A6 &lt;&gt; B1:B6)</code> die Werte <code>{WAHR; WAHR; WAHR; WAHR; WAHR; WAHR}</code>. Dieses Verhalten zeigt das folgende Beispiel.</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;"><code>0</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>0</code></td>
<td style="text-align: center;"><code>2</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;"><code>2</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>0</code></td>
<td style="text-align: center;"><code>1</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>3</code></td>
<td style="text-align: center;"><code>2</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>0</code></td>
<td style="text-align: center;"><code>0</code></td>
</tr>
</tbody>
</table>
<p>Damit das Richtige Ergebnis erzeugt wird, müssen die Werte in Wahrheitswerte konvertiert werden. Dazu muss die Formel durch Vergleiche ungleich <code>0</code> erweitert werden:</p>
<pre><code>= (A1:A6 &lt;&gt; 0) &lt;&gt; (B1:B6 &lt;&gt; 0)</code></pre>
<p>Diese Formel liefert die gewünschten Werte <code>{WAHR; WAHR; FALSCH; WAHR; FALSCH; FALSCH}</code>.</p>
<p>Die folgende Tabelle zeigt logischen Operatoren und die zugehörigen Terme für die Boole’sche Arithmetik.</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Operator</th>
<th style="text-align: center;">&nbsp;Boole’sche Operation</th>
<th style="text-align: center;">Vereinfachter Operator</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\lnot</span></td>
<td style="text-align: center;"><code>1 - a</code></td>
<td style="text-align: center;"><code>NICHT(a)</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\land</span></td>
<td style="text-align: center;"><code>a * b</code></td>
<td style="text-align: center;"><code>a * b</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\lor</span></td>
<td style="text-align: center;"><code>a + b - a * b</code></td>
<td style="text-align: center;"><code>a + b</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\oplus</span></td>
<td style="text-align: center;"><code>a + b - 2 * a * b</code> oder <code>( a - b ) ^ 2</code></td>
<td style="text-align: center;"><code>(a &lt;&gt; b)</code></td>
</tr>
</tbody>
</table>
</section>
<section id="vergleiche" class="level2" data-number="10.3">
<h2 data-number="10.3" class="anchored" data-anchor-id="vergleiche"><span class="header-section-number">10.3</span> Vergleiche</h2>
<p>Eine besondere Art von logischen Ausdrücken sind <em>Vergleiche</em>. Ein Vergleich prüft das Verhältnis zweier Werte zueinander. Excel kennt die üblichen Vergleichsoperatoren, die jeweils einen Wahrheitswert zurückliefern.</p>
<p>In Excel werden die Vergleichsoperatoren wie folgt geschrieben:</p>
<ul>
<li><code>&gt;</code> (grösser als)</li>
<li><code>&lt;</code> (kleiner als)</li>
<li><code>&gt;=</code> (grösser oder gleich)</li>
<li><code>&lt;=</code> (kleiner oder gleich)</li>
<li><code>=</code> (gleich)</li>
<li><code>&lt;&gt;</code> (ungleich)</li>
</ul>
<p>Excel’s Vergleichsoperatoren sind Datentypen sensitiv. Das bedeutet, dass die Operatoren Datentypen vor dem Vergleich <em>nicht</em> angleichen. Der Vergleich folgende Vergleich ergibt also immer <code>FALSCH</code>.</p>
<pre><code>= 3 = "3"</code></pre>
<p>Weil die Operationen <code>*</code>, <code>+</code> und <code>-</code> normalerweise vor den Vergleichsoperatoren ausgeführt werden, müssen alle Vergleiche eines logischen Ausdrucks für die Boole’sche Arithmetik in Klammern gesetzt werden.</p>
<section id="der-in-operator-mit-xverweis" class="level3" data-number="10.3.1">
<h3 data-number="10.3.1" class="anchored" data-anchor-id="der-in-operator-mit-xverweis"><span class="header-section-number">10.3.1</span> Der <span class="math inline">\in</span>-Operator mit XVERWEIS</h3>
<p>Mithilfe der Funktion <code>XVERGLEICH()</code> kann der <span class="math inline">\in</span>-Operator aus der <em>Mengenlehre</em> in Excel für logische Ausdrücke bereitgestellt werden. Mit dieser Funktion <code>XVERWEIS()</code> können sowohl der <span class="math inline">\in</span> als auch der <span class="math inline">\notin</span>-Operator mit <code>XVERWEIS()</code> abgebildet werden.</p>
<p>Für die folgenden Beispiele verwenden wir die Werte:</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Suchkriterium</td>
<td style="text-align: center;">Suchbereich</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>4</code></td>
<td style="text-align: center;"><code>1</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>7</code></td>
<td style="text-align: center;"><code>3</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"><code>4</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"><code>8</code></td>
</tr>
</tbody>
</table>
<ul>
<li><span class="math inline">\in</span>-Operator: <code>XVERWEIS(A2:A3; B2:B5; B2:B5 = B2:B5; FALSCH)</code></li>
<li><span class="math inline">\notin</span>-Operator: <code>XVERWEIS(A2:A3; B2:B5; B2:B5 &lt;&gt; B2:B5; WAHR)</code></li>
</ul>
<p>Der Trick besteht darin, dass die <em>Rückgabematrix</em> durch einen Vergleich aus dem Suchbereich erzeugt wird. Dadurch wird die Rückgabematrix mit den gleichen Wahrheitswerten für alle Werte im Suchbereich gefüllt. Die erste Formel ergibt deshalb <code>{WAHR; FALSCH}</code> und die zweite Formel <code>{FALSCH; WAHR}</code>, weil der Wert <code>4</code> im Suchbereich vorkommt und der Wert <code>7</code> nicht. Diese Werte können direkt in logischen Ausdrücken verwendet werden.</p>
</section>
<section id="zeichenketten-vergleichen" class="level3" data-number="10.3.2">
<h3 data-number="10.3.2" class="anchored" data-anchor-id="zeichenketten-vergleichen"><span class="header-section-number">10.3.2</span> Zeichenketten vergleichen</h3>
<p>Die Vergleichsoperatoren zeigen die Unterschiede zweier Zeichenketten bezüglich der alphabetischen Sortierung an. Die “kleinste” Zeichenkette ist die leere Zeichenkette. Gross- und Kleinschreibung wird bei Zeichenkettenvergleichen nicht unterschieden.</p>
<p>Weil Excel für Vergleiche die nicht-druckbaren Zeichen mit Ausnahme des Leerzeichens und des Tabulators ignoriert, gibt der Vergleichsoperator <code>=</code> <code>WAHR</code> auch für Zeichenketten zurück, die unterschiedliche nicht-druckbare Zeichen enthalten. Das gleiche Problem entsteht beim Vergleich von unterschiedlicher Gross- und Kleinschreibung. Um auch diese Unterschiede zu erkennen, müssen wir die Funktion <code>IDENTISCH()</code> verwenden. Diese Funktion vergleicht die Zeichenketten Zeichen für Zeichen und liefert nur dann <code>WAHR</code> zurück, wenn die Zeichenketten exakt gleich sind.</p>
<p>BEISPIEL</p>
</section>
</section>
<section id="fälle-unterscheiden" class="level2" data-number="10.4">
<h2 data-number="10.4" class="anchored" data-anchor-id="fälle-unterscheiden"><span class="header-section-number">10.4</span> Fälle unterscheiden</h2>
<p>Logische Ausdrücke eigenen sich besonders gut, um <em>Fallunterscheidungen</em> zu formulieren, weil ein logischer Ausdruck immer nur zwei Werte als Ergebnis haben kann. Es gibt also für jeden logischen Ausdruck immer nur zwei unterscheidbare Fälle.</p>
<p>Excel hat zwei zentrale Funktionen für Fallunterscheidungen: <code>WENN()</code> und <code>WENNS()</code>. Die Funktion <code>WENN()</code> ist eine <em>einfache</em> Unterscheidung, die Funktion <code>WENNS()</code> unterstützt <em>mehrfache</em> Unterscheidungen. In anderen Programmiersprachen wird in diesem Zusammenhang auch von <em>Verzweigungen</em> gesprochen.</p>
<section id="wenn" class="level3" data-number="10.4.1">
<h3 data-number="10.4.1" class="anchored" data-anchor-id="wenn"><span class="header-section-number">10.4.1</span> WENN</h3>
<p>Die Funktion <code>WENN()</code> ist eine <em>einfache</em> Fallunterscheidung. Einfach bedeutet hier, dass die beiden Fälles <em>eines</em> logischen Ausdrucks unterschieden werden. Entsprechend hat die Funktion <code>WENN()</code> drei Parameter:</p>
<ol type="1">
<li>Der auszuwertende logische Ausdruck.</li>
<li>Das Ergebnis falls der logische Ausdruck <code>WAHR</code> ergibt.</li>
<li>Das Ergebnis falls der logische Ausdruck <code>FALSCH</code> ergibt.</li>
</ol>
<p>Das Ergebnis für den Fall, dass der logische Ausdruck <code>FALSCH</code> ergibt, ist optional. Fehlt dieser Parameter, dann wird der Wert <code>FALSCH</code> zurückgegeben.</p>
<p>Das Verhalten dieser Funktion lässt sich mit den Wahrheitswerten als logischer Ausdruck direkt überprüfen:</p>
<pre><code>= WENN(WAHR; "Guten Tag"; "Auf Wiedersehen")</code></pre>
<p>Weil der logische Ausdruck in diesem Fall <code>WAHR</code> ist, wird der zweite Parameter als Ergebnis zurückgegeben. Die Formel gibt also den Wert <code>"Guten Tag"</code> zurück.</p>
<p>Wird der logische Ausdruck auf <code>FALSCH</code> geändert, dann liefert die Formel den Wert <code>"Auf Wiedersehen"</code>.</p>
<pre><code>= WENN(FALSCH; "Guten Tag"; "Auf Wiedersehen")</code></pre>
<p>Lassen wir den dritten Parameter weg, dann wird der Wert <code>FALSCH</code> zurückgegeben.</p>
<pre><code>= WENN(FALSCH; "Guten Tag")</code></pre>
<p>Ausser der Fallunterscheidung hat <code>WENN()</code> keine weiteren Eigenschaften. Deshalb wird diese Funktion in der Praxis oft mit anderen Funktionen kombiniert. Das kann mit der Funktion <code>WENN()</code> selbst geschehen. In diesem Fall wird von geschachtelten Fallunterscheidungen gesprochen.</p>
<p>Zur Veranschaulichung dient das folgende Beispiel:</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;">A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: center;"><code>4</code></td>
</tr>
<tr class="even">
<td style="text-align: right;">2</td>
<td style="text-align: center;"><code>7</code></td>
</tr>
</tbody>
</table>
<p>Eine Fallunterscheidung soll prüfen, ob die Werte in <code>A1:A2</code> Werte gleich <code>1</code>, <code>3</code>, <code>4</code> oder <code>8</code> sind. Falls das der Fall ist, soll der zugehörige Zahlwert als Zeichenkette ausgegeben werden. Falls das nicht der Fall ist, soll der Wert <code>Ungültig</code> zurückgegeben werden. Als geschachtelte <code>WENN()</code>-Funktion lässt sich diese Fallunterscheidung wie folgt formulieren:</p>
<pre><code>= WENN(A1 = 1; "Eins"; 
       WENN(A1 = 3; "Drei"; 
            WENN(A1 = 4; "Vier"; 
                 WENN(A1 = 8; "Acht"; 
                      "Ungültig"))))</code></pre>
<p>Eine solche geschachtelte Fallunterscheidung wird als <em>Entscheidungsbaum</em> bezeichnet.</p>
</section>
<section id="wenns" class="level3" data-number="10.4.2">
<h3 data-number="10.4.2" class="anchored" data-anchor-id="wenns"><span class="header-section-number">10.4.2</span> WENNS</h3>
<p>Die Funktion <code>WENN()</code> ist eine <em>einfache</em> Fallunterscheidung. In vielen Excel-Arbeitsmappen existieren geschachtelte Aufrufe von <code>WENN()</code>-Funktionen. Diese Aufrufe machen die Formeln nicht nur schwer lesbar, sondern auch fehleranfällig und ineffizient. Deshalb sollten geschachtelte Fallunterscheidungen unbedingt vermieden werden. Mit der Funktion <code>WENNS()</code> lassen sich geschachtelte Fallunterscheidungen vermeiden, indem alle Fallunterscheidungen in einem einzigen Funktionsaufruf zusammengefasst werden.</p>
<blockquote class="blockquote">
<p><strong>Merke:</strong> geschachtelte Fallunterscheidungen mit <code>WENN()</code> unbedingt vermeiden!</p>
</blockquote>
<p>Die Funktion <code>WENNS()</code> erwartet Parameterpaare, bestehend aus einem logischen Ausdruck und dem Ergebnis, falls dieser logische Ausdruck <code>WAHR</code> ergibt. Die Funktion kann bis zu 127 Parameterpaare verarbeiten, so dass sich auch sehr komplexe Fallunterscheidungen mit dieser Funktion abbilden lassen.</p>
<p>(<em>Beispiel 1</em>) Das folgende Beispiel zeigt die Verwendung der Funktion <code>WENNS()</code> für die geschachtelte Fallunterscheidung aus dem Abschnitt <code>WENN</code>.</p>
<pre><code>= WENNS(A2:A3 = 1; "Eins"; 
        A2:A3 = 3; "Drei"; 
        A2:A3 = 4; "Vier"; 
        A2:A3 = 8; "Acht")</code></pre>
<p>Das Beispiel bildet aber noch nicht die vollständige Fallunterscheidung ab. Es fehlt noch der Fall, dass keiner der logischen Ausdrücke <code>WAHR</code> ergibt. Leider kann <code>WENNS()</code> ausschliesslich logische Ausdrücke mit ihren Ergebnissen verbinden.</p>
<blockquote class="blockquote">
<p><strong>Merke:</strong> <code>WENNS()</code> kann nur logische Ausdrücke mit ihren <code>WAHR</code>-Ergebnissen verbinden.</p>
</blockquote>
<p>Anders als bei <code>WENN()</code> gibt es keine direkte Möglichkeit, ein Ergebnis festzulegen, falls alle logische Ausdrücke <code>FALSCH</code> ergeben. Um ein solches Verhalten zu erzeugen, wird ausgenutzt, dass die Funktion <code>WENNS()</code> immer einen wahren logischen Ausdruck mit einem Ergebnis verknüpft. Weil die logischen Ausdrücke in der Reihenfolge ausgewertet werden, wie sie in der Funktion angegeben sind, muss der letzte logische Ausdruck alle Fälle abdecken, die von keinem anderen der vorangegangen logischen Ausdrücke akzeptiert wurden. Der einfachste logische Ausdruck, der immer wahr ist, ist der Wahrheitswert <code>WAHR</code>. Deshalb wird dieser Wert als letzter logischer Ausdruck für <code>WENNS()</code> verwendet.</p>
<p>Mit diesem Wissen lässt sich das erste Beispiel mit <code>WENNS()</code> vervollständigen:</p>
<pre><code>= WENNS(A2:A3 = 1; "Eins"; 
        A2:A3 = 3; "Drei"; 
        A2:A3 = 4; "Vier"; 
        A2:A3 = 8; "Acht"; 
        WAHR; "Ungültig")</code></pre>
<p>Diese Formel prüft die Werte in <code>A2:A3</code> auf Gleichheit mit den Werten <code>1</code>, <code>3</code>, <code>4</code> und <code>8</code>. Für diese Zahlen wird die zugehörige Zahlwert als Zeichenkette ausgegeben. Falls keiner dieser Werte gefunden wird, wird der Wert <code>Ungültig</code> zurückgegeben.</p>
<p>Die Fallunterscheidung mit <code>WENNS()</code> endet beim ersten logischen Ausdruck, der <code>WAHR</code> ergibt. Die Funktion prüft der Reihe nach alle angegebenen logischen Ausdrücke. Sobald einer dieser Ausdrücke <code>WAHR</code> ist, wird der zugehörige Ergebniswert ausgegeben und die Funktion wird beendet. Diese Eigenschaft begründet, dass die logischen Ausdrück nur die Fälle prüfen müssen, die von den vorangegangenen logischen Ausdrücken nicht abgedeckt wurden.</p>
<p>(*Beispiel 2) Das folgende komplexe Beispiel zeigt, wie die Fallunterscheidung mit <code>WENNS()</code> vereinfacht werden kann.</p>
<pre><code>WENN(J2&gt;=O2;
    (WENN(J2&gt;L2;
          0;
          WENN(J2&lt;=L2;
               WENN((J2&gt;N2)*(J2&gt;=O2);
                    (K2+((M2-K2)/(N2-L2))*(J2-L2));
                    WENN((J2&lt;=N2)*(J2&lt;O2);
                         (M2+((O2-M2)/(O2-N2))*(J2-N2))
                ))
          )
    ));
    100)</code></pre>
<p>Diese Formel ist aus zwei Gründen übermässig komplex.</p>
<ol type="1">
<li>Die Fallunterscheidung mit <code>WENN()</code> ist geschachtelt.</li>
<li>Es existieren <em>redundante</em> Fallunterscheidungen.</li>
</ol>
<p>Bevor die Fallunterscheidung mit <code>WENNS()</code> vereinfacht wird, werden die redundanten Fallunterscheidungen entfernt. Das betrifft die zweite (<code>J2 &gt; L2</code>) und die vierte Fallunterscheidung (<code>J2 &gt; N2</code>). Im jeweiligen <code>FALSCH</code>-Fall wird der gegenteilige logische Ausdruck geprüft. Das ist in diesem Fall unnötig, weil die äussere Fallunterscheidung diesen Fall bereits abdeckt. Werden die redundanten logischen Ausdrücke und unnötige Klammern entfernt, dann ergibt sich die folgende wesentlich einfachere Formel.</p>
<pre><code>= WENN(J2&gt;=O2;
    WENN(J2&gt;L2;
          0;
          WENN((J2&gt;N2)*(J2&gt;=O2);
              K2+(M2-K2)/(N2-L2)*(J2-L2);
              M2+(O2-M2)/(O2-N2)*(J2-N2)
          )
    );
    100)</code></pre>
<p>Die äusserste Fallunterscheidung hat für den Fall <code>WAHR</code> eine geschachtelte <code>WENN()</code>-Funktion und im Fall <code>FALSCH</code> ein einfaches Ergebnis. Das ist für <code>WENNS()</code> unhandlich, so dass die äusserste Fallunterscheidung durch Umkehrung des logischen Ausdrucks umgestellt wird.</p>
<pre><code>= WENN(J2&lt;O2;
       100; 
       WENN(J2&gt;L2;
            0;
            WENN((J2&gt;N2)*(J2&gt;=O2);
                 K2+(M2-K2)/(N2-L2)*(J2-L2);
                 M2+(O2-M2)/(O2-N2)*(J2-N2)
            )
       )
  )</code></pre>
<p>Nun lassen sich die vier unterschiedlichen Fälle gut erkennen und mit <code>WENNS()</code> abbilden. Daraus ergibt sich die folgende Formel.</p>
<pre><code>= WENNS(J2&lt;O2; 100; 
        J2&gt;L2; 0; 
        (J2&gt;N2)*(J2&gt;=O2); K2+(M2-K2)/(N2-L2)*(J2-L2); 
        WAHR; M2+(O2-M2)/(O2-N2)*(J2-N2)
  )</code></pre>
<p>Diese Formel ist wesentlich einfacher zu lesen und zu verstehen. Beim Durchgehen der Fälle fällt auf, dass ein Teilausdruck des dritten Falls das Gegenteil des ersten Falls ist. Diese Bedingung wurde bereits im ersten Fall geprüft und würde sie nicht gelten, dann wäre die Formel bereits beendet worden. Deshalb können bereits geprüfte Teilausdrücke in den nachfolgenden Ausdrücken weggefallen. Dadurch wird nicht nur die Verschachtelung, sondern auch die Komplexität der logischen Ausdrücke vereinfacht.</p>
<pre><code>= WENNS(J2&lt;O2; 100; 
        J2&gt;L2; 0; 
        J2&gt;N2; K2+(M2-K2)/(N2-L2)*(J2-L2); 
        WAHR;  M2+(O2-M2)/(O2-N2)*(J2-N2)
  )</code></pre>
<p>Diese Formel hat jedoch den Makel, dass der letzte Fall <code>WAHR</code> keine Konstante abbildet. Besser wäre es, wenn der zweite und der letzte Fall vertauscht wären, so dass der Wert <code>0</code> der letzte Wert ist. Dazu müssen die logischen Ausdrücke umorganisiert werden. Bei der Umorganisation ist die Reihenfolge der logischen Ausdrücke zu beachten: Die letzten beiden Fälle sind nicht umabhängig vom logischen Ausdruck <code>J2&gt;L2</code>. Beim Umorganisieren darf diese Abhängigkeit nicht verloren gehen.</p>
<pre><code>= WENNS(J2&lt;O2; 100; 
        (J2&lt;=L2)*(J2&gt;N2); K2+(M2-K2)/(N2-L2)*(J2-L2); 
        J2&lt;=L2; M2+(O2-M2)/(O2-N2)*(J2-N2)
        WAHR; 0
  )</code></pre>
<p>Diese Formel ist deutlich einfacher und weniger Fehleranfällig als die ursprüngliche Formel mit geschachtelten <code>WENN()</code>-Funktionen. Es lassen sich auch weitere Fälle hinzufügen, ohne dass die Formel komplexer wird. Dabei ist zu beachten, dass diese Fälle <em>vor</em> dem Fall <code>WAHR</code> angegeben werden müssen.</p>
</section>
<section id="ersterwert" class="level3" data-number="10.4.3">
<h3 data-number="10.4.3" class="anchored" data-anchor-id="ersterwert"><span class="header-section-number">10.4.3</span> ERSTERWERT</h3>
<p>Die Funktion <code>ERSTERWERT()</code> bildet einen Spezialfall von <code>WENNS()</code> ab: Es wird bei allen logischen Ausdrücken ein Vergleich auf Gleichheit des <em>Suchkriteriums</em> mit verschiedenen Referenzwerten durchgeführt. In diesem Fall können die logischen Ausdrücke mit <code>ERSTERWERT()</code> stark vereinfacht werden. Das lässt sich am ersten Beispiel im Abschnitt <code>WENNS</code> veranschaulichen.</p>
<p>Weil alle logischen Ausdrücke die Gleichheit über den gleichen Adressbereich prüfen, kann die Operation mit der Funktion <code>ERSTERWERT()</code> vereinfacht wie folgt werden.</p>
<pre><code>= ERSTERWERT(A2:A3; 
             1; "Eins"; 
             3; "Drei"; 
             4; "Vier"; 
             8; "Acht"; 
             "Ungültig")</code></pre>
</section>
<section id="xverweis-zur-fallunterscheidung" class="level3" data-number="10.4.4">
<h3 data-number="10.4.4" class="anchored" data-anchor-id="xverweis-zur-fallunterscheidung"><span class="header-section-number">10.4.4</span> XVERWEIS zur Fallunterscheidung</h3>
<p>Die Funktion <code>XVERWEIS()</code> ist als Excels Version des <span class="math inline">\in</span>-Operators bereits bekannt. Die Funktion kann auch als Alternative zur Funktion <code>ERSTERWERT()</code> verwendet werden. In diesem Fall werden als Rückgabematrix keine Wahrheitswerte, sondern die Ergebnisse der Fallunterscheidung angegeben.</p>
<p>Der Vorteil dieser Anwendung ist, dass die Fallunterscheidung nicht mehr auf die Anzahl der Parameterpaare beschränkt ist und die Parameterpaare zum Zeitpunkt der Formelerstellung auch nicht bekannt sein müssen.</p>
<p>Das folgende Beispiel zeigt die Umsetzung des Beispiels aus dem Abschnitt <code>ERSTERWERT</code> mit <code>XVERWEIS()</code>. Dazu wird zuerst eine Tabelle mit den Vergleichswerten und den zugehörigen Ergebnissen erstellt.</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">C</th>
<th style="text-align: center;">D</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;"><code>Eins</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>3</code></td>
<td style="text-align: center;"><code>Drei</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>4</code></td>
<td style="text-align: center;"><code>Vier</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>8</code></td>
<td style="text-align: center;"><code>Acht</code></td>
</tr>
</tbody>
</table>
<p>Diese Referenztabelle stell in Spalte <code>C</code> die sog. Suchmatrix und in Spalte <code>D</code> die sog. Rückgabematrix bereit. Mit diesen Werten lässt sich die Fallunterscheidung wie folgt abbilden.</p>
<pre><code>= XVERWEIS(A2:A3; C2:D5; D2:D5; "Ungültig")</code></pre>
<p>Ein weiterer Vorteil von <code>XVERGLEICH()</code> gegenüber <code>ERSTERWERT()</code> sind Vergleiche mit den Operatoren <code>=</code>, <code>&lt;=</code> oder <code>&gt;=</code>. Diese Vergleiche lassen sich über den fünften Parameter von <code>XVERWEIS()</code> konfigurieren. Dabei steht der Wert <code>0</code> für die Gleichheit, der Wert <code>-1</code> für kleiner oder gleich und der Wert <code>1</code> für grösser oder gleich. Die Vergleiche sind immer so organisiert, dass der linke Operand dem Suchkriterium entspricht und der rechte Operand dem Wert in der Suchmatrix. Bei einem Treffer wird der Wert aus der Rückgabematrix zurückgegeben. Gibt es keinen Treffer für den Vergleich wird der Wert aus dem vierten Parameter <code>wenn_nicht_gefunden</code> geliefert.</p>
</section>
<section id="anwendungshilfe-für-fallunterscheidungen" class="level3" data-number="10.4.5">
<h3 data-number="10.4.5" class="anchored" data-anchor-id="anwendungshilfe-für-fallunterscheidungen"><span class="header-section-number">10.4.5</span> Anwendungshilfe für Fallunterscheidungen</h3>
<p>Die Anwendung der verschiedenen Fallunterscheidungsfunktionen hängt von verschiedenen Kriterien ab. Diese sind hier zusammengefasst:</p>
<p>Die Funktion <code>WENN()</code> wird immer dann eingesetzt, wenn ein logischer Ausdruck geprüft werden muss und nur die beiden Fälle dieses Ausdrucks unterschieden werden müssen.</p>
<p>Die Funktion <code>WENNS()</code> wird immer dann eingesetzt werden, wenn mehrere logische Ausdrücke geprüft werden müssen. Die logischen Ausdrücke können dabei beliebig komplex sein und sich auf verschiedene Daten und Bereiche beziehen.</p>
<p>Die Funktion <code>ERSTERWERT()</code> wird immer dann eingesetzt, wenn die Gleichheit des Suchkriteriums mit wenigen Referenzwerten überprüft werden soll. Die Suchkriterien sind für alle Vergleiche identisch.</p>
<p>Die Funktion <code>XVERWEIS()</code> wird immer dann eingesetzt, wenn ein Vergleich auf Gleichheit, Kleiner-oder-Gleich oder Grösser-oder-Gleich durchgeführt werden muss. Die Suchkriterien und die Vergleichsoperatoren sind für alle Vergleiche identisch.</p>
<p>Die Funktion <code>XVERWEIS()</code> muss anstatt von <code>ERSTERWERT()</code> verwendet werden, wenn die Referenzwerte des Vergleichs zum Zeitpunkt der Formelerstellung noch nicht bekannt sind oder leicht änderbar bleiben sollen.</p>
</section>
</section>
<section id="rezepte" class="level2" data-number="10.5">
<h2 data-number="10.5" class="anchored" data-anchor-id="rezepte"><span class="header-section-number">10.5</span> Rezepte</h2>
<section id="fehlerwerte-abfangen" class="level3" data-number="10.5.1">
<h3 data-number="10.5.1" class="anchored" data-anchor-id="fehlerwerte-abfangen"><span class="header-section-number">10.5.1</span> Fehlerwerte abfangen</h3>
<p>Viele Excel-Funktionen geben einen Fehlerwert zurück, falls die Funktion kein gültiges Ergebnis ermitteln kann. Weil sich diese Fehlerwerte in Operationen fortpflanzen, müssen diese Werte durch einen geeigneten regulären Wert ersetzt werden. Das kann mit der folgenden Entscheidung erreicht werden.</p>
<pre><code>= WENN(ISTFEHLER(A1); 0; A1)</code></pre>
<p>Diese Operation ersetzt alle Fehlerwerte durch den Wert <code>0</code> und lässt alle anderen Werte unverändert.</p>
<p>Weil diese Entscheidung sehr oft vorkommt, gibt es die Funktion <code>WENNFEHLER()</code>, mit der die gleiche Operation einfacher ausgedrückt werden kann.</p>
<pre><code>= WENNFEHLER(A1; 0)</code></pre>
</section>
<section id="eine-zahl-für-genau-eine-bedingung-zurückgeben" class="level3" data-number="10.5.2">
<h3 data-number="10.5.2" class="anchored" data-anchor-id="eine-zahl-für-genau-eine-bedingung-zurückgeben"><span class="header-section-number">10.5.2</span> Eine Zahl für genau eine Bedingung zurückgeben</h3>
<p>Ein häufiger Spezialfall für Unterscheidungen ist die Auswahl von <em>Zahlen</em>, die genau <strong>einen</strong> logischen Ausdrück erfüllen. Solche Unterscheidungen geben im <code>FALSCH</code>-Fall <code>0</code> und im anderen Fall die gesuchte Zahl zurück. In diesem Spezialfall kann der Zielwert ohne Umweg über die <code>WENN()</code>-Funktion mit dem logischen Ausdruck multipliziert werden. Der logische Ausdruck liefert <code>1</code> für <code>WAHR</code> und <code>0</code> für <code>FALSCH</code>. Die Multiplikation mit <code>0</code> liefert immer <code>0</code>. Die Multiplikation mit <code>1</code> liefert den Zielwert.</p>
<p>Das Beispiel gibt für die folgenden Werte alle Zahlen zurück, die grösser als 10 <em>und</em> kleiner als 20 sind.</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>13</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>5</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>17</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>20</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>12</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>2</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>29</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>11</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>7</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>32</code></td>
</tr>
</tbody>
</table>
<p>Normalerweise würde diese Entscheidung durch die folgende Operation abgebildet:</p>
<pre><code>= WENN((A1:A10 &gt; 10) * (A1:A10 &lt; 20); A1:A10; 0)</code></pre>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warnung
</div>
</div>
<div class="callout-body-container callout-body">
<p>Diese spezielle Fallunterscheidung sollte auf Korrektheit überprüft werden, wenn im <code>WAHR</code>-Fall der Wert <code>0</code> erlaubt ist. In diesem Fall wird der Wert <code>0</code> nicht vom logischen Ausdruck unterschieden.</p>
</div>
</div>
<p>Weil alle Werte Zahlen sind, handelt es sich um den Spezialfall, dass der <code>WAHR</code>-Wert eine Zahl und der <code>FALSCH</code>-Fall eine 0 ist. Für diesen Fall lässt sich die Formel vereinfachen, indem die gesuchten Werte mit dem logischen Ausdruck multipliziert werden:</p>
<pre><code>= A1:A10 * (A1:A10 &gt; 10) * (A1:A10 &lt; 20)</code></pre>
<p>Das Ergebnis beider Formeln sind die Werte <code>{13;0;17;0;12;0;0;11;0;0}</code>.</p>
<p>Damit dieses Rezept funktioniert, müssen <em>alle</em> Teile des logischen Ausdrucks genau die Werte FALSCH oder WAHR bzw. 0 oder 1 zurückgeben. Das ist notwendig, weil nur das neutrale Element die Zielwerte unverändert lässt. Eine direkte Übergabe von Zahlen im logischen Ausdruck verfälscht das Ergebnis, weil nicht mit dem <em>neutralen Element</em> gerechnet wird.</p>
<p>Soll für einen logischen Ausdruck nur der Wert 1 oder 0 zurückgegeben werden, dann kann der Rückgabebereich am Anfang der Formel weggelassen werden. Es wird dann nur der logische Ausdruck angegeben. Die Formel <code>= (A1:A10 &gt; 10) * (A1:A10 &lt; 20)</code> hat die Werte <code>{1;0;1;0;1;0;0;1;0;0}</code> als Ergebnis.</p>
</section>
<section id="fehlerwerte-vergleichen" class="level3" data-number="10.5.3">
<h3 data-number="10.5.3" class="anchored" data-anchor-id="fehlerwerte-vergleichen"><span class="header-section-number">10.5.3</span> Fehlerwerte vergleichen</h3>
<p>Fehlerwerte können nicht direkt mit den Vergleichsoperatoren verglichen werden, weil Excel immer den ersten gefundenen Fehlerwert als Ergebnis einer Operation zurückgibt. Deshalb müssen Fehlerwerte zuerst in normale Werte konvertiert werden. Damit verschiedene Fehlerwerte miteinander verglichen werden können, müssen die verschiedenen Fehlerwerte zuerst in eindeutige Zahlen umgewandelt werden. Das übernimmt die Funktion <code>FEHLER.TYP()</code>. Diese Zahlen können anschliessend wie gewohnt weiter verarbeitet werden.</p>
<p>Das folgende Beispiel weist den gegebenen Fehlerwerten eine Fehlermeldung zu:</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>#NV</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>#WERT!</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>3</code></td>
</tr>
</tbody>
</table>
<p>Die folgende Formel liefert die Werte <code>{"Fehler: #NV"; "Fehlerhafter Wert", "Kein Fehler"}</code>.</p>
<pre><code>= WENNS(FEHLER.TYP(A1:A2) = 7; "Fehler: #NV"; 
        FEHLER.TYP(A1:A2) = 3; "Fehlerhafter Wert"; 
        WAHR; "Kein Fehler")</code></pre>
<p>Weil alle Vergleiche die Gleichheit überprüfen, kann die Formel mit der Funktion <code>ERSTERWERT()</code> vereinfacht werden. Die Formel lautet dann:</p>
<pre><code>= ERSTERWERT( WENNFEHLER(FEHLER.TYP(A1:A3); 0);
              3; "Fehlerhafter Wert";
              7; "Fehler: #NV";
              "Kein Fehler")</code></pre>
<p>Für diesen Schritt muss die Operation mit der Funktion <code>WENNFEHLER()</code> erweitert werden, weil die Funktion <code>FEHLER.TYP()</code> einen Fehler ausgibt, wenn der übergebene Wert kein Fehlerwert ist. Weil die Fehlertypen mit Werten grösser <code>0</code> durchnummeriert sind, bietet sich für reguläre Werte der Wert <code>0</code> an.</p>
<hr>
<p>Die Basisfunktionen für das Sortieren sind die Funktionen <code>sort()</code> (R) und <code>SORTIEREN()</code> (Excel). Diese Funktionen bringen einen Vektor in die gewünschte Reihenfolge. Beide Funktionen können nur nach einem Vektor sortieren. Deshalb eignen sie sich nur für einfache Sortierungen.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hinweis
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Excels <code>SORTIEREN()</code>-Funktion</strong> kann einen Bereich zeilen- oder spaltenweise sortieren. Diese Funktion hat vier Parameter:</p>
<ul>
<li><code>Matrix</code> - der zu sortierende Bereich, der <em>keine</em> Matrix sein muss.</li>
<li><code>Sortierindex</code> - die Spalten- oder Zeilennummer, nach der sortiert werden soll. Standardmässig wird die erste Spalte bzw. die erste Zeile angenommen.</li>
<li><code>Sortierreihenfolge</code> - legt die Sortierreihenfolge fest. <code>1</code>, um aufsteigend und <code>-1</code>, um absteigend zu sortieren.</li>
<li><code>nach_Spalte</code> - Ein Wahrheitswert, ob die Spalten oder die Zeilen sortiert werden sollen. <code>WAHR</code> bedeutet, dass die Spalten (horizontal) sortiert werden sollen. <code>FALSCH</code> bedeutet, dass die Zeilen (vertikal) sortiert werden sollen. Standardmässig wird zeilenweise sortiert.</li>
</ul>
</div>
</div>
<section id="die-funktionen-arrange-und-sortierennach" class="level4" data-number="10.5.3.1">
<h4 data-number="10.5.3.1" class="anchored" data-anchor-id="die-funktionen-arrange-und-sortierennach"><span class="header-section-number">10.5.3.1</span> Die Funktionen <code>arrange()</code> und <code>SORTIERENNACH()</code></h4>
<p>Für allgemeine Sortierungen nach mehreren Vektoren stellen Excel und R eigene Funktionen bereit. Zwei dieser Funktionen heben sich wegen ihrer Flexibilität besonders ab. Ihnen liegt der gleiche Denkprozess zu Grunde. Diese beiden Funktionen sind:</p>
<ul>
<li>Die R-Funktion <code>arrange()</code> und</li>
<li>die Excel-Funktion <code>SORTIERENNACH()</code>.</li>
</ul>
<p>Beide Funktionen ermöglichen uns, mehrere Vektoren auf einmal nach <strong>mehreren</strong> gemeinsamen Kriterien zu sortieren. Dazu müssen wir zuerst die Sortierkriterien identifizieren.</p>
</section>
<section id="schritt-1-sortierkriterien-festlegen." class="level4" data-number="10.5.3.2">
<h4 data-number="10.5.3.2" class="anchored" data-anchor-id="schritt-1-sortierkriterien-festlegen."><span class="header-section-number">10.5.3.2</span> Schritt 1: Sortierkriterien festlegen.</h4>
<p>Die Sortierkriterien sind durch die Werte in Vektoren festgelegt, nach denen sortiert werden soll. Wir können dazu mehrere Vektoren festlegen, deren Werte nacheinander zum Sortieren unserer Daten verwendet werden. In R legen wir die Suchkriterien über die entsprechenden <em>Vektornamen</em> und in Excel über entsprechende Vektoren oder Bereiche fest.</p>
<ul>
<li>In R müssen die Vektoren mit den Suchkriterien im Stichprobenobjekt vorhanden sein.<br>
</li>
<li>In Excel können die Vektoren mit den Suchkriterien an einer beliebigen Position in einer Arbeitsmappe liegen. Dabei müssen zwei Bedingungen erfüllt sein:
<ol type="1">
<li>Die Vektoren müssen die gleiche Länge haben.</li>
<li>Die Vektoren müssen die gleiche Orientierung haben.</li>
</ol></li>
</ul>
</section>
<section id="schritt-2" class="level4" data-number="10.5.3.3">
<h4 data-number="10.5.3.3" class="anchored" data-anchor-id="schritt-2"><span class="header-section-number">10.5.3.3</span> Schritt 2:</h4>
<p>Im zweiten Schritt werden die zu sortierenden Vektoren ausgewählt.</p>
<p>In R wird dieser zweite Schritt automatisch auf die vorgegebene Stichprobe angewandt. In Excel können wir zusammenhängende Vektoren als “Matrix” an die <code>SORTIERENNACH()</code>-Funktion übergeben. Hängen die Vektoren nicht direkt zusammen, dann müssen mehrere Sortieroperationen mit den gleichen Referenzen auf die Sortierreferenzen durchgeführt werden.</p>
</section>
</section>
<section id="sortierreihenfolge" class="level3" data-number="10.5.4">
<h3 data-number="10.5.4" class="anchored" data-anchor-id="sortierreihenfolge"><span class="header-section-number">10.5.4</span> Sortierreihenfolge</h3>
<p>In Excel wird die Sortierrichtung als <code>Sortierreihenfolge</code> bezeichnet und als separater Parameter für das jeweilige Sortierkriterium angegeben. Dabei steht <code>1</code> für die aufsteigende Sortierung und <code>-1</code> für die absteigende Sortierung.</p>
<p>In R wird grundsätzlich von einer aufsteigenden Sortierung ausgegangen. Um eine absteigende Sortierung zu erreichen, verwenden wir die Hilfsfunktion <code>desc()</code> (für engl. <em>descending</em> ~ <em>absteigend</em>).</p>
<p>Das folgende R-Beispiel zeigt, wie die Daten im Stichprobenobjekt, zu erst absteigend nach dem <code>natel</code>-Vektor und anschliessend nach dem <code>geschlecht</code>-Vektor sortiert werden.</p>
<pre><code>daten %&gt;% 
    arrange(
         desc(natel), # Sortierkriterium absteigend sortiert
         geschlecht   # Sortierkriterium aufsteigend sortiert
    )</code></pre>
</section>
<section id="einfache-verzweigungen" class="level3" data-number="10.5.5">
<h3 data-number="10.5.5" class="anchored" data-anchor-id="einfache-verzweigungen"><span class="header-section-number">10.5.5</span> Einfache Verzweigungen</h3>
<p>Excels Entscheidungsfunktion ist die <code>WENN()</code>-Funktion. Diese Funktion hat drei Parameter:</p>
<ol type="1">
<li>Einen logischen Ausdruck - dieser Parameter wird als Wahrheitswert interpretiert.</li>
<li><code>WAHR</code>-Ergebnis - dieser Parameter wird als Ergebnis zurückgegeben, wenn der erste Parameter <code>WAHR</code> ist.</li>
<li><code>FALSCH</code>-Ergebnis - dieser Parameter wird als Ergebnis zurückgegeben, wenn der erste Parameter <code>FALSCH</code> ist.</li>
</ol>
<p>Diese Funktion entscheidet mit Hilfe des logischen Ausdrucks, welcher der beiden anderen Parameter zurückgegeben werden muss.</p>
<p>In R heisst diese Funktion <code>ifelse()</code> und hat genau die gleichen Parameter.</p>
<p>Häufig finden wir Formeln, in denen einfach ein Wert als erster Parameter an die <code>WENN()</code>-Funktion übergeben wird. Dieser Wert wird als logischer Ausdruck interpretiert. Dabei wird der Wert <code>0</code> mit dem Wahrheitswert <code>FALSCH</code> gleichgesetzt und Werte ungleich <code>0</code> werden als <code>WAHR</code> interpretiert.</p>
</section>
<section id="abbruchbedingungen" class="level3" data-number="10.5.6">
<h3 data-number="10.5.6" class="anchored" data-anchor-id="abbruchbedingungen"><span class="header-section-number">10.5.6</span> Abbruchbedingungen</h3>
<div id="def-abbruchbedingung" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 10.1 </strong></span>Eine <strong>Abbruchbedingung</strong> ist eine spezielle Entscheidung, die einen Algorithmus beendet. Dabei wird zwischen einem <em>konstanten</em> Wert und einem <em>dynamischen</em> Wert entschieden.</p>
</div>
<p>Mit Hilfe von Abbruchbedingungen “schützen” wir unsere Programmlogik vor unerwünschten oder fehlerhaften Werten.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hinweis
</div>
</div>
<div class="callout-body-container callout-body">
<p>Genau genommen bricht dieses Konzept nicht ab, sondern verwendet die dynamischen Werte des Vektors nicht mehr. Stattdessen werden konstante Werte zurückgegeben. Für diese Werte müssen wir einen Wert wählen, der den logischen Ausdruck der Abbruchbedingung weiterhin so erfüllt, dass der Algorithmus diese Werte ignoriert.</p>
</div>
</div>
</section>
<section id="komplexe-entscheidungen" class="level3" data-number="10.5.7">
<h3 data-number="10.5.7" class="anchored" data-anchor-id="komplexe-entscheidungen"><span class="header-section-number">10.5.7</span> Komplexe Entscheidungen</h3>
<p>Komplexe Entscheidungen können wir uns als eine Folge einfacher Entscheidungen vorstellen. Weil solche Entscheidungen sehr unübersichtlich sein können, bieten Excel und R Kurzformen an, mit denen wir solche Folgen einfacher schreiben können.</p>
</section>
<section id="excels-wenns" class="level3" data-number="10.5.8">
<h3 data-number="10.5.8" class="anchored" data-anchor-id="excels-wenns"><span class="header-section-number">10.5.8</span> Excels WENNS</h3>
<p>Die <code>WENNS()</code>-Funktion erlaubt es uns, verschiedene Entscheidungen zusammenzufassen. Dabei gibt es immer Paare von logischen Ausdrücken und Ergebniswerten. Die <code>WENNS()</code>-Funktion prüft nacheinander die logischen Ausdrücke und liefert als Ergebnis den Wert, der zum ersten logischen Ausdruck gehört, der WAHR ergibt.</p>
<div id="exm-wenns-linear" class="theorem example">
<p><span class="theorem-title"><strong>Beispiel 10.1 (Linearer Entscheidungsbaum) </strong></span>&nbsp;</p>
<pre><code>=WENNS( A1 &gt; 5; "Sehr gut"; A1 &gt; 4; "Gut"; A1 &gt; 3; "Genügend"; A1 &lt;= 3; "Ungenügend")</code></pre>
</div>
<p>Beachten Sie, dass im <a href="#exm-wenns-nicht-erreichbar">Beispiel&nbsp;<span>10.2</span></a> der zweite logische Ausdruck auch für die Werte des ersten logischen Ausdrucks WAHR ergeben würde. Weil aber diese Fälle bereits durch den ersten logischen Ausdruck abgefangen werden, kommen diese gar nicht mehr zum zweiten logischen Ausdruck. Entsprechend müssen Sie aufpassen, dass die logischen Ausdrücke sich nicht überschneiden.</p>
<div id="exm-wenns-nicht-erreichbar" class="theorem example">
<p><span class="theorem-title"><strong>Beispiel 10.2 (Nicht erreichbare Entscheidungen) </strong></span>&nbsp;</p>
<pre><code>=WENNS( A1 &gt; 5; "Sehr gut"; A1 &gt; 3; "Genügend"; A1 &gt; 4; "Gut"; A1 &lt;= 3; "Ungenügend")</code></pre>
</div>
<p>In <a href="#exm-wenns-nicht-erreichbar">Beispiel&nbsp;<span>10.2</span></a> kann nie das Ergebnis “Gut” angezeigt werden, weil der zweite logische Ausdruck (A1 &gt; 3) alle Werte “maskiert”, die durch den dritten logischen Ausdruck (A1 &gt; 4) als “Gut” markiert werden müssten. “Ungenügend” würde trotzdem angezeigt werden, wenn der Wert in A1 entweder 1, 2 oder 3 ist.</p>
<p>In diesem Beispiel kann die Entscheidung <code>A1 &gt; 4</code> nicht erreicht werden, weil das vorherige und allgemeinere Kriterium <code>A1 &gt; 3</code> für die gleichen Werte zutrifft.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Merke
</div>
</div>
<div class="callout-body-container callout-body">
<p>Es müssen immer die spezielleren Kriterien vor den allgemeineren Kriterien geprüft werden.</p>
</div>
</div>
<p>Es ist guter Stil, das letzte Parameterpaar immer für den gültigen logischen Ausdruck <code>WAHR</code> zu reservieren. Damit stellen Sie sicher, dass für jeden möglichen Eingabewert ein gültiges Ergebnis zurückgegeben wird. Dieser Schritt ist notwendig, weil <code>WENNS()</code> keine Alternativausgabe hat.</p>
<div id="exm-wenns-wahr" class="theorem example">
<p><span class="theorem-title"><strong>Beispiel 10.3 (Abschliessender Standardwert mit <code>WAHR</code>) </strong></span>&nbsp;</p>
<pre><code>=WENNS( A1 &gt; 5; "Sehr gut"; A1 &gt; 4; "Gut"; A1 &gt; 3; "Genügend"; UND(A1 &lt;= 3; A1 &gt; 0); "Ungenügend"; WAHR; "Nicht angetreten")</code></pre>
</div>
</section>
<section id="sonstige-entscheidungen-in-excel" class="level3" data-number="10.5.9">
<h3 data-number="10.5.9" class="anchored" data-anchor-id="sonstige-entscheidungen-in-excel"><span class="header-section-number">10.5.9</span> Sonstige Entscheidungen in Excel</h3>
<p>In Excel gibt es zusätzlich die beiden Funktionen <code>WENNFEHLER()</code> und deren spezialisierte Form <code>WENNNV()</code>. Diese Funktionen erlauben eine kompaktere Schreibweise der typischen Fehlerbehandlung: Wenn kein Fehler erzeugt wird, dann wird das Ergebnis der Formel des ersten Parameters als Ergebnis geliefert. Wird ein Fehler erzeugt, dann wird der 2. Parameter als Rückfallwert zurückgegeben.</p>
<p>Wir sparen uns mit diesen beiden Funktionen die Schreibweise:</p>
<pre><code>=WENN(ISTFEHLER(A1); "Rückfallwert", A1)</code></pre>
<p>Stattdessen schreiben wir:</p>
<pre><code>=WENNFEHLER(A1, "Rückfallwert")</code></pre>
<p>Das ist leichter verständlich, als die ausführliche Variante mit <code>WENN()</code>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../kapitel/zeichenketten/kapitel.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Zeichenketten</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../kapitel/vektor-operationen/kapitel.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Vektoroperationen</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>